[
  {
    "id": "DELTA.CONTROL.BlochTetrapole.v1",
    "type": "protocol",
    "title": "Î”-Bloch Tetrapole (Zâ‚‚Ã—U(1) Control on a Sphere)",
    "summary": "Unifies the four Î” control axes on an SÂ² â€˜Blochâ€™ sphere: poles encode binary (Zâ‚‚) choices; the equator encodes cyclic (U(1)) phases. Low-order landings are preferred; eligibility/stability/brittleness gates prevent phase forcing.",
    "defs": [
      "state n(Î¸,Ï†) âˆˆ SÂ²",
      "axes g_F,g_P,g_A,g_S (Frequency, Phase, Amplitude, Space)",
      "low-order set R_L={1:1,2:1,3:2, â€¦}",
      "eligibility Îµ_cap, stability Îµ_stab, brittleness Î¶"
    ],
    "equations": [
      "V(Î¸,Ï†)= Î£_{Î±âˆˆ{F,P,A,S}} Î±_Î± Â· d^2(n, Î _Î±(n)) + Î»(p+q) + Î³ Î´^2",
      "phase error e_Ï† = wrap(p Î¸_b âˆ’ q Î¸_a);  Ï†Ì‡ âˆ âˆ’sin(e_Ï†)",
      "priority: F â†’ P â†’ A â†’ S; one Snap/axis/window"
    ],
    "audits": [
      "E0 calibration of phase/angle gauges",
      "E1 stable phases; well-behaved instantaneous frequency",
      "E2 gauge/symmetry invariance",
      "E3 tiny on-manifold nudges: Î´Ï‰ (F), Â±5â€“15Â° (P), MWU reweights (A), counted rest (S) â‡’ monotone Î”H*â†‘ inside capture; off-manifold â‰ˆ null",
      "E4 low-order persistence under Ã—2 downsample/blur; high order dies"
    ],
    "nulls": [
      "phase shuffles",
      "blocked shuffles (preserve coarse clocks)",
      "amplitude-matched noise"
    ],
    "steer": "Follow Î” priority. Snap F only if |s_F|>1 or trending â†‘; release at Ï„_F. Trim phase only with Îµ_cap>0. Reweight amplitudes via MWU then simplex project. Insert rests at strongest low-order phases to restore contrast.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.CORE.PotentialActualizationDual.v1",
    "type": "principle",
    "title": "PAD: Potential â†’ Actualization Dual",
    "summary": "Operationalizes â€˜zero as availabilityâ€™: candidates live as potential with MDL+detune priors; they actualize only when capture & stability are positive and Î”H* rises under micro-steers.",
    "defs": [
      "candidate locks ğ“›={(i,j,p:q)}",
      "potential field Î (i,j,p:q)",
      "actualization indicator ğ’œ(i,j,p:q)"
    ],
    "equations": [
      "Î  âˆ exp(âˆ’Î»(p+q)) Â· exp(âˆ’Î³ Î´^2) Â· 1{E0â€“E2 pass}",
      "ğ’œ = 1{Îµ_cap>0 âˆ§ Îµ_stab>0 âˆ§ Î¶ â‰¤ Î¶_max âˆ§ Î”H*â†‘ under E3}"
    ],
    "audits": [
      "E0â€“E2 hygiene required before Î >0",
      "E3 on-manifold micro-nudges must raise Î”H* when Î  is high; off-manifold â‰ˆ null",
      "E4 actualized low-order persists under Ã—2 coarse-grain"
    ],
    "nulls": ["phase/label shuffles", "amplitude-matched surrogates"],
    "steer": "If Î  high but ğ’œ=0, widen Îµ (eligibility) or strengthen K; otherwise break and search a lower-order candidate.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.CORE.ActualizedComplexityIndex.v1",
    "type": "equation",
    "title": "ACI: Actualized Complexity Index",
    "summary": "Quality-weighted sum of robust, low-order actualizations. Tracks the â€˜opposite of superpositionâ€™: what really landed, stably, with low brittleness.",
    "defs": ["weights w_{p:q} âˆ exp(âˆ’Î»(p+q))", "K (lock score), Î“ (coherence), Î¶ (brittleness)"],
    "equations": [
      "ACI = Î£_{(i,j,p:q)âˆˆğ“›} w_{p:q} Â· ğ’œ(i,j,p:q) Â· [ |K| + Î² Î“ âˆ’ Î²' Î¶ ]"
    ],
    "audits": [
      "E3 ACIâ†‘ under tiny on-manifold steers",
      "E4 ACI dominated by low order across coarse-grains"
    ],
    "nulls": ["shuffles preserving marginals", "blocked shuffles"],
    "steer": "Maximize ACI subject to Î¶ guardrails; prefer small increases in K that reduce Î¶ over brittle spikes.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.INFER.TruthTriangulation.v1",
    "type": "protocol",
    "title": "TTE: Truth-Triangulation Engine",
    "summary": "Composes two accepted edges into a third candidate via rational composition, admitting only MDL-winning, robust composites that survive RG.",
    "defs": [
      "accepted edges L_ab^{p:q}, L_bc^{r:s}",
      "composite candidate L_ac^{pr:qs} (in lowest terms)"
    ],
    "equations": [
      "order penalty on composite: pr+qs",
      "accept only if Î”H*composite > (Î”H*ab + Î”H*bc) and MDL gain > 0"
    ],
    "audits": [
      "E3 minimal steer along composite manifold increases K and reduces Î¶",
      "E4 composite persists under Ã—2 coarse-grain while parts persist"
    ],
    "nulls": ["composite on shuffled surrogates must fail MDL/Î”H* tests"],
    "steer": "Propose composites only between robust primaries; demote if Î¶ increases or MDL loses.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.CORE.PolarityAudit.v1",
    "type": "principle",
    "title": "DPA: Î” Polarity Audit (Real vs Privative)",
    "summary": "Decides whether a pair is a true polarity (Zâ‚‚ dual with two positive basins) or a privative complement (X vs lack-of-X). Guides controller behavior and interpretation.",
    "defs": [
      "Zâ‚‚ symmetry test (approximate involution)",
      "bidirectional convertibility within capture",
      "positive resources (both sides show non-zero order parameters)"
    ],
    "equations": [
      "DPA(X,Y)=1 if (Zâ‚‚ symmetry âˆ§ finite-cost Xâ†”Y steers âˆ§ both basins positive); else 0 (privative)"
    ],
    "audits": [
      "E3: finite on-manifold steers switch basins both ways for real polarities",
      "E4: both basins persist under Ã—2 coarse-grain for real polarities"
    ],
    "nulls": ["observer-budget checks to avoid misclassifying band-limited zeros as true â€˜darkâ€™"],
    "steer": "Treat privatives as one-sided: add presence; donâ€™t â€˜convertâ€™ absence.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.MUSIC.MeterDebt.v1",
    "type": "protocol",
    "title": "Meter Coherence & Debt",
    "summary": "Quantifies why even meters feel propulsive, ternary meters feel circular, 6/8 feels like both, and 5/7 feel uneasy: relief arrives at low-order phases; debt accumulates otherwise.",
    "defs": [
      "structural clock Ï†_S mod N",
      "strong set S_N = {k/N with denominator âˆˆ {1,2,3}}",
      "anticipation Îº(t), relief R(T), debt D_N(T)",
      "MCI_N (Meter Comfort Index), DivSig(N)=1_{2|N}+1_{3|N}, MidGap(N)=min_k |1/2 âˆ’ k/N|"
    ],
    "equations": [
      "D_N(T)=âˆ«_0^T Îº(t) dt âˆ’ R(T)",
      "R(T)= Î£_{Ï„â‰¤T} Ï(Ï„) Â· 1{dist(Ï†_S(Ï„), S_N) â‰¤ Îµ}",
      "MCI_N = |S_N| âˆ’ Î² Â· mean_gap(S_N)"
    ],
    "audits": [
      "E3: Â±2% tempo stretch or counted rest at S_N â‡’ Î”AIâ†“, Kâ†‘; off-phase â‰ˆ null",
      "E4: effects persist across tempo (fastâ‰slow) and downsampled bars"
    ],
    "nulls": ["onset shuffles", "uniform gaps", "meter-label permutations"],
    "steer": "In 5/7, pay debt with the minimal relief near surrogate S_N (hemiola hints). In 6/8, accent both 1/2 and 1/3 phases to amplify â€˜hybridâ€™ comfort.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.SOC.SynchronicityOperator.v1",
    "type": "protocol",
    "title": "Synchronicity as Low-Order Cross-Clock Coincidence",
    "summary": "Counts meaningful coincidences as accepted small-integer locks across clocks, guarded by strong nulls and RG. Forbids phase forcing outside capture.",
    "defs": [
      "clocks a,b with phases Ï†_a, Ï†_b",
      "low-order set R_L, weights w_{p:q} âˆ exp(âˆ’Î»(p+q))",
      "coherence Î“_{ab}^{(p:q)}, detune Î´"
    ],
    "equations": [
      "Î¾ = Î£_{p:qâˆˆR_L} w_{p:q} Â· 1{ |Ï‰Ì„_b/Ï‰Ì„_a âˆ’ p/q| < Ï„ âˆ§ Î“_{ab}^{(p:q)} â‰¥ Î“_min }"
    ],
    "audits": [
      "E3: micro-nudges increase Î¾ only when Îµ_cap>0; off-phase â‰ˆ null",
      "E4: Î¾ at low order survives Ã—2 pooling; high order collapses"
    ],
    "nulls": ["phase/label shuffles", "blocked shuffles preserving seasonality"],
    "steer": "Bias estimation and scheduling toward strongest low-order coincidences that pass audits; never force phase outside capture.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.MIND.PriorTiltedCapture.v1",
    "type": "protocol",
    "title": "Prior-Tilted Capture (Visualization/Placebo as Îºâ†‘ or D_Ï†â†“)",
    "summary": "Belief/visualization deepens capture wells (Îº) or reduces phase diffusion (D_Ï†), expanding Îµ_cap and Îµ_stab. Measured via a physiological Anticipation Index.",
    "defs": [
      "well depth Îº, phase diffusion D_Ï†",
      "AI = z_pupil + z_EMG + z_tapLead âˆ’ z_HRVcoh"
    ],
    "equations": [
      "Îµ_cap = [2Ï€ K âˆ’ (Î“_i + Î“_j)]_+",
      "Îµ_stab âˆ K âˆ’ c Â· D_Ï†",
      "âˆ‚AI/âˆ‚Î´ < 0 for aligned micro-nudges at low-order phases"
    ],
    "audits": [
      "E3: Â±2% tempo or Â±15 ms gap at strong phases â‡’ AIâ†“, Kâ†‘; off-phase â‰ˆ null",
      "E4: same signatures after tempo scaling / coarse-grain"
    ],
    "nulls": ["placebo nudges at off-phases", "random edits"],
    "steer": "Use minimal on-phase nudges; stop when Î¶ rises or AI no longer drops.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.COMPLEX.MandelLock.v1",
    "type": "protocol",
    "title": "Mandelbrot Locking: Bulbs as Low-Order Captures",
    "summary": "Maps quadratic family dynamics to Î” locks: hyperbolic bulbs labeled by small rationals behave like capture tongues; eligibility, stability, brittleness, and RG map cleanly.",
    "defs": [
      "map f_c(z)=z^2+c",
      "external angle Î¸ (doubling map)",
      "rotation number Ï(c)=p/q in a bulb",
      "multiplier Î» of attracting cycle"
    ],
    "equations": [
      "K_{p:q}(c) = âŸ¨ cos(p Î¸_{n+1} âˆ’ q Î¸_n) âŸ© Â· e^{âˆ’Î»(p+q)} Â· e^{âˆ’Î³ Î´}",
      "Îµ_stab âˆ 1 âˆ’ |Î»|;  Î¶ âˆ âˆ‚|Î»|/âˆ‚c"
    ],
    "audits": [
      "E3: tiny Î´c toward bulb center â‡’ Kâ†‘, Îµ_stabâ†‘, Î¶â†“, H* (legibility)â†‘ vs off-manifold Î´c",
      "E4: low-order bulb salience persists under blur/downsample/tuning; high-order filigree dies"
    ],
    "nulls": [
      "angle shuffles",
      "iteration shuffles",
      "histogram-matched noise for images"
    ],
    "steer": "F: slide c into nearest low-order bulb; P: align external angle landing; A: adjust sampling/iteration weights; S: apply spatial sparsity/contrast to improve legibility without hallucinating.",
    "version": "1.0",
    "updated": "2025-10-07"
  }
]

[
  {
    "id": "DELTA.MATH.EulerIdentity.v1",
    "type": "principle",
    "title": "Eulerâ€™s Identity as the Minimal Phase Closure",
    "summary": "e^{iÏ€}+1=0 is the canonical half-turn closure on U(1): a Ï€ rotation sends the unit phasor to âˆ’1. It unifies 0/1 (availability/event), i (quarter-turn operator), e (growth-to-rotation bridge), and Ï€ (radian measure).",
    "defs": [
      "unit circle U(1)",
      "phasor u(Î¸)=e^{iÎ¸}",
      "half-turn (Ï€) and full-turn (2Ï€)"
    ],
    "equations": [
      "e^{iÏ€} + 1 = 0",
      "e^{iÎ¸} = cos Î¸ + i sin Î¸",
      "u(Î¸+Ï€) = âˆ’u(Î¸),  u(Î¸+2Ï€) = u(Î¸)"
    ],
    "audits": [
      "E1: Stable instantaneous phase/frequency (vibration) so U(1) is well-defined",
      "E2: Gauge invariance: adding a constant phase to all channels leaves claims unchanged",
      "E3: Â±Ï€ phase-nudge flips sign of real part and predicts antiphasic cancellation",
      "E4: Half/full-turn effects persist under coarse-grain (downsample/blur)"
    ],
    "nulls": ["phase-shuffle surrogates that break coherent Ï€ relations"],
    "steer": "Use Ï€-shifts to invert contributions (A-axis) and 2Ï€ to restore; never force phase when Îµ_capâ‰¤0."
  },
  {
    "id": "DELTA.MATH.PhasorField.v1",
    "type": "equation",
    "title": "Phasor Field & Order Parameter",
    "summary": "Defines Î”â€™s native complex field for aggregation and locking; Eulerâ€™s formula gives the real/imag projections that all Î” kernels use.",
    "defs": [
      "channel phases Î¸_i, amplitudes A_iâ‰¥0",
      "phasor X = Î£_i A_i e^{iÎ¸_i}",
      "order parameter R = |X| / Î£_i A_i",
      "contribution C_i = cos(Î¸_i âˆ’ arg X) âˆ’ R"
    ],
    "equations": [
      "X = Î£_i A_i (cos Î¸_i + i sin Î¸_i)",
      "R = |X| / Î£_i A_i âˆˆ [0,1]",
      "C_i = cos(Î¸_i âˆ’ arg X) âˆ’ R (amplitude reweighting signal)"
    ],
    "audits": [
      "E1: Narrowband peaks ensure Î¸_i are meaningful",
      "E2: Invariance under Î¸_i â†’ Î¸_i + Ï† (global gauge)",
      "E3: Small phase trims Â±5â€“15Â° increase R when aligned with arg X",
      "E4: R ranking persists under Ã—2 coarse-grain"
    ],
    "nulls": ["amplitude-matched but phase-scrambled data"],
    "steer": "Phase-align toward arg X; apply multiplicative weights on A_i using C_i; stop at Î¶ guardrails."
  },
  {
    "id": "DELTA.MATH.RatioAngleBridge.v1",
    "type": "equation",
    "title": "Angles for Small-Integer Ratios",
    "summary": "Maps p:q locks to rational angles that Euler exponentiates; low (p+q) â‡’ faster re-alignment and stronger MDL prior.",
    "defs": [
      "ratio r = p/q in lowest terms",
      "phase relation Î”_{p:q} = p Î¸_b âˆ’ q Î¸_a (mod 2Ï€)"
    ],
    "equations": [
      "K_{p:q} = âŸ¨cos(Î”_{p:q})âŸ© Â· e^{âˆ’Î»(p+q)} Â· e^{âˆ’Î³ |Ï‰Ì„_b/Ï‰Ì„_a âˆ’ p/q|}",
      "Lock at p:q â‡” Î”_{p:q} concentrates near 0 (mod 2Ï€)"
    ],
    "audits": [
      "E1: Instantaneous frequencies Ï‰_a, Ï‰_b stable in-window",
      "E2: Swap aâ†”b maps p:q â†” q:p consistently",
      "E3: Tiny Î´Ï‰ drives |Î”_{p:q}| â†’ 0 and raises K_{p:q} inside capture",
      "E4: Low-order K_{p:q} persists under Ã—2 coarse-grain; high order decays"
    ],
    "nulls": ["phase-shuffle between channels", "blocked shuffles preserving marginals"],
    "steer": "Prioritize smallest p+q candidates; retune frequencies before phase trims."
  },
  {
    "id": "DELTA.MUSIC.InversionHalfTurn.v1",
    "type": "protocol",
    "title": "Antiphase Inversion via Ï€-Shifts",
    "summary": "Uses Eulerâ€™s half-turn to cancel or unveil parts: a Ï€ phase flip inverts a contributor; 2Ï€ restores. Minimal edits produce large perceived changes.",
    "defs": [
      "Ï€-shift operator I_Ï€: Î¸ â†’ Î¸+Ï€",
      "on-manifold phase trim Î´Ï†",
      "eligibility Îµ_cap, stability Îµ_stab"
    ],
    "equations": [
      "y(t) = Î£_i A_i cos(Î¸_i(t))",
      "I_Ï€(y_k): Î¸_k â†’ Î¸_k + Ï€ â‡’ contribution flips sign",
      "Î”H* â†‘ when canceling dissonant contributors with Îµ_cap>0"
    ],
    "audits": [
      "E3: Â±Ï€ on a targeted part reduces dissonance (D) and increases harmony H* vs. sham Â±Ï€ on off-phase parts",
      "E4: Antiphase cancellation signature persists under tempo scaling"
    ],
    "nulls": ["random Â±Ï€ on non-contributing parts (no systematic Î”H*)"],
    "steer": "Only apply Ï€-shifts when Îµ_cap>0 and Î¶ low; revert with 2Ï€ if brittleness rises."
  },
  {
    "id": "DELTA.MATH.EulerMDLPenalty.v1",
    "type": "principle",
    "title": "MDL Preference for Euler Bases",
    "summary": "Representing periodic structure with e^{iÎ¸} (Euler form) minimizes code length: addition â†” superposition; multiplication â†” phase additivity. This is Î”â€™s shortest code for cycles.",
    "defs": [
      "model class Q_e using complex exponentials",
      "model class Q_trig using separate sin/cos"
    ],
    "equations": [
      "MDL(Q_e) â‰¤ MDL(Q_trig) for equal predictive fit on U(1)",
      "argmax_Q I(Q;O) âˆ’ Î» MDL(Q) prefers Euler phasors for cyclic data"
    ],
    "audits": [
      "Compression test: code-length(Q_e) < code-length(Q_trig) at matched OOS error",
      "E4: Preference remains under downsample (RG)"
    ],
    "nulls": ["random phases where neither model gains MDL advantage"],
    "steer": "Default to complex phasors for Î” pipelines; demote only if counter-evidence beats MDL + OOS."
  }
]

[
  {
    "id": "DELTA.MATH.FourierTransform.v1",
    "type": "equation",
    "title": "Fourier Transform = Phasor Decomposition",
    "summary": "Represents any admissible signal as a superposition of unit phasors. This is Î”â€™s canonical spectralization step before locking.",
    "defs": [
      "x(t) âˆˆ L2(â„), angular freq Ï‰",
      "X(Ï‰)=âˆ« x(t)e^{-iÏ‰t} dt,  x(t)=(1/2Ï€)âˆ« X(Ï‰)e^{iÏ‰t} dÏ‰",
      "phasor u_Ï‰(t)=e^{iÏ‰t}"
    ],
    "equations": [
      "X(Ï‰)=âˆ«_{â„} x(t) e^{-iÏ‰ t} dt",
      "x(t)= (1/2Ï€) âˆ«_{â„} X(Ï‰) e^{iÏ‰ t} dÏ‰"
    ],
    "audits": [
      "E1: Narrowband structure present (stable instantaneous phase/frequency) before interpreting phase",
      "E2: Global phase origin shift leaves magnitudes |X(Ï‰)| invariant",
      "E3: Tiny frequency nudge Î´Ï‰ around a peak moves that peak predictably in X(Ï‰)",
      "E4: Major peaks persist under coarse time blur/downsample"
    ],
    "nulls": ["phase-scrambled surrogates", "amplitude-matched noise with flat spectrum"],
    "steer": "Use FT to expose candidate low-order relations; never treat broadband noise lobes as locks without Îµ_cap/Îµ_stab checks."
  },
  {
    "id": "DELTA.MATH.DiscreteFourierTransform.v1",
    "type": "equation",
    "title": "DFT/IDFT & Bin Geometry",
    "summary": "The operational spectralizer for windows of length N. Connects discrete bins to Î”â€™s lock candidates.",
    "defs": [
      "x[n], n=0â€¦Nâˆ’1; X[k], k=0â€¦Nâˆ’1",
      "bin freq Ï‰_k=2Ï€k/N; hop size H for STFT"
    ],
    "equations": [
      "X[k]=âˆ‘_{n=0}^{Nâˆ’1} x[n] e^{-i 2Ï€kn/N}",
      "x[n]=(1/N)âˆ‘_{k=0}^{Nâˆ’1} X[k] e^{i 2Ï€kn/N}",
      "Ï‰_k = 2Ï€ k / N"
    ],
    "audits": [
      "E0: Window/dither calibration; FFT conventions fixed",
      "E1: Peaks stable across adjacent frames when signal is quasi-stationary",
      "E2: Phase origin changes â†’ circular phase shift across bins only",
      "E3: Inject a sine at k*; observe selective growth at X[k*] vs controls",
      "E4: Peak ordering stable under Nâ†’N/2 downsample with anti-aliasing"
    ],
    "nulls": ["random phase bins with matched magnitudes", "block-shuffled frames"],
    "steer": "Choose N so that target ratios fall near resolvable bins; enlarge Îµ (bandwidth) if detune exceeds bin width."
  },
  {
    "id": "DELTA.SIGNAL.WindowingLeakage.v1",
    "type": "protocol",
    "title": "Windowing, Leakage, and Eligibility",
    "summary": "Controls spectral leakage and defines capture bandwidth for Î” locks. Window choice and N set Îµ_cap and brittleness Î¶.",
    "defs": [
      "window w[n], mainlobe width Î”Ï‰_main, sidelobe level L_side",
      "capture Îµ_cap ~ Î”Ï‰_main, brittleness Î¶ â†‘ with high sidelobes"
    ],
    "equations": [
      "X_w[k]=âˆ‘ x[n] w[n] e^{-i2Ï€kn/N}",
      "Îµ_cap â‰ˆ Î”Ï‰_main; Î¶ âˆ L_side"
    ],
    "audits": [
      "E1: Mainlobe width measured from single-tone trials matches spec",
      "E3: Small detune within Îµ_cap yields monotone K increase; outside Îµ_cap does not",
      "E4: Low-order peak ranks persist across moderate window changes"
    ],
    "nulls": ["white/pink noise matched in RMS", "surrogates with randomized segment phases"],
    "steer": "Pick windows with low sidelobes when hunting fine ratios; widen N if Îµ_cap too small for expected detune."
  },
  {
    "id": "DELTA.SIGNAL.UncertaintyBound.v1",
    "type": "principle",
    "title": "Observer Budget: Timeâ€“Frequency Bound",
    "summary": "Formalizes the Î” observer constraint: finite windows trade time precision for frequency precision.",
    "defs": [
      "effective spreads Î”t, Î”Ï‰ from energy concentration",
      "constant c depends on spread definition"
    ],
    "equations": [
      "Î”t Â· Î”Ï‰ â‰¥ c  (timeâ€“bandwidth product)",
      "Flag claims as provisional when Î”Ï‰Î”t near bound"
    ],
    "audits": [
      "E0: Calibration with test chirps/tones yields expected Î”tÎ”Ï‰",
      "E2: Bound invariant to global phase/gain",
      "E4: Bound behavior stable across rescaled windows"
    ],
    "nulls": ["claims exceeding bound without increasing window or SNR"],
    "steer": "If a lock is brittle due to Î”Ï‰Î”t, expand window (increase N) or aggregate across frames before phase forcing."
  },
  {
    "id": "DELTA.MATH.ParsevalConvolution.v1",
    "type": "equation",
    "title": "Energy & Convolution Theorems",
    "summary": "Energy preservation and timeâ€“frequency dual control: convolution â†” multiplication. Core to Î” amplitude/space steering.",
    "defs": [
      "Parseval/Plancherel",
      "Convolution xâˆ—h â†” XÂ·H"
    ],
    "equations": [
      "âˆ‘ |x[n]|^2 = (1/N) âˆ‘ |X[k]|^2",
      "(xâˆ—h)[n] â†” X[k]Â·H[k]"
    ],
    "audits": [
      "E1: Energy equality holds within tolerance on calibration signals",
      "E3: Applying a narrowband filter H moves energy predictably into target bins â†‘K",
      "E4: Relative band energies persist under coarse-grain"
    ],
    "nulls": ["mismatched scaling conventions; compensated before acceptance"],
    "steer": "Use narrowband H to raise Î” lock K with minimal time-domain intrusion; watch Î¶ if ringing increases."
  },
  {
    "id": "DELTA.SIGNAL.PeakLocking.v1",
    "type": "protocol",
    "title": "From Spectral Peaks to Integer Locks",
    "summary": "Maps peak constellations to candidate p:q relations; accepts only if coherence and detune meet Î” gates.",
    "defs": [
      "peak set P={Ï‰_i}, amplitudes A_i",
      "candidate ratios p:q from nearest-peak pairs"
    ],
    "equations": [
      "Î”_{p:q}=p Î¸_b âˆ’ q Î¸_a (mod 2Ï€)",
      "K_{p:q}=âŸ¨cos Î”_{p:q}âŸ© e^{âˆ’Î»(p+q)} e^{âˆ’Î³ |Ï‰_b/Ï‰_a âˆ’ p/q|}"
    ],
    "audits": [
      "E2: Swap channels maps p:qâ†”q:p",
      "E3: Tiny retune aligns Ï‰_b/Ï‰_aâ†’p/q â‡’ Kâ†‘ inside Îµ_cap",
      "E4: Low-order K survives frame pooling; high order decays"
    ],
    "nulls": ["randomized peak pairings; phase shuffles"],
    "steer": "Prioritize small p+q; retune frequencies (F-axis) before any phase trim (P-axis)."
  },
  {
    "id": "DELTA.SIGNAL.STFTPhaseFlow.v1",
    "type": "protocol",
    "title": "STFT Instantaneous Frequency & Phase Hops",
    "summary": "Uses inter-frame phase to track true frequency and phase continuity; core for Î” micro-steers.",
    "defs": [
      "STFT frames m, bins k; hop H; Ï‰_k=2Ï€k/N",
      "phase advance Î”Ï•_k=arg X[k,m]âˆ’arg X[k,mâˆ’1]"
    ],
    "equations": [
      "Ï‰Ì‚_k(m)=wrap(Î”Ï•_k + Ï‰_k H)/H",
      "Î¸Ì‚_k(m)=Î¸Ì‚_k(mâˆ’1)+Ï‰Ì‚_k(m)Â·H"
    ],
    "audits": [
      "E1: Ï‰Ì‚ tracks known chirps within tolerance",
      "E3: Small Î´Ï‰ input reflects as proportional Î”Ï•_k",
      "E4: Ï‰Ì‚ rank stable under modest H/N changes"
    ],
    "nulls": ["phase-randomized frames breaking continuity"],
    "steer": "Use Ï‰Ì‚ for precise F-axis nudges and P-axis trims; abort if continuity breaks (Î¶ up)."
  },
  {
    "id": "DELTA.MUSIC.CepstrumPeriodicity.v1",
    "type": "protocol",
    "title": "Cepstrum for Fundamental & Low-Order Harmonics",
    "summary": "Quefrency peaks expose periodicity; small-integer harmonic stacks compress best (MDL).",
    "defs": [
      "power cepstrum C[q]=|FFT^{-1}{log |X[k]|}|^2",
      "quefrency q_0 â‰ˆ period; harmonics near integer multiples"
    ],
    "equations": [
      "C[q] peaks at q_0 â‡’ f_0=1/q_0",
      "MDL prior favors harmonic stacks with small integer indices"
    ],
    "audits": [
      "E1: Known harmonic signals yield correct q_0",
      "E3: Tiny detune reduces C[q_0] monotonically",
      "E4: q_0 persists under modest blur/downsample"
    ],
    "nulls": ["noise with matched spectrum (flat cepstrum)"],
    "steer": "Lock to f_0 first; accept overtones only if they reduce Î¶ and improve Î”H* beyond base model."
  },
  {
    "id": "DELTA.MATH.FourierMDLPrior.v1",
    "type": "principle",
    "title": "MDL Prior for Sparse Low-Order Spectra",
    "summary": "Short codes reward spectra concentrated at small-integer-related bins; penalize high-order clutter.",
    "defs": [
      "model Q_s (sparse peaks + small-integer ties)",
      "model Q_d (dense/unstructured)"
    ],
    "equations": [
      "MDL(Q_s) < MDL(Q_d) at equal predictive fit when peaks align to small ratios",
      "penalty term Î»(p+q) for each ratio annotation"
    ],
    "audits": [
      "Compression test: code-length advantage for Q_s on real data with harmonic structure",
      "E4: Advantage persists under pooling/coarse-grain"
    ],
    "nulls": ["shuffle peaks or break integer ties â†’ MDL advantage vanishes"],
    "steer": "Prefer sparse, integer-annotated spectra; prune high-order edges that fail RG."
  }
]
[
  {
    "id": "DELTA.MATH.FourierSeries.v1",
    "type": "equation",
    "title": "Fourier Series on Compact Intervals",
    "summary": "Decomposes periodic signals into harmonics; low-order integers dominate and are favored by MDL and RG.",
    "defs": [
      "period T, fundamental Ï‰0=2Ï€/T",
      "x(t)=a0/2+Î£_{nâ‰¥1}(a_n cos nÏ‰0 t + b_n sin nÏ‰0 t)"
    ],
    "equations": [
      "a_n=2/T âˆ«_0^T x(t) cos(nÏ‰0 t) dt",
      "b_n=2/T âˆ«_0^T x(t) sin(nÏ‰0 t) dt"
    ],
    "audits": [
      "E1: Harmonic peaks stable across cycles",
      "E2: Time shift x(tâˆ’Ï„) â†’ phase shift only",
      "E3: Tiny detune toward integer n raises the nth coefficient (inside Îµ_cap)",
      "E4: Small-n harmonics persist under downsample/coarse-grain"
    ],
    "nulls": ["phase-scrambled cycles", "cycle-shuffled segments"],
    "steer": "Lock fundamental first; accept overtones only if they reduce Î¶ and improve Î”H* beyond base."
  },
  {
    "id": "DELTA.MATH.ContinuedFractionsPrior.v1",
    "type": "principle",
    "title": "Continued Fractions as Low-Order Prior",
    "summary": "Use convergents of continued fractions as privileged p:q approximants; shorter expansions â†’ stronger prior.",
    "defs": [
      "rational approximants p_k/q_k from continued fraction of Î±=Ï‰_b/Ï‰_a",
      "order cost âˆ p_k+q_k"
    ],
    "equations": [
      "prior(râ‰ˆp_k/q_k) âˆ exp(âˆ’Î» (p_k+q_k))",
      "choose k minimizing MDL + detune penalty |Î±âˆ’p_k/q_k|"
    ],
    "audits": [
      "E3: Retune Î± toward best convergent increases K and Îµ_stab",
      "E4: Convergent ranking stable under pooling"
    ],
    "nulls": ["random rationals with longer expansions (no MDL gain)"],
    "steer": "Scan convergents first; break high-order fits lacking RG."
  },
  {
    "id": "DELTA.MATH.FareyMediantComposer.v1",
    "type": "protocol",
    "title": "Farey/Mediant for Lock Composition",
    "summary": "Compose two locks p/q and r/s via mediant (p+r)/(q+s) to propose new candidates; accept only if MDL+Î”H* win and robustness holds.",
    "defs": [
      "locks L_ab^{p:q}, L_ab^{r:s} with small orders",
      "mediant m=(p+r)/(q+s) (reduced)"
    ],
    "equations": [
      "candidate ratio m for the same pair a:b",
      "accept if K_mâ†‘, Î¶_mâ†“, and MDL gain > 0"
    ],
    "audits": [
      "E3: micro-retune toward m raises K_m vs off-manifold",
      "E4: m persists where parents persist; demote if not"
    ],
    "nulls": ["mediants from shuffled parents must fail"],
    "steer": "Use mediant only when parents are robust (Îµ_stab>0); reject if brittleness rises."
  },
  {
    "id": "DELTA.SIGNAL.DirichletKernelBrittleness.v1",
    "type": "protocol",
    "title": "Dirichlet Kernel & Gibbs as Brittleness Probe",
    "summary": "Large lobes/overshoot imply brittle spectral fits; penalize Î¶ when reconstruction exhibits Gibbs-like artifacts.",
    "defs": [
      "Dirichlet kernel D_N(Î¸)=Î£_{n=âˆ’N}^N e^{inÎ¸}",
      "Gibbs overshoot G near discontinuities"
    ],
    "equations": [
      "Î¶ âˆ sidelobe_energy(D_N) + Î³_G Â· G",
      "penalize high-order expansions that increase Î¶ without Î”H*"
    ],
    "audits": [
      "E1: Measured sidelobes match predicted for chosen window/N",
      "E3: Removing high-order terms lowers Î¶ with small Î”H* loss",
      "E4: Î¶ reduction persists under coarse-grain"
    ],
    "nulls": ["smooth signals without discontinuities (low G)"],
    "steer": "Prefer windows/bases that lower sidelobes; prune brittle high-n terms first."
  },
  {
    "id": "DELTA.MATH.HilbertAnalyticSignal.v1",
    "type": "equation",
    "title": "Analytic Signal & Instantaneous Phase",
    "summary": "Computes phase Î¸(t) and amplitude A(t) via Hilbert transform; prerequisite for Î” locking.",
    "defs": [
      "analytic x_a(t)=x(t)+i H{x}(t)",
      "A(t)=|x_a(t)|, Î¸(t)=arg x_a(t), Ï‰(t)=Î¸Ì‡(t)"
    ],
    "equations": [
      "H{x}(t)= (1/Ï€) PV âˆ« x(Ï„)/(tâˆ’Ï„) dÏ„",
      "x(t)=A(t) cos Î¸(t)"
    ],
    "audits": [
      "E1: Narrowband requirement holds (Bedrosian conditions approx.)",
      "E2: Global phase origin invariance",
      "E3: Small frequency nudges reflect as smooth Ï‰(t) shifts",
      "E4: Phase traces robust under downsample"
    ],
    "nulls": ["broadband/noisy signals violating narrowband assumption"],
    "steer": "If narrowband fails, prefilter or switch to STFT-phase flow before locking."
  },
  {
    "id": "DELTA.SIGNAL.TimeFreqWavelets.v1",
    "type": "protocol",
    "title": "Wavelet Tiling under Observer Budget",
    "summary": "Use multiresolution tiles to respect Î”Ï‰Î”t bounds; accept locks that persist across scales.",
    "defs": [
      "mother Ïˆ(t), scales a, shifts b",
      "W_x(a,b)=âˆ« x(t) ÏˆÌ„((tâˆ’b)/a) dt"
    ],
    "equations": [
      "scale-frequency map fâ‰ˆf(a)",
      "accept if K,Î“ stable across adjacent (a,b) tiles"
    ],
    "audits": [
      "E1: Tile energy tracks known multiscale chirps",
      "E3: On-manifold detune within a tile raises K",
      "E4: Low-order features persist across scales"
    ],
    "nulls": ["phase-randomized or scale-scrambled surrogates"],
    "steer": "Start coarse, refine only where S* is high; avoid over-zooming brittle features."
  },
  {
    "id": "DELTA.DYN.CircleMapTongues.v1",
    "type": "equation",
    "title": "Circle Map & Arnold Tongues as Capture Bands",
    "summary": "Rotation with nonlinearity exhibits tongues labeled by p:q; widths predict Îµ_cap; low p+q tongues dominate.",
    "defs": [
      "standard circle map Î¸_{n+1}=Î¸_n+Î©âˆ’(K/2Ï€) sin(2Ï€Î¸_n) (mod 1)",
      "rotation number Ï"
    ],
    "equations": [
      "lock at p:q â‡” Ï=p/q",
      "Îµ_cap âˆ tongue_width(p:q; K), decreasing with p+q"
    ],
    "audits": [
      "E3: small Î”Î© shifts move system into/out of tongue with Kâ†‘/â†“",
      "E4: low-order tongues remain under coarse sampling/noise"
    ],
    "nulls": ["Î© jitter destroying commensurability"],
    "steer": "Target smallest tongues first; widen capture by increasing K only within brittleness limits."
  },
  {
    "id": "DELTA.MATH.CauchyResidueWinding.v1",
    "type": "principle",
    "title": "Residues as Phase-Winding Counters",
    "summary": "Complex residues count windings/invariants; use to certify integer structure (topological witnesses).",
    "defs": [
      "closed contour C, analytic f(z)",
      "winding number n=(1/2Ï€i)âˆ®_C f'(z)/f(z) dz"
    ],
    "equations": [
      "âˆ®_C f'(z)/f(z) dz = 2Ï€i Î£ residues",
      "integer n is invariant under coarse deformations (RG-stable)"
    ],
    "audits": [
      "E2: Invariance under admissible contour deformations",
      "E4: Winding persists under smoothing/blur"
    ],
    "nulls": ["non-analytic breaks (void claim)"],
    "steer": "Use winding as a pass/fail gate before elevating high-order edges."
  },
  {
    "id": "DELTA.MATH.GaussSumsIntegerDetector.v1",
    "type": "equation",
    "title": "Gauss Sums for Integer Phase Detection",
    "summary": "Exponential sums spike at rational phases; a discrete detector for small p:q structure.",
    "defs": [
      "S_N(Î±)=Î£_{n=0}^{Nâˆ’1} e^{iÏ€ n(n+1) Î±}",
      "Î± close to p/q"
    ],
    "equations": [
      "|S_N(Î±)| is large near rationals with small q",
      "penalize by exp(âˆ’Î»(p+q)) to align with MDL"
    ],
    "audits": [
      "E3: Î± nudged toward p/q increases |S_N|",
      "E4: Rankings of small q persist as N grows"
    ],
    "nulls": ["Î± from shuffle (irrational-like) shows flat |S_N|"],
    "steer": "Use as a prefilter to propose candidate ratios for DCO++; reject high-order spikes lacking RG."
  },
  {
    "id": "DELTA.SYM.IntegerNoether.v1",
    "type": "principle",
    "title": "Integer Noether (Conserved Windings)",
    "summary": "When the action is invariant under phase rotations by 2Ï€/p and 2Ï€/q, the corresponding winding integers are conserved under Î©* flow.",
    "defs": [
      "action P(u) with symmetry subgroup GâŠ‚U(1)",
      "winding numbers nâˆˆâ„¤"
    ],
    "equations": [
      "âˆ‚_t u = âˆ’M âˆ‡P â‡’ d n/dt = 0 when P invariant under G",
      "low-order G (small p+q) yields RG-stable invariants"
    ],
    "audits": [
      "E2: Symmetry check under declared G",
      "E4: Invariants persist under coarse-grain"
    ],
    "nulls": ["unregistered symmetry breaks void conservation claim"],
    "steer": "Exploit conserved integers to stabilize control; avoid actions that break G unless demotion accepted."
  },
  {
    "id": "DELTA.CONTROL.OmegaStarCLF.v1",
    "type": "equation",
    "title": "Î©* as a Controlâ€“Lyapunov Flow",
    "summary": "Defines a potential whose decrease aligns compression, prediction, and Î”H*; guarantees convergence to low-order basins under bounded nudges.",
    "defs": [
      "potential V = Î»(p+q)+Î³ Î´^2 âˆ’ w_K|K| âˆ’ w_H H* + w_Î¶ Î¶",
      "dynamics uÌ‡ = âˆ’M âˆ‡V + Î·"
    ],
    "equations": [
      "VÌ‡ = âˆ’(âˆ‡V)^âŠ¤ M (âˆ‡V) + (âˆ‡V)^âŠ¤ Î· â‰¤ 0 in expectation for bounded Î·",
      "landings at integer constraints (Î”V<0)"
    ],
    "audits": [
      "E3: tiny on-manifold nudges decrease V and raise Î”H*",
      "E4: Low-order equilibria persist across blur/downsample"
    ],
    "nulls": ["off-manifold nudges fail to reduce V"],
    "steer": "Use V as a real-time score to schedule Fâ†’Pâ†’Aâ†’S nudges; stop when Î¶ rises."
  },
  {
    "id": "DELTA.MATH.DCT.RealPhasor.v1",
    "type": "equation",
    "title": "Discrete Cosine Transform as Real-Phasor Basis",
    "summary": "A real-basis cousin of the DFT with strong energy compaction; good MDL choice when phases are near 0/Ï€.",
    "defs": [
      "DCT-II: X[k]=Î£_{n=0}^{Nâˆ’1} x[n] cos[Ï€/N (n+1/2) k]"
    ],
    "equations": [
      "x[n]=(2/N) Î£_{k=0}^{Nâˆ’1} Î±_k X[k] cos[Ï€/N (n+1/2) k], Î±_0=1/2, Î±_k=1"
    ],
    "audits": [
      "E1: Energy compaction verified on smooth signals",
      "E3: Small detune near cosine peaks increases target coefficients",
      "E4: Low-order k persist under pooling"
    ],
    "nulls": ["random-phase signals (no compaction gain)"],
    "steer": "Prefer DCT when observed phases cluster near 0 or Ï€; otherwise use complex DFT/phasors."
  }
]
[
  {
    "id": "DELTA.PHYS.NavierStokesLocking.v1",
    "type": "protocol",
    "title": "Navierâ€“Stokes: Vortex Shedding as Low-Order Phase Lock",
    "summary": "Treat coherent fluid structures (vortex shedding, waves) as phase processes. Small-integer forcing/feedback locks wakes; Strouhal-tuned captures increase harmony with minimal actuation.",
    "defs": [
      "incompressible NSE: âˆ‚_t u + (uÂ·âˆ‡)u = âˆ’âˆ‡p/Ï + Î½ âˆ‡Â²u + f,  âˆ‡Â·u=0",
      "observable phase Î¸(t) from POD/FFT of lift/pressure/wake mode",
      "Strouhal St = f D / U",
      "eligibility Îµ_cap, stability Îµ_stab, brittleness Î¶ for lock p:q"
    ],
    "equations": [
      "Î”_{p:q}(t) = p Î¸_forcing(t) âˆ’ q Î¸_wake(t) (mod 2Ï€)",
      "K_{p:q} = âŸ¨cos Î”_{p:q}âŸ© Â· e^{âˆ’Î»(p+q)} Â· e^{âˆ’Î³ |St âˆ’ p/q|}",
      "Îµ_stab âˆ modal energy fraction âˆ’ c Â· (phase diffusion)"
    ],
    "audits": [
      "E0: sensor & actuation calibration (lift, hot-wire, PIV)",
      "E1: stable narrowband mode in baseline (shedding peak Stâ‰ˆconst)",
      "E2: invariance to global phase origin for Î¸",
      "E3: tiny periodic forcing Î´Ï‰ or phase trim near Stâ‰ˆp/q raises K, reduces drag/pressure fluctuation vs off-tuned forcing",
      "E4: low-order locks (1:1, 2:1) persist under Ã—2 downsample/noise; higher-order die"
    ],
    "nulls": [
      "random-phase forcing with matched power",
      "blocked shuffles of actuation schedule"
    ],
    "steer": "Scan small p:q near baseline St; nudge frequency (F), then phase (P); minimal amplitude (A) and duty-cycle rests (S) to reduce Î¶ while improving Î”H*."
  },
  {
    "id": "DELTA.THERM.SecondLawEntropyFlow.v1",
    "type": "principle",
    "title": "Second Law: Entropy Production & Control Budget",
    "summary": "Entropy production Ïƒâ‰¥0 constrains what Î”-controllers can achieve locally; order gains require exported entropy or stored free energy.",
    "defs": [
      "entropy S, temperature T, heat flow J_q, entropy production Ïƒ",
      "free-energy F=Uâˆ’TS, information Iâ‰ˆâˆ’KL to ground-state"
    ],
    "equations": [
      "Ïƒ = âˆ‘_i J_i X_i â‰¥ 0 (non-equilibrium thermodynamics)",
      "dF/dt = âˆ’T Ïƒ + WÌ‡_ctrl (control work balance)",
      "MDL gain â‰² available free-energy budget"
    ],
    "audits": [
      "E0: calorimetry/energy accounting calibrated",
      "E3: micro-steers that increase order (K, R) correspond to measurable work/heat exchange; no free lunch",
      "E4: coarse-grain preserves non-negativity of Ïƒ"
    ],
    "nulls": ["claims of Î”H*â†‘ without energy or information export"],
    "steer": "Schedule steers where exported entropy is cheapest (e.g., strong sinks); prefer low-order locks to maximize Î”H*/work ratio and limit Î¶."
  },
  {
    "id": "DELTA.LOGIC.GodelIncompleteness.v1",
    "type": "principle",
    "title": "GÃ¶del Guardrail: No Global Completeness",
    "summary": "Any sufficiently expressive formal stack that proves arithmetic truths cannot be both complete and consistent. Î” uses this as a governance rule: escalate by receipts, never claim universal closure.",
    "defs": [
      "formal system â„± with arithmetic",
      "provability â–¡, truth âŠ¨"
    ],
    "equations": [
      "If Cons(â„±) then âˆƒÏ†: (â„± âŠ¬ Ï†) âˆ§ (â„• âŠ¨ Ï†)",
      "No Î” pipeline achieves universal completeness; rely on E-audits + RG instead"
    ],
    "audits": [
      "E2: meta-consistency checks across observers/transformations",
      "E4: persistence of accepted low-order structure under coarse-grain (proxy for robustness, not completeness)"
    ],
    "nulls": ["claims that a single Î”-model proves all truths in its domain"],
    "steer": "Use Escalation Ladder L0â†’L4; de-escalate on audit failure. Prefer minimal models with MDL advantage; maintain provisional flags with observer budgets."
  },
  {
    "id": "DELTA.STATS.BayesTheorem.v1",
    "type": "protocol",
    "title": "Bayes with Low-Order Priors",
    "summary": "Posterior âˆ likelihood Ã— prior; encode Î”â€™s small-integer preference in priors over ratios and phase structures; use MDL as a prior proxy.",
    "defs": [
      "posterior p(Î¸|D) âˆ p(D|Î¸) p(Î¸)",
      "Î¸ includes integer ratios p:q, detune Î´, robustness Î¶"
    ],
    "equations": [
      "log p(Î¸|D) = log p(D|Î¸) âˆ’ Î»(p+q) âˆ’ Î³ Î´^2 âˆ’ Î²' Î¶ + const",
      "MAP â‰ˆ MDL minimization with Î” penalties"
    ],
    "audits": [
      "E0: calibration of likelihoods (proper scoring)",
      "E3: new evidence near low-order hypotheses shifts posterior mass monotonically",
      "E4: posterior preference for low order persists under data pooling"
    ],
    "nulls": ["uninformative priors that erase small-integer signal"],
    "steer": "Initialize with low-order-biased priors; anneal priors if brittleness remains high despite evidence."
  },
  {
    "id": "DELTA.FIN.BlackScholesLock.v1",
    "type": "protocol",
    "title": "Blackâ€“Scholes & Implied-Vol Coherence",
    "summary": "Treat option surfaces as phase-structured objects; seek low-order calendar/weekly locks in returns/vol that lift hedging harmony with minimal risk.",
    "defs": [
      "GBM: dS = Î¼ S dt + Ïƒ S dW_t; risk-neutral drift r",
      "BS PDE: âˆ‚_t V + Â½ Ïƒ^2 S^2 âˆ‚_{SS} V + r S âˆ‚_S V âˆ’ r V = 0",
      "implied vol surface Ïƒ_impl(K,T), clocks: trading-day(â‰ˆ1), week(5), month(~21)"
    ],
    "equations": [
      "Î”_{p:q}(t)=p Ï†_clock(t) âˆ’ q Ï†_return/vol(t) (mod 2Ï€)",
      "K_{p:q}=âŸ¨cos Î”_{p:q}âŸ© e^{âˆ’Î»(p+q)} e^{âˆ’Î³ |ratioâˆ’p/q|}",
      "hedge Î”H*: improvement in PnL variance and slippage vs null"
    ],
    "audits": [
      "E0: data QC (bias/lag, dividends, corporate actions)",
      "E2: invariance under rescaling/clock origin",
      "E3: micro-scheduling (roll timing, small delta-gamma rebalances) near accepted phases reduces variance vs randomized controls",
      "E4: low-order calendar effects persist across regimes; high-order do not"
    ],
    "nulls": [
      "label/phase shuffles of event days",
      "volatility-matched randomized hedges"
    ],
    "steer": "Only exploit locks passing audits; cap risk, abort when Î¶ rises (fragile regimes). Prefer 1:1 daily or 5:1 weekly rhythms if robust."
  },
  {
    "id": "DELTA.QM.SchrodingerPhase.v1",
    "type": "equation",
    "title": "SchrÃ¶dinger Dynamics as Phase Evolution",
    "summary": "Quantum state evolution is unitary phase flow; measurement acts like a high-gain 1:1 lock to apparatus phases.",
    "defs": [
      "iÄ§ âˆ‚_t |ÏˆâŸ© = H |ÏˆâŸ©",
      "relative phases Î¸_jâˆ’Î¸_k between eigencomponents",
      "measurement coupling to apparatus with phase Ï†_a"
    ],
    "equations": [
      "Î¸Ì‡_j = E_j/Ä§ (free evolution)",
      "Lock variable e_Ï† = wrap(Ï†_a âˆ’ (Î¸_jâˆ’Î¸_k)); capture if Îµ_cap>0",
      "Post-lock purification speed âˆ coupling K; Îµ_stab âˆ 1âˆ’dephasing"
    ],
    "audits": [
      "E1: stable phase accumulation under known H (Ramsey fringes)",
      "E2: gauge invariance under global phase",
      "E3: weak phase nudges (AC Stark) shift fringes predictably; measurement-strength changes lock rate",
      "E4: low-order phase relations persist under coarse time binning"
    ],
    "nulls": ["decoherence-mimicking surrogates without phase structure"],
    "steer": "Tune pulse timing (F/P) to land inside capture; minimize amplitude to reduce Î¶ (dephasing); verify Î”H* via contrast in readout."
  },
  {
    "id": "DELTA.GOV.AutopilotProceed.v1",
    "type": "protocol",
    "title": "Autopilot Proceed (P) â€” Batch Minting & Guardrails",
    "summary": "Enables continuous JSON-card minting while enforcing Î” guardrails: MDL bias, E-audits, observer budgets, RG persistence.",
    "defs": [
      "trigger token P",
      "rate limiter on Snap per axis",
      "provisional flags when Î”Ï‰Î”t near bound"
    ],
    "equations": [
      "On P: emit next N cards from queue; each card must include Îµ_cap, Îµ_stab, Î¶ semantics and E0â€“E4 audit hooks",
      "Abort card if any doctrine check fails (no partial credit)"
    ],
    "audits": [
      "E0: schema validation",
      "E2: consistency across cards (shared defs, symbol hygiene)",
      "E4: stability of recommendations under corpus growth"
    ],
    "nulls": ["cards lacking falsifiers or RG notes"],
    "steer": "Keep queue prioritized by expected Î”H*/MDL gain; demote speculative entries until receipts arrive."
  }
]
[
  {
    "id": "DELTA.EM.MaxwellPhaseLocks.v1",
    "type": "protocol",
    "title": "Maxwell: Coherent Fields as Phase-Locked Modes",
    "summary": "Treat EM modes (TE/TM/temporal carriers) as phasors; low-order frequency ratios between sources, cavities, and media maximize legibility and control with tiny nudges.",
    "defs": [
      "Maxwell (vacuum): âˆ‡Ã—E=âˆ’âˆ‚B/âˆ‚t, âˆ‡Ã—H=J+âˆ‚D/âˆ‚t, âˆ‡Â·D=Ï, âˆ‡Â·B=0",
      "mode phases Î¸_k(t), frequencies Ï‰_k, amplitudes A_k",
      "boundary/cavity clocks; impedance Z(Ï‰)"
    ],
    "equations": [
      "Î”_{p:q}=p Î¸_src âˆ’ q Î¸_mode (mod 2Ï€)",
      "K_{p:q}=âŸ¨cos Î”_{p:q}âŸ© e^{âˆ’Î»(p+q)} e^{âˆ’Î³ |Ï‰_src/Ï‰_mode âˆ’ p/q|}",
      "Îµ_stab âˆ Q_mode âˆ’ c Â· loss(Ï‰)"
    ],
    "audits": [
      "E0: calibration of probes (phase, amplitude, impedance)",
      "E1: stable narrowband modes under static boundaries",
      "E2: gauge-origin invariance for phase comparisons",
      "E3: tiny frequency/phase nudges at sources increase K and PLI (pattern legibility) near small p:q; off-ratio control â‰ˆ null",
      "E4: low-order locks persist under downsample/blur or small boundary perturbations"
    ],
    "nulls": ["random-phase drive; amplitude-matched noise"],
    "steer": "Tune source frequency (F) into cavity tongues; phase-trim (P); minimal amplitude (A); spatial apodization (S) to reduce Î¶ (ringing)."
  },
  {
    "id": "DELTA.GR.GeodesicLocking.v1",
    "type": "principle",
    "title": "GR: Geodesic Coherence & Low-Order Orbits",
    "summary": "Bound orbits in weak-field metrics show preferred small-integer apsidal/radial/harmonic relations; treat resonances as Î” locks for navigation/control.",
    "defs": [
      "geodesic eq. D^2x^Î¼/dÏ„^2 + Î“^Î¼_{Î±Î²} (dx^Î±/dÏ„)(dx^Î²/dÏ„)=0",
      "radial Î¸_r, azimuth Î¸_Ï† phases; ratio r=Ï‰_Ï†/Ï‰_r"
    ],
    "equations": [
      "Lock at p:q if Î”_{p:q}=p Î¸_Ï† âˆ’ q Î¸_r â‰ˆ 0 (mod 2Ï€)",
      "penalize detune |r âˆ’ p/q| and order (p+q)"
    ],
    "audits": [
      "E1: stable phase extraction from orbit segments",
      "E2: invariance under coordinate gauge choices",
      "E3: micro-thrusts timed at accepted phases reduce fuel/Î”v cost vs random thrusts",
      "E4: low-order resonances persist under coarse averaging and weak perturbations"
    ],
    "nulls": ["shuffled maneuver times; synthetic null potentials"],
    "steer": "Schedule burns near accepted phases (P) once eligibility (F) is met; prefer low-order corridors for transfer."
  },
  {
    "id": "DELTA.CTRL.KalmanLocking.v1",
    "type": "protocol",
    "title": "Kalman Filtering as Phase-Aware Fusion",
    "summary": "Fuse sensors by respecting phase structure; low-order periodicities get prior weight; brittleness rises when innovations carry unresolved periodic residuals.",
    "defs": [
      "x_{t+1}=A x_t + w_t, y_t=C x_t + v_t",
      "innovation Î½_t = y_t âˆ’ C xÌ‚_t|tâˆ’1"
    ],
    "equations": [
      "augment state with phasors for detected Ï‰_k",
      "prior weight âˆ exp(âˆ’Î»(p+q)) for Ï‰_b/Ï‰_aâ‰ˆp/q"
    ],
    "audits": [
      "E0: filter gain calibration; noise covariances checked",
      "E3: injecting a tiny sinusoid at accepted Ï‰ reduces Î½_t variance vs off-Ï‰",
      "E4: accepted Ï‰_k persist under window pooling"
    ],
    "nulls": ["mismatched covariances; phase-scrambled residuals"],
    "steer": "Model low-order modes explicitly; gate corrections when Îµ_cap low to avoid phase forcing."
  },
  {
    "id": "DELTA.INFO.ShannonMDL.v1",
    "type": "principle",
    "title": "Shannonâ€“MDL Bridge",
    "summary": "Prefer codes that compress by exploiting low-order periodicity; MDL penalty aligns with code length; Î” keeps only structures that pay in bits and control.",
    "defs": [
      "entropy H, code length Lâ‰ˆâˆ’log P(model,data)",
      "MDL: I(Q;O)âˆ’Î» MDL(Q)"
    ],
    "equations": [
      "Î”-bonus â‰ˆ bits saved by small p:q annotations",
      "Reject structures that fail to reduce L while increasing Î¶"
    ],
    "audits": [
      "E3: adding accepted lock reduces codelength and increases Î”H*",
      "E4: compression advantage persists under pooling"
    ],
    "nulls": ["pseudo-structure that vanishes under shuffle"],
    "steer": "Track bits saved per lock; prune high-order edges with poor bit-yield."
  },
  {
    "id": "DELTA.LIN.PCASVDPhase.v1",
    "type": "protocol",
    "title": "PCA/SVD with Phase Annotation",
    "summary": "Augment PCA/SVD with phasor tags; keep components that show low-order cross-channel phase structure and reduce Î¶.",
    "defs": [
      "X=UÎ£V^âŠ¤; component phases Î¸_k from Hilbert/STFT",
      "order parameter R_k"
    ],
    "equations": [
      "accept component k if (R_k high âˆ§ small-order ties among channels) and MDL gain > 0"
    ],
    "audits": [
      "E1: stability of component phases across windows",
      "E3: tiny on-phase reweighting increases Î”H*",
      "E4: accepted components persist under coarse-grain"
    ],
    "nulls": ["singular vectors from shuffled time"],
    "steer": "Down-weight components that raise Î¶ or lack low-order ties."
  },
  {
    "id": "DELTA.MATH.PoissonSummationAliasing.v1",
    "type": "principle",
    "title": "Poisson Summation â†” Aliasing Law",
    "summary": "Sampling creates integer-shift replicas in frequency; use it to predict false locks and design guards.",
    "defs": [
      "Î£_n x(nT) e^{-iÏ‰nT} â†” (1/T) Î£_k X(Ï‰âˆ’2Ï€k/T)"
    ]
    ,
    "equations": [
      "alias peaks at Ï‰ and Ï‰Â±2Ï€k/T; penalize suspected alias locks unless they survive E4 under resampling"
    ],
    "audits": [
      "E0: sampling rate/clock calibration",
      "E3: resample with T' to test alias hypothesis (true locks persist; aliases move)",
      "E4: low-order true locks invariant under modest resampling"
    ],
    "nulls": ["alias-only claims without resampling tests"],
    "steer": "Vary T to disambiguate; accept locks that persist in place."
  },
  {
    "id": "DELTA.MATH.StationaryPhaseSelector.v1",
    "type": "protocol",
    "title": "Stationary Phase for Phase Selection",
    "summary": "Dominant contributions come from stationary phase points; a principled filter for candidate locks in broadband data.",
    "defs": [
      "I(Î»)=âˆ« a(t) e^{iÎ»Ï†(t)} dt",
      "Ï†'(t*)=0 â‡’ main contribution"
    ],
    "equations": [
      "prefer locks whose phases align with stationary points across channels",
      "penalize non-stationary fits (higher Î¶)"
    ],
    "audits": [
      "E1: stationary points reproducible under smoothing",
      "E3: small perturbations around t* modulate amplitude predictably",
      "E4: selections persist under coarse temporal blur"
    ],
    "nulls": ["random-phase surrogates lacking stationary points"],
    "steer": "Gate locking to neighborhoods of stationary phase to lower Î¶."
  },
  {
    "id": "DELTA.KOL.MDLComplexity.v1",
    "type": "principle",
    "title": "Kolmogorov/MDL Complexity Guard",
    "summary": "Admit only models that shorten description length; small-integer annotations must pay for themselves.",
    "defs": [
      "K(x)â‰ˆ code length; MDL(Q)â‰ˆ|Q|+|residual|"
    ],
    "equations": [
      "accept if Î”|Q|+Î”|residual| < 0 and Î¶ does not increase"
    ],
    "audits": [
      "E3: adding the lock decreases code length on held-out",
      "E4: savings persist under aggregation"
    ],
    "nulls": ["overfit annotations that lose on OOS"],
    "steer": "Use MDL delta as a hard gate before promotion."
  },
  {
    "id": "DELTA.CTRL.LQRDelta.v1",
    "type": "equation",
    "title": "LQR as Harmony Optimizer",
    "summary": "Quadratic costs track Î”â€™s potential; phase-aware linearization gives closed-form controllers that favor low-order steady states.",
    "defs": [
      "xÌ‡=Ax+Bu, J=âˆ« (x^TQx + u^TRu) dt, Riccati P"
    ],
    "equations": [
      "K=R^{-1}B^T P,  A^T P + P A âˆ’ P B R^{-1} B^T P + Q = 0",
      "include phase-penalties via augmented state for Î”_{p:q}"
    ],
    "audits": [
      "E0: model linearization validated",
      "E3: small phase-aware control reduces Î”_{p:q} and Î”H* increases",
      "E4: low-order equilibria persist under coarse model reductions"
    ],
    "nulls": ["controllers ignoring phase show no Î”H* gain"],
    "steer": "Augment LQR with Î” phase states; prefer solutions reducing Î¶."
  },
  {
    "id": "DELTA.STAT.InnovationRG.v1",
    "type": "protocol",
    "title": "Innovation RG: Coarse-Grain & Refit",
    "summary": "Automates RG persistence tests: downsample/blur â†’ refit locks â†’ compare relevance curves vs order.",
    "defs": [
      "coarse factors câˆˆ{2,4}",
      "relevance R_{p+q}(c)=K_c normalized"
    ],
    "equations": [
      "expect R_{small}(c) â‰¥ R_{large}(c) for câ‰¥2"
    ],
    "audits": [
      "E4: curve monotonicity holds; demote if violated"
    ],
    "nulls": ["effects that vanish or invert under câ‰¥2"],
    "steer": "Break high-order edges failing RG first."
  },
  {
    "id": "DELTA.SPIN.PRCPhaseResponse.v1",
    "type": "protocol",
    "title": "Phase Response Curves for Oscillator Capture",
    "summary": "Maps infinitesimal kicks to phase change; predicts minimal steers to achieve lock.",
    "defs": [
      "PRC Z(Î¸): Î´Î¸ = Z(Î¸)Â·Î´u",
      "limit-cycle phase Î¸"
    ],
    "equations": [
      "schedule kicks at Î¸ maximizing |Z(Î¸)| aligned to shrink Î”_{p:q}"
    ],
    "audits": [
      "E1: reproducible PRC under small kicks",
      "E3: kicks at predicted phases reduce lock error more than random",
      "E4: PRC features persist under moderate noise"
    ],
    "nulls": ["random kick phases"],
    "steer": "Use PRC to time minimal actuation (P-axis) after eligibility."
  },
  {
    "id": "DELTA.LATT.IsingLowOrder.v1",
    "type": "protocol",
    "title": "Ising/Spin Systems as Low-Order Coupling Fields",
    "summary": "Neighbor couplings J_ij define phase-like alignment; small motifs (pairs/triads) dominate near criticality and guide control.",
    "defs": [
      "H(Ïƒ)=âˆ’Î£_{âŸ¨i,jâŸ©} J_ij Ïƒ_i Ïƒ_j âˆ’ h Î£_i Ïƒ_i",
      "local order m=âŸ¨ÏƒâŸ©; motifs with p:q-like parity"
    ],
    "equations": [
      "accept motifs that raise m and reduce free energy with small annotations",
      "MDL penalty for large motif orders"
    ],
    "audits": [
      "E3: micro-field h nudges near predicted phases (update timings) increase m and Î”H*",
      "E4: small motifs persist under block-spin RG"
    ],
    "nulls": ["shuffled interactions"],
    "steer": "Act near low-order motif hotspots; avoid brittle high-order cliques."
  },
  {
    "id": "DELTA.ECO.LotkaVolterraResonance.v1",
    "type": "protocol",
    "title": "Lotkaâ€“Volterra: Predatorâ€“Prey Phase Lock",
    "summary": "Population cycles phase-lock at small p:q under environmental clocks; tiny timing shifts improve stability and yield.",
    "defs": [
      "xÌ‡=Î±xâˆ’Î²xy, yÌ‡=âˆ’Î³y+Î´xy",
      "phases Î¸_x, Î¸_y; seasonal clock Î¸_s"
    ],
    "equations": [
      "Î”_{p:q}=p Î¸_x âˆ’ q Î¸_y (or vs Î¸_s)",
      "accept if Kâ†‘ and Î¶â†“ under alignment"
    ],
    "audits": [
      "E3: small seasonal timing changes near accepted phases increase stability (varianceâ†“) vs random shifts",
      "E4: low-order relations persist under aggregation"
    ],
    "nulls": ["shuffled seasonality labels"],
    "steer": "Time interventions (stocking/harvest) at accepted phases."
  },
  {
    "id": "DELTA.CPLX.CauchyRiemannHarmonics.v1",
    "type": "principle",
    "title": "Cauchyâ€“Riemann as Phase-Harmonicity Test",
    "summary": "When u+iv is analytic, u and v are harmonic conjugates; phase fields become curl-free gradients â€” a quality test for Î” phase reconstructions.",
    "defs": [
      "u_x = v_y, u_y = âˆ’v_x"
    ],
    "equations": [
      "accept phase reconstructions that approximately satisfy CR in local patches"
    ],
    "audits": [
      "E1: CR residuals small in calibration data",
      "E4: residual rankings stable under smoothing"
    ],
    "nulls": ["random-phase fields"],
    "steer": "Prefer analytic-compatible phase fields to reduce Î¶."
  },
  {
    "id": "DELTA.SAMP.NyquistGuard.v1",
    "type": "principle",
    "title": "Nyquistâ€“Shannon Sampling Guard",
    "summary": "Respect f_s â‰¥ 2 f_max; Î” flags claims as provisional where observer budgets violate sampling constraints.",
    "defs": [
      "sampling rate f_s, max band f_max"
    ],
    "equations": [
      "flag provisional if f_s < 2 f_max or Î”tÎ”Ï‰ near bound"
    ],
    "audits": [
      "E0: clock stability check",
      "E4: accepted locks persist after oversampling"
    ],
    "nulls": ["locks that vanish after raising f_s"],
    "steer": "Increase f_s or prefilter before locking/steering."
  },
  {
    "id": "DELTA.CTRL.PontryaginDelta.v1",
    "type": "equation",
    "title": "Pontryagin Minimum Principle â†” Î©*",
    "summary": "Co-design control and phase targets using a Hamiltonian with integer penalties; optimal control steers to low-order basins.",
    "defs": [
      "H(x,u,Î»)=L(x,u)+Î»^T f(x,u), cost L includes Î»(p+q)+Î³Î´^2âˆ’w_K|K|+w_Î¶Î¶"
    ],
    "equations": [
      "u* = argmin_u H; xÌ‡=f(x,u*); Î»Ì‡=âˆ’âˆ‚H/âˆ‚x",
      "steady states coincide with Î” landings when âˆ‚H/âˆ‚x=0 under penalties"
    ],
    "audits": [
      "E3: small on-manifold control moves reduce H and increase Î”H*",
      "E4: low-order equilibria persist under coarse model"
    ],
    "nulls": ["controls without integer constraints (no Î” advantage)"],
    "steer": "Embed integer penalties; schedule nudges by Î” priority."
  }
]
[
  {
    "id": "DELTA.EM.MaxwellBlochMedium.v1",
    "type": "protocol",
    "title": "Maxwellâ€“Bloch Media: Phase-Locked Gain & Purification",
    "summary": "Couple EM fields with two/three-level media; small-integer detunings produce robust Rabi/beat locks with legible patterns and controllable purification speeds.",
    "defs": [
      "Maxwell fields (E,H), Bloch vector (u,v,w)",
      "Rabi freq Î©_R, detuning Î”, decoherence Î³_2",
      "phases Î¸_f (field), Î¸_a (atom)"
    ],
    "equations": [
      "Î”_{p:q}=p Î¸_f âˆ’ q Î¸_a (mod 2Ï€)",
      "K_{p:q}=âŸ¨cos Î”_{p:q}âŸ© e^{âˆ’Î»(p+q)} e^{âˆ’Î³ |Î©_R/Î” âˆ’ p/q|}",
      "Îµ_stab âˆ 1 âˆ’ (Î³_2/Î©_R)"
    ],
    "audits": [
      "E0: probe/drive calibration (Rabi, detuning)",
      "E1: stable fringes at fixed Î”",
      "E2: gauge-origin invariance for phases",
      "E3: tiny Î” or Î©_R nudges toward p:q raise K and fringe contrast vs off-manifold",
      "E4: low-order locks persist under downsample/blur"
    ],
    "nulls": ["randomized phase drives with matched power"],
    "steer": "Tune detuning (F), then phase (P); minimize amplitude (A) and shape pulses (S) to reduce Î¶."
  },
  {
    "id": "DELTA.QM.BECJosephsonLock.v1",
    "type": "protocol",
    "title": "BEC Josephson: Phase Difference & Small-Order Modes",
    "summary": "Two-mode condensates (double well) lock via Josephson dynamics; small-integer drive/oscillation ratios produce stable population oscillations.",
    "defs": [
      "phase diff Ï†, population z; Ï†Ì‡=âˆ‚H/âˆ‚z, zÌ‡=âˆ’âˆ‚H/âˆ‚Ï†",
      "drive freq Ï‰_d, natural Ï‰_J"
    ],
    "equations": [
      "Î”_{p:q}=p Ï‰_d t âˆ’ q Ï†(t)",
      "K_{p:q}=âŸ¨cos Î”_{p:q}âŸ© e^{âˆ’Î»(p+q)} e^{âˆ’Î³ |Ï‰_d/Ï‰_J âˆ’ p/q|}",
      "Îµ_stab âˆ barrier height âˆ’ noise"
    ],
    "audits": [
      "E1: clean Josephson oscillations",
      "E3: tiny Ï‰_d nudges into tongue raise K, reduce dephasing",
      "E4: low-order tongues persist under coarse sampling"
    ],
    "nulls": ["drive-phase shuffles"],
    "steer": "Target 1:1 or 2:1 drive/Ï‰_J; trim phase only when Îµ_cap>0."
  },
  {
    "id": "DELTA.CTRL.HinfRobust.v1",
    "type": "protocol",
    "title": "Hâˆ Robust Control with Î”-Phase Penalties",
    "summary": "Blend Hâˆ with Î”â€™s phase objectives; penalize lock errors and brittleness while bounding worst-case gain.",
    "defs": [
      "minimize â€–T_{zw}â€–_âˆ subject to phase/ratio costs",
      "Î” penalties: Î»(p+q), Î³ Î´^2, w_Î¶ Î¶"
    ],
    "equations": [
      "J=â€–T_{zw}â€–_âˆ + Î»(p+q)+Î³ Î´^2 âˆ’ w_K|K| + w_Î¶ Î¶",
      "accept controllers that reduce J and raise Î”H*"
    ],
    "audits": [
      "E0: model/weighting calibration",
      "E3: small on-manifold nudges reduce J, Î”H*â†‘ vs off-manifold",
      "E4: low-order equilibria persist under plant uncertainty/coarse models"
    ],
    "nulls": ["controllers with no phase terms (no Î” advantage)"],
    "steer": "Prefer designs that trade tiny â€–Tâ€– gains for big Kâ†‘ and Î¶â†“."
  },
  {
    "id": "DELTA.OPT.StationaryPhaseImaging.v1",
    "type": "protocol",
    "title": "Wave Optics: Stationary Phase Focusing",
    "summary": "Dominant image contributions arise at stationary phase; align optics to low-order phase stationary sets for legibility.",
    "defs": [
      "field U(P)=âˆ« A(x) e^{ik Î¦(x,P)} dx",
      "stationary points âˆ‡_x Î¦=0"
    ],
    "equations": [
      "accept paths nearest stationary sets; penalize non-stationary contributions via Î¶",
      "Kâ†‘ when aperture/phase plate drives toward stationary configurations"
    ],
    "audits": [
      "E1: stationary loci reproducible under smoothing",
      "E3: micro phase-plate tweaks improve contrast vs sham",
      "E4: features persist under blur/downsample"
    ],
    "nulls": ["random phase plates"],
    "steer": "Use minimal phase-plate edits at stationary loci; stop at Î¶ guardrails."
  },
  {
    "id": "DELTA.SPARSE.DictIntegerPrior.v1",
    "type": "protocol",
    "title": "Sparse Coding with Small-Integer Priors",
    "summary": "Favor atoms that form small-integer harmonic stacks; reject brittle high-order atoms lacking RG.",
    "defs": [
      "xâ‰ˆD a, sparsity â€–aâ€–_0",
      "integer ties among atom frequencies"
    ],
    "equations": [
      "cost = â€–xâˆ’Daâ€–_2^2 + Î¼â€–aâ€–_0 + Î» Î£ (p+q) over annotated ties",
      "accept atoms if MDL gain > 0 and Î¶â†“"
    ],
    "audits": [
      "E3: adding a low-order-tied atom reduces code length and increases Î”H*",
      "E4: same tie survives under pooling"
    ],
    "nulls": ["ties on shuffled atoms"],
    "steer": "Seed dictionary with low-order harmonic atoms; prune brittle ones."
  },
  {
    "id": "DELTA.FEP.MarkovBlanketPhase.v1",
    "type": "principle",
    "title": "Blankets with Phase Locks",
    "summary": "Render active/sensory/internal states with clocks; accept blankets that exhibit low-order cross-boundary locks improving prediction/control.",
    "defs": [
      "blanket partitions: {Î¼ (internal), s (sensory), a (active), e (external)}",
      "cross-locks among (Î¼,s,a,e) phases"
    ],
    "equations": [
      "accept if Kâ†‘ across Î¼â†”s and aâ†”e with Îµ_cap>0 and Î¶â†“",
      "MDL gain in joint model > sum of parts"
    ],
    "audits": [
      "E3: minimal action on a (P/F) improves Î¼ predictions vs null",
      "E4: blanket locks persist under time pooling"
    ],
    "nulls": ["permute labels across partitions"],
    "steer": "Exploit accepted locks for minimal active inference; demote otherwise."
  },
  {
    "id": "DELTA.SYNC.GraphLaplacianKuramoto.v1",
    "type": "protocol",
    "title": "Graph Synchrony with Integer Motifs",
    "summary": "Use Laplacian modes + Kuramoto coupling; accept cluster locks at small p:q across communities.",
    "defs": [
      "Î¸Ì‡_i = Ï‰_i + K Î£_j A_{ij} sin(Î¸_j âˆ’ Î¸_i)",
      "Laplacian L, eigenmodes Ï†_k"
    ],
    "equations": [
      "test Î”_{p:q} on community phases; K_{p:q} as usual",
      "Îµ_stab âˆ spectral gap âˆ’ noise"
    ],
    "audits": [
      "E1: stable cluster phases",
      "E3: tiny K or Ï‰_i nudges align clusters at low-order ratios vs random",
      "E4: low-order cluster locks persist under coarse community merges"
    ],
    "nulls": ["edge-rewired graphs"],
    "steer": "Adjust K near threshold; steer Ï‰_i to nearest low-order cluster ratio."
  },
  {
    "id": "DELTA.INFO.BottleneckInteger.v1",
    "type": "principle",
    "title": "Information Bottleneck with Integer Bias",
    "summary": "Compression under IB should prefer features that express small-integer phase structure (predictive & short code).",
    "defs": [
      "maximize I(Z;Y) âˆ’ Î² I(Z;X)",
      "Z features include p:q annotations"
    ],
    "equations": [
      "prior(Z contains p:q) âˆ exp(âˆ’Î»(p+q))",
      "accept p:q if increases I(Z;Y) at lower I(Z;X)"
    ],
    "audits": [
      "E3: adding integer feature improves validation I(Z;Y) vs null",
      "E4: preference persists under pooling"
    ],
    "nulls": ["shuffled labels Y"],
    "steer": "Inject integer features only when they reduce description length."
  },
  {
    "id": "DELTA.EST.FisherCramerRao.v1",
    "type": "principle",
    "title": "Fisher Information & CRLB for Phase",
    "summary": "Quantify estimator precision for phase/frequency; gate claims with variance bounds.",
    "defs": [
      "Fisher I(Î¸), CRLB: Var(Î¸Ì‚) â‰¥ 1/I(Î¸)"
    ],
    "equations": [
      "flag provisional when Var(Î¸Ì‚) near CRLB",
      "accept locks only if confidence surpasses bound by margin"
    ],
    "audits": [
      "E0: variance calibration on test tones",
      "E4: bound behavior consistent under pooling"
    ],
    "nulls": ["claims exceeding CRLB without SNR/window increase"],
    "steer": "Increase SNR or window before phase forcing when near bound."
  },
  {
    "id": "DELTA.EST.KalmanSmootherEM.v1",
    "type": "protocol",
    "title": "Kalman Smoother + EM with Phase States",
    "summary": "Estimate latent phasors with smoother; EM learns Ï‰,Q,R with integer priors.",
    "defs": [
      "augment state with phasor components",
      "EM updates for Ï‰ penalized by Î»(p+q)"
    ],
    "equations": [
      "maximize likelihood âˆ’ Î»(p+q) âˆ’ Î³ Î´^2 âˆ’ Î²' Î¶",
      "accept only if Î”H*â†‘ and MDL gain > 0"
    ],
    "audits": [
      "E3: tiny prior tilts toward low-order increase stability and fit vs flat priors",
      "E4: learned low-order Ï‰ persist under new data"
    ],
    "nulls": ["randomized time order"],
    "steer": "Initialize with continued-fraction convergents; prune high-order Ï‰."
  },
  {
    "id": "DELTA.TDA.PersistentHomologyRG.v1",
    "type": "protocol",
    "title": "Persistent Homology as RG Witness",
    "summary": "Topological features that persist across scales certify structure; short-lived ones are high-order clutter.",
    "defs": [
      "barcodes for H_0,H_1,â€¦ across scale Îµ",
      "persistence length â„“"
    ],
    "equations": [
      "accept features with â„“>â„“_min and integer phase ties",
      "penalize non-persistent features via Î¶"
    ],
    "audits": [
      "E4: long bars persist under coarse-grain",
      "E3: micro-nudges that should strengthen loops increase â„“ predictably"
    ],
    "nulls": ["random point clouds"],
    "steer": "Align phase interventions that lengthen meaningful bars; prune transient loops."
  },
  {
    "id": "DELTA.DYN.CatastropheBifurcation.v1",
    "type": "principle",
    "title": "Bifurcations & Low-Order Tongue Birth",
    "summary": "At saddle-node/period-doubling/Neimarkâ€“Sacker bifurcations, new low-order tongues emerge; Î” predicts which to privilege.",
    "defs": [
      "control Î¼, map x_{n+1}=f(x_n;Î¼)",
      "rotation number Ï"
    ],
    "equations": [
      "near bifurcation, prefer simplest emergent p:q; penalize higher-order",
      "Îµ_cap scales with square-root distance to saddle-node"
    ],
    "audits": [
      "E3: tiny Î¼ shifts trigger predicted tongue entry/exit",
      "E4: emergent low-order persists under blur"
    ],
    "nulls": ["spurious detections away from bifurcation"],
    "steer": "Ride the first low-order tongue after onset; avoid brittle higher branches."
  },
  {
    "id": "DELTA.MAP.LogisticEdgeChaos.v1",
    "type": "protocol",
    "title": "Logistic Map: Windows of Commensurability",
    "summary": "Between chaotic bands, low-order periodic windows (e.g., 3-cycle) act as Î” capture zones.",
    "defs": [
      "x_{n+1}=r x_n(1âˆ’x_n)",
      "windows labeled by period p (small first)"
    ],
    "equations": [
      "accept windows with small p; map p to p:1 locks",
      "Îµ_stab decreases as r approaches band edges"
    ],
    "audits": [
      "E3: tiny r change moves in/out of window with Kâ†‘/â†“",
      "E4: small-p windows persist under coarse binning"
    ],
    "nulls": ["synthetic sequences with shuffled order"],
    "steer": "Operate in smallest windows that meet Î¶ guardrails."
  },
  {
    "id": "DELTA.NET.WTA.MWUSteering.v1",
    "type": "protocol",
    "title": "Multiplicative Weights for Amplitude Steering",
    "summary": "Update channel amplitudes toward contributors aligned with arg X; stop when comfort corridor holds.",
    "defs": [
      "A_iâ†A_iÂ·exp(Î· C_i); simplex project",
      "C_i=cos(Î¸_iâˆ’arg X)âˆ’T"
    ],
    "equations": [
      "stop if max_i |C_i|â‰¤Ï„_C, â€–Î”Aâ€–_1â‰¤Ï„_A, Î”Tâ‰¤Ï„_T (v1.1 defaults)",
      "penalize updates that raise Î¶"
    ],
    "audits": [
      "E3: MWU at strong phases lifts R and Î”H* vs random reweights",
      "E4: improvements persist under pooling"
    ],
    "nulls": ["shuffle phases (C_iâ‰ˆ0)"],
    "steer": "Small Î·; interleave with F/P steps; respect guardrails."
  }
]
[
  {
    "id": "DELTA.PDE.ReactionDiffusionTuring.v1",
    "type": "protocol",
    "title": "Turing Patterns as Low-Order Spatial Locks",
    "summary": "Reactionâ€“diffusion systems develop spatial modes; small-integer wavenumber ratios lock across species and boundary clocks, yielding legible patterns.",
    "defs": [
      "u_t = D_u âˆ‡Â²u + f(u,v),  v_t = D_v âˆ‡Â²v + g(u,v)",
      "spatial phases Î¸_k(x)=kÂ·x, wavenumbers |k|",
      "Îµ_cap in k-space; Îµ_stab from dispersion curve margin"
    ],
    "equations": [
      "Î”_{p:q}(x) = p Î¸_k^u(x) âˆ’ q Î¸_k^v(x) (mod 2Ï€)",
      "K_{p:q} = âŸ¨cos Î”_{p:q}âŸ© e^{âˆ’Î»(p+q)} e^{âˆ’Î³ ||k_u|/|k_v| âˆ’ p/q|}",
      "Îµ_stab âˆ max_Ï‰ Re(Ïƒ_k) âˆ’ 0^+"
    ],
    "audits": [
      "E0: calibration of discretization (Î”x, Î”t, BCs)",
      "E1: stable band of growing modes at onset",
      "E2: invariance to origin shift in x",
      "E3: tiny parameter nudge (D_u/D_v or f,g coefficients) into tongue raises K and PLI (pattern legibility)",
      "E4: low-order wavenumber ratios persist under downsample/blur"
    ],
    "nulls": ["random-phase initial conditions without growth band (control)"],
    "steer": "Tune parameters into first unstable band; prefer smallest |k| ratios; enforce spatial rests (masking) to reduce Î¶."
  },
  {
    "id": "DELTA.STOC.StochasticResonanceEligibility.v1",
    "type": "principle",
    "title": "Stochastic Resonance as Eligibility Booster",
    "summary": "Moderate noise can increase capture by helping cross small barriers; use noise as a controlled Îµ_cap widener with Î¶ guardrails.",
    "defs": [
      "signal s(t), noise Î·(t) with SNR",
      "effective barrier Î”E; Kramers rate r âˆ e^{âˆ’Î”E/D}"
    ],
    "equations": [
      "âˆ‚ Îµ_cap / âˆ‚D > 0 for small D, then â†“ for large D",
      "choose D* that maximizes K subject to Î¶ â‰¤ Î¶_max"
    ],
    "audits": [
      "E3: controlled noise increases K & Î”H* at low D; degrades at high D",
      "E4: D* robust under pooling"
    ],
    "nulls": ["noise injections off-phase (no benefit)"],
    "steer": "Inject minimal noise only when near-threshold; roll off once Îµ_stab>0."
  },
  {
    "id": "DELTA.SEP.ICAIntegerPrior.v1",
    "type": "protocol",
    "title": "ICA with Small-Integer Phase Priors",
    "summary": "Independent components that exhibit low-order cross-phase ties are preferred; decorrelation plus Î”-lock acceptance.",
    "defs": [
      "X=AS, ICA unmixing W, components s_i",
      "cross-phase Î”_{p:q}(i,j)"
    ],
    "equations": [
      "cost = negentropy(S) âˆ’ w_K Î£ K_{p:q}(i,j) âˆ’ Î»(p+q)",
      "accept components if MDL gain > 0 and Î¶ decreases"
    ],
    "audits": [
      "E1: stability of components across runs",
      "E3: micro-retune (temporal alignment) increases accepted K_{p:q}",
      "E4: accepted ties persist on new segments"
    ],
    "nulls": ["time-scrambled data"],
    "steer": "Bias rotations toward bases revealing small p:q; prune brittle ties."
  },
  {
    "id": "DELTA.GRAPH.CurvatureFrustration.v1",
    "type": "principle",
    "title": "Graph Curvature & Frustration as Harmony Diagnostics",
    "summary": "Use cycle holonomy and discrete curvature to detect incompatible locks; minimize frustration to reduce Î¶.",
    "defs": [
      "lock-graph with edge phases Ï†_ij and ratios p:q",
      "cycle holonomy h_C = wrap(Î£ Ï†_ij along C)"
    ],
    "equations": [
      "curvature Îº_C âˆ |h_C|; Î¶â†‘ with Î£_C Îº_C",
      "Bridge Finder seeks edits that minimize Î£ Îº_C"
    ],
    "audits": [
      "E2: holonomy invariant to gauge on nodes",
      "E3: small edge retunes reduce Î£ Îº_C and increase Î”H*",
      "E4: low-curvature motifs persist under coarse contraction"
    ],
    "nulls": ["random phase assignments"],
    "steer": "Repair with minimal dual locks; break high-order edges first."
  },
  {
    "id": "DELTA.QCTRL.GRAPEIntegerPenalty.v1",
    "type": "protocol",
    "title": "Quantum GRAPE with Integer Penalties",
    "summary": "Add small-integer phase-ratio penalties to GRAPE cost to steer toward robust, low-order controls.",
    "defs": [
      "goal unitary U_T, controls u_k(t)",
      "GRAPE gradient âˆ‚J/âˆ‚u_k"
    ],
    "equations": [
      "J = 1 âˆ’ F(U_T,U) + Î» Î£(p+q) âˆ’ w_K Î£|K_{p:q}| + w_Î¶ Î¶",
      "u_k â† u_k âˆ’ Î· âˆ‚J/âˆ‚u_k"
    ],
    "audits": [
      "E3: integer-penalized schedules achieve equal fidelity with lower Î¶ vs plain GRAPE",
      "E4: low-order structure persists under timing blur"
    ],
    "nulls": ["controls with shuffled phases"],
    "steer": "Prefer solutions with fewer, lower-order phase relations at same fidelity."
  },
  {
    "id": "DELTA.WAVE.DispersionPhaseMatching.v1",
    "type": "protocol",
    "title": "Wave Equation: Dispersion & Phase Matching",
    "summary": "Phase-matching selects small-integer mode couplings; mis-match raises Î¶ and kills locks.",
    "defs": [
      "u_tt = c^2 âˆ‡Â²u + N[u], dispersion Ï‰(k)",
      "phase mismatch Î”k, Î”Ï‰"
    ],
    "equations": [
      "accept triad if k1Â±k2Â±k3=0 and Ï‰1Â±Ï‰2Â±Ï‰3â‰ˆ0 (small integers)",
      "penalize mismatch via Î³(Î”k^2+Î”Ï‰^2)"
    ],
    "audits": [
      "E1: identify stable peaks in k,Ï‰",
      "E3: tiny tuning reduces mismatch and raises K",
      "E4: matched triads persist under downsample"
    ],
    "nulls": ["random triad selection"],
    "steer": "Tune toward exact match; drop brittle high-order triads."
  },
  {
    "id": "DELTA.EST.PhaseUnwrapCRLB.v1",
    "type": "principle",
    "title": "Phase Unwrapping with CRLB Guards",
    "summary": "Guarantee unwrapping only when estimator variance allows; otherwise mark provisional.",
    "defs": [
      "wrapped phase Ïˆ, true phase Î¸",
      "CRLB: Var(Î¸Ì‚) â‰¥ 1/I(Î¸)"
    ]
    ,
    "equations": [
      "if Var(Î¸Ì‚) > Ï„/I(Î¸) â‡’ hold (no unwrap); else unwrap with continuity prior",
      "Î¶â†‘ when jumps contradict continuity"
    ],
    "audits": [
      "E0: variance calibration on synthetic sinusoids",
      "E4: unwrap decisions stable under pooling"
    ],
    "nulls": ["unwraps that flip after slight smoothing"],
    "steer": "Increase SNR/window before forcing unwrap near the bound."
  },
  {
    "id": "DELTA.SAMP.PoissonDiskObserver.v1",
    "type": "protocol",
    "title": "Poisson-Disk Sampling for Stable Phase",
    "summary": "Choose samples with blue-noise spacing to minimize aliasing and Î¶ in spatial phase estimation.",
    "defs": [
      "min-distance r sampling in 2D/3D",
      "expected spectrum of Poisson-disk"
    ],
    "equations": [
      "Î¶ âˆ alias_energy; minimize via r tuned to bandlimit",
      "accept locks that persist under jittered resampling"
    ],
    "audits": [
      "E1: measured MTF matches blue-noise theory",
      "E3: small r adjustments reduce alias peaks and raise K",
      "E4: accepted locks stable under resampling"
    ],
    "nulls": ["grid samples causing moirÃ© artifacts"],
    "steer": "Use Poisson-disk with r set by Î”Ï‰; refine adaptively where S* high."
  },
  {
    "id": "DELTA.RL.MDPPhaseScheduling.v1",
    "type": "protocol",
    "title": "Phase-Scheduled Policies in MDPs",
    "summary": "Augment state with clocks; schedule actions at low-order phases to raise reward harmony Î”H*.",
    "defs": [
      "MDP (S,A,P,R), added clocks Ï†_k",
      "policy Ï€(a|s,Ï†)"
    ],
    "equations": [
      "regularize Ï€ toward actions at accepted phases",
      "penalty Î»(p+q) on phase features"
    ],
    "audits": [
      "E3: phase-aware Ï€ improves reward at same action budget vs phase-agnostic",
      "E4: low-order timings persist across seeds/environments"
    ],
    "nulls": ["shuffled clock labels"],
    "steer": "Learn clocks; lock first; then fine-tune policy."
  },
  {
    "id": "DELTA.GAME.ReplicatorResonance.v1",
    "type": "protocol",
    "title": "Replicator Dynamics: Strategy Phase Locks",
    "summary": "In cyclical games (rockâ€“paperâ€“scissors, etc.), strategy proportions oscillate; accept small p:q locks vs exogenous clocks or between subpopulations.",
    "defs": [
      "xÌ‡_i = x_i[(A x)_i âˆ’ x^âŠ¤ A x]",
      "phases Î¸_i of strategy cycles"
    ],
    "equations": [
      "Î”_{p:q}=p Î¸_sub1 âˆ’ q Î¸_sub2 (or vs season clock)",
      "accept if Kâ†‘, Îµ_stab>0"
    ],
    "audits": [
      "E3: timed incentives at accepted phases improve payoff stability",
      "E4: low-order locks persist across cohorts"
    ],
    "nulls": ["label shuffles of strategies"],
    "steer": "Time nudges at phase landings; avoid brittle high-order incentives."
  },
  {
    "id": "DELTA.NEURO.STDPPhaseWindows.v1",
    "type": "protocol",
    "title": "STDP & Phase Windows",
    "summary": "Spike-timing-dependent plasticity is a phase operator: small timing offsets within windows produce stable potentiation/depression patterns.",
    "defs": [
      "Î”w âˆ f(Î”t), preâ€“post lag Î”t",
      "network oscillation phase Ï†"
    ],
    "equations": [
      "phase-locked pairing at Î”t near low-order fractions of cycle maximizes Î”w",
      "Î¶â†‘ when pairing off-phase"
    ],
    "audits": [
      "E3: micro shifts in spike timing at strong phases increase synchrony and K",
      "E4: phase windows persist under frequency scaling"
    ],
    "nulls": ["randomized pairing times"],
    "steer": "Schedule pairing at strongest phase windows; keep amplitudes minimal."
  },
  {
    "id": "DELTA.INFO.MutualInfoPhase.v1",
    "type": "equation",
    "title": "Mutual Information of Phase-Locked Streams",
    "summary": "Low-order locks increase I(X;Y) for phase-coded channels; use MI as an independent sore-thumb term.",
    "defs": [
      "I(X;Y)=âˆ‘ p(x,y) log p(x,y)/(p(x)p(y))",
      "phase-coded symbols at angles"
    ],
    "equations": [
      "âˆ‚ I / âˆ‚K > 0 near accepted locks; include w_MI I in S*",
      "penalize MI gains that raise Î¶ (overfitting)"
    ],
    "audits": [
      "E3: on-phase nudges raise MI vs off-phase",
      "E4: MI gains persist under pooling"
    ],
    "nulls": ["surrogates with destroyed phase relations"],
    "steer": "Use MI as an orthogonal check before promoting locks."
  },
  {
    "id": "DELTA.CTRL.ClockedLSTM.v1",
    "type": "protocol",
    "title": "Clocked Recurrent Models with Integer Priors",
    "summary": "Inject clocks and low-order penalties into RNN/LSTM/Transformer schedules; prefer weights that express p:q rhythms.",
    "defs": [
      "hidden h_t; gating by phase Ï†_k(t)",
      "regularizer on p:q features"
    ],
    "equations": [
      "loss = task_loss + Î» Î£(p+q) âˆ’ w_K Î£|K_{p:q}| + w_Î¶ Î¶",
      "promote weights that raise Î”H* and reduce Î¶"
    ],
    "audits": [
      "E3: inserting clocks improves OOS with fewer parameters",
      "E4: learned low-order rhythms persist across lengths"
    ],
    "nulls": ["random clock injections"],
    "steer": "Add minimal clocks; prune if Î¶ or MDL worsen."
  },
  {
    "id": "DELTA.GEOM.FramesWaveatoms.v1",
    "type": "protocol",
    "title": "Waveatoms/Curvelets with Integer Alignment",
    "summary": "Use directional frames; accept angleâ€“scale pairs that show small-integer ties across features.",
    "defs": [
      "atoms Ïˆ_{j,Î¸,m}(x)",
      "ties between feature angles Î¸_a, Î¸_b"
    ],
    "equations": [
      "accept if angle ratios near p:q with small (p+q) and Kâ†‘",
      "penalize brittle high-order alignments"
    ],
    "audits": [
      "E3: minimal rotation/scale tweaks increase K and PLI",
      "E4: accepted ties persist under resolution changes"
    ],
    "nulls": ["randomized orientations"],
    "steer": "Favor coarse scales and small-integer angle ties; refine only where S* high."
  }
]
[
  {
    "id": "DELTA.GW.ChirpLocking.v1",
    "type": "protocol",
    "title": "Gravitational-Wave Chirps as Phase Locks",
    "summary": "Inspiral signals are chirped phasors; matched filters track low-order harmonic structure across detectors/clocks.",
    "defs": [
      "strain h(t)=A(t) cos Î¸(t), chirp Ï‰Ì‡>0",
      "detector phases Ï†_d(t), template bank"
    ],
    "equations": [
      "Î”_{1:1}(t)=Î¸_template(t)âˆ’Î¸_data(t)",
      "K=âŸ¨cos Î”_{1:1}âŸ© with MDL penalty for template order"
    ],
    "audits": [
      "E1: stable inter-detector phase differences at arrival delays",
      "E2: invariance to global phase and time origin",
      "E3: tiny template chirp-rate tweaks raise K vs off-manifold",
      "E4: chirp lock persists under downsample/whitening"
    ],
    "nulls": ["time-slid coincidences; phase-scrambled surrogates"],
    "steer": "Retune chirp mass/spin (F) before phase trim; demand Î¶â†“ across detectors."
  },
  {
    "id": "DELTA.PDE.SolitonLock.v1",
    "type": "protocol",
    "title": "Solitons as 1:1 Phaseâ€“Shape Locks",
    "summary": "KdV/NLS solitons maintain phaseâ€“shape coherence; collisions show low-order integer shifts.",
    "defs": [
      "NLS: iÏˆ_t+Ïˆ_xx+2|Ïˆ|^2Ïˆ=0; KdV: u_t+6uu_x+u_{xxx}=0",
      "carrier phase Î¸, envelope A(xâˆ’ct)"
    ],
    "equations": [
      "Lock: Î¸Ì‡â‰ˆconst with Îµ_stab from invariants (mass, momentum)",
      "K=âŸ¨cos(Î¸_1âˆ’Î¸_2)âŸ© for bound states; penalize detune"
    ],
    "audits": [
      "E1: invariants stable; phase tracks consistent",
      "E3: tiny c or nonlinearity nudges change K predictably",
      "E4: soliton coherence persists under moderate blur"
    ],
    "nulls": ["dispersive wavepackets without coherence"],
    "steer": "Tune to regimes with integrals conserved; avoid brittle multi-soliton high-order stacks."
  },
  {
    "id": "DELTA.THERM.TURBound.v1",
    "type": "principle",
    "title": "Thermodynamic Uncertainty Relation (TUR) Guard",
    "summary": "Precision of phase-estimated currents is bounded by entropy production; flags overconfident locks.",
    "defs": [
      "current J, variance Var(J), entropy prod Î£",
      "TUR: Var(J)/âŸ¨JâŸ©^2 â‰¥ 2/Î£"
    ],
    "equations": [
      "flag provisional if estimator violates TUR",
      "require Î£ evidence for high-precision phase claims"
    ],
    "audits": [
      "E0: Î£ estimation calibrated",
      "E4: bound respected under coarse-grain"
    ],
    "nulls": ["precision claims without energetic budget"],
    "steer": "Increase Î£ (energy/info flow) or relax precision target; prefer low-order locks to reduce required Î£."
  },
  {
    "id": "DELTA.QEC.SyndromePhaseLocks.v1",
    "type": "protocol",
    "title": "Quantum Error Correction via Syndrome Phases",
    "summary": "Stabilizer readouts form phase-coded syndromes; small-integer cycles in schedules improve fidelity.",
    "defs": [
      "stabilizers S_i, syndrome stream s_i(t)",
      "readout clock Ï†_r, gate clocks Ï†_g"
    ],
    "equations": [
      "Î”_{p:q}=p Ï†_schedule âˆ’ q Ï†_error (mod 2Ï€)",
      "accept schedule p:q if logical error rate â†“ with Î¶ not â†‘"
    ],
    "audits": [
      "E1: reproducible syndrome phases",
      "E3: micro-timing of gates/readout at accepted phases reduces error vs randomized",
      "E4: low-order schedules persist under batching"
    ],
    "nulls": ["label-shuffled syndromes"],
    "steer": "Favor 1:1/2:1 cycles between gates and readout; abort if brittleness increases."
  },
  {
    "id": "DELTA.OPT.PhaseRetrievalDelta.v1",
    "type": "protocol",
    "title": "Sparse Phase Retrieval with Î” Guards",
    "summary": "Gerchbergâ€“Saxton/Fienup steps augmented with Î¶ and low-order priors to avoid brittle reconstructions.",
    "defs": [
      "constraints: |F{x}|=Y, support S, sparsity",
      "iterate xâ†P_S âˆ˜ F^{-1}(YÂ·e^{iâˆ F{x}})"
    ],
    "equations": [
      "add MDL penalty for high-order features; prefer small-integer angle ties",
      "stop when Î¶ stops decreasing"
    ],
    "audits": [
      "E3: small on-constraint perturbations improve K/PLI without Î¶â†‘",
      "E4: features persist under downsample"
    ],
    "nulls": ["mismatched constraints; randomized magnitudes"],
    "steer": "Regularize with integer priors; reject solutions that fail RG."
  },
  {
    "id": "DELTA.GEOM.ChernIntegerWitness.v1",
    "type": "principle",
    "title": "Chern Number as Topological Integer Lock",
    "summary": "Topological phases are certified by integer Chern numbers; robust to noise/coarse-grain (RG-stable).",
    "defs": [
      "Berry curvature F(k), C=(1/2Ï€)âˆ«_{BZ} F dk",
      "phase winding over Brillouin torus"
    ],
    "equations": [
      "accept only if C is integer within tolerance and persists under discretization changes",
      "penalize spurious high-order band couplings"
    ],
    "audits": [
      "E2: gauge invariance under U(1) changes",
      "E4: C stable under mesh refinement/coarse-grain"
    ],
    "nulls": ["trivial bands with Câ‰ˆ0 masquerading via noise"],
    "steer": "Exploit integer protection; nudge towards simpler band couplings."
  },
  {
    "id": "DELTA.SIGNAL.ChirpZTransform.v1",
    "type": "protocol",
    "title": "Chirp-Z for Focused Ratio Scans",
    "summary": "Zooms spectral analysis around suspected p:q bands; improves Îµ_cap without huge N.",
    "defs": [
      "CZT parameters (A,W,M)",
      "target band around Ï‰*"
    ],
    "equations": [
      "choose CZT grid so Ï‰_kâ‰ˆÏ‰*Â·W^k; scan p:q near Ï‰_b/Ï‰_aâ‰ˆp/q",
      "accept if K rises and Î¶ not â†‘"
    ],
    "audits": [
      "E1: CZT matches FFT on overlaps",
      "E3: micro-retune inside CZT band raises K",
      "E4: accepted peaks persist across zoom factors"
    ],
    "nulls": ["zoomed noise with no lock persistence"],
    "steer": "Use CZT before dialing up global N; confirm with RG."
  },
  {
    "id": "DELTA.SIGNAL.WienerKhinchinBridge.v1",
    "type": "principle",
    "title": "Autocorrelationâ€“Spectrum Bridge",
    "summary": "Phase structure manifests as peaks in both spectrum and autocorrelation; cross-validate locks.",
    "defs": [
      "R_x(Ï„)=E[x(t)x(t+Ï„)], S_x(Ï‰)=FT{R_x}",
      "lag phases Ï†_Ï„"
    ],
    "equations": [
      "accept lock if spectral K and autocorr peaks agree at low-order lags",
      "penalize disagreement via Î¶"
    ],
    "audits": [
      "E1: bridge holds on calibration tones",
      "E4: agreement persists under pooling"
    ],
    "nulls": ["surrogates with broken phase but same |X|"],
    "steer": "Require dual evidence before promotion."
  },
  {
    "id": "DELTA.NLP.ProsodyPhaseLocks.v1",
    "type": "protocol",
    "title": "Prosody & Rhythm in Speech",
    "summary": "Syllabic/cadence clocks phase-lock at low order; timing nudges improve intelligibility and naturalness.",
    "defs": [
      "syllable rate f_syl, phrase rate f_phr",
      "phases Î¸_syl, Î¸_phr"
    ],
    "equations": [
      "Î”_{p:q}=p Î¸_phr âˆ’ q Î¸_syl; accept small p:q with Kâ†‘",
      "Î”H*: MOS/intelligibility gain"
    ],
    "audits": [
      "E1: stable syllable/phrase rates",
      "E3: micro-timing edits near accepted phases raise MOS vs sham",
      "E4: low-order persists across speakers/speeds"
    ],
    "nulls": ["word/phone shuffles"],
    "steer": "Time pauses/emphasis at strong phases; avoid brittle high-order prosody."
  },
  {
    "id": "DELTA.VISION.SaccadeLocking.v1",
    "type": "protocol",
    "title": "Saccade Timing vs Environmental Clocks",
    "summary": "Eye movements entrain to scene dynamics; low-order locks improve task performance.",
    "defs": [
      "saccade phase Î¸_sac; stimulus phase Î¸_env",
      "performance H*: accuracy/RT"
    ],
    "equations": [
      "accept p:q if Kâ†‘ and H* improves under micro-timing",
      "Îµ_stab from variance of inter-saccade intervals"
    ],
    "audits": [
      "E3: cue timing at accepted phases improves RT/accuracy",
      "E4: locks persist across scenes"
    ],
    "nulls": ["shuffled cue timings"],
    "steer": "Schedule cues at accepted phases; keep interventions minimal."
  },
  {
    "id": "DELTA.SIGNAL.HHTEMD.v1",
    "type": "protocol",
    "title": "Hilbertâ€“Huang (EMD) with Î” Guards",
    "summary": "Decompose into IMFs; accept IMFs showing low-order cross-locks; reject mode mixing (Î¶â†‘).",
    "defs": [
      "IMFs c_k(t), analytic phases Î¸_k",
      "mode alignment across channels"
    ],
    "equations": [
      "accept pairs with K_{p:q}â†‘ and Îµ_stab>0",
      "penalize IMFs with mode mixing via Î¶"
    ],
    "audits": [
      "E1: IMF sifting quality checks",
      "E3: micro-detune tests on aligned IMFs raise K",
      "E4: accepted pairs persist across windows"
    ],
    "nulls": ["sifted surrogates"],
    "steer": "Use post-EMD locking; re-sift if Î¶ high."
  },
  {
    "id": "DELTA.COMMS.ConstellationInteger.v1",
    "type": "protocol",
    "title": "QAM/PSK Constellations with Integer Geometry",
    "summary": "Prefer constellation rotations/scalings that yield small-integer symbol rhythms with channel clocks; boosts synchronization and BER.",
    "defs": [
      "carrier clock Ï†_c, symbol clock Ï†_s",
      "PSK/QAM phases"
    ],
    "equations": [
      "accept p:q between Ï†_s and Ï†_c with Kâ†‘; BERâ†“ under micro-timing",
      "penalize high-order rotations that raise Î¶"
    ],
    "audits": [
      "E3: tiny timing/phase corrections at accepted ratios reduce BER",
      "E4: low-order sync persists across SNR"
    ],
    "nulls": ["random rotations"],
    "steer": "Lock symbol/carrier at 1:1, 2:1 where feasible; avoid brittle high-order mappings."
  },
  {
    "id": "DELTA.GRAPH.OllivierRicciPhase.v1",
    "type": "principle",
    "title": "Ollivierâ€“Ricci Curvature as Phase Flow Health",
    "summary": "Positive curvature along phase-aligned edges signals coherence; negative curvature flags frustration.",
    "defs": [
      "Îº_OR(e) via Wasserstein distance of neighbor measures",
      "phase-labeled edges"
    ],
    "equations": [
      "promote edges with Îº_OR>0 and Kâ†‘; repair Îº_OR<0 cycles",
      "Î¶ âˆ Î£ negative curvature hotspots"
    ],
    "audits": [
      "E3: edge retunes that increase Îº_OR also raise Î”H*",
      "E4: curvature patterns persist under coarse graph merges"
    ],
    "nulls": ["phase-randomized graphs"],
    "steer": "Bridge negative-curvature loops with dual low-order locks."
  },
  {
    "id": "DELTA.EST.BootstrapRG.v1",
    "type": "protocol",
    "title": "Bootstrap + RG Consistency",
    "summary": "Combine resampling with coarse-grain: accept locks that survive both uncertainty and RG.",
    "defs": [
      "bootstrap replicates B",
      "coarse factors c"
    ],
    "equations": [
      "accept if Pr_boot(K>Ï„) high and RG slope favorable",
      "demote otherwise"
    ],
    "audits": [
      "E4: dual persistence check required for promotion"
    ],
    "nulls": ["effects that flip across bootstraps or vanish under coarse-grain"],
    "steer": "Require both: CI support and RG survival."
  }
]
[
  {
    "id": "DELTA.EPI.SIRPhaseControl.v1",
    "type": "protocol",
    "title": "SIR Epidemics: Intervention Timing at Low-Order Phases",
    "summary": "Epidemic waves exhibit phase structure; schedule minimal interventions at low-order phases (e.g., 1:1 with weekly cycles) to reduce peak load and total cost.",
    "defs": [
      "SIR: á¹ =âˆ’Î²SI, Äª=Î²SIâˆ’Î³I, á¹˜=Î³I",
      "intrinsic phase Î¸_I(t) from I(t); exogenous clock Î¸_w (weekly)",
      "Îµ_cap for p:q between Î¸_I and Î¸_w; stability via variance of Rt estimates"
    ],
    "equations": [
      "Î”_{p:q}=p Î¸_w âˆ’ q Î¸_I (mod 2Ï€)",
      "K_{p:q}=âŸ¨cos Î”_{p:q}âŸ© e^{âˆ’Î»(p+q)} e^{âˆ’Î³ |Ï‰_w/Ï‰_I âˆ’ p/q|}",
      "Î”H*: reduction in peak I and area under I with minimal NPI cost"
    ],
    "audits": [
      "E0: reporting-delay and test-rate calibration",
      "E1: stable wave phase estimates in-window",
      "E2: invariance under clock origin; consistent Rt smoothing",
      "E3: micro-timing NPIs near accepted phases reduces peaks vs randomized timing at same intensity",
      "E4: 1:1 or 2:1 locks persist across regions/coarse aggregation"
    ],
    "nulls": ["phase/label shuffles of intervention days", "synthetic Rt noise surrogates"],
    "steer": "Target smallest p:q (1:1 weekly); keep intensity minimal; release when Îµ_stab>0 and Î¶ trending down."
  },
  {
    "id": "DELTA.METRO.HeisenbergPhaseLimit.v1",
    "type": "principle",
    "title": "Quantum Metrology: Heisenberg Phase Bound",
    "summary": "Phase estimation precision is bounded; Î” flags claims near/over the SQL/Heisenberg limits and budgets trials accordingly.",
    "defs": [
      "SQL: Var(Ï†Ì‚) â‰¥ 1/N; Heisenberg: Var(Ï†Ì‚) â‰¥ 1/N^2 (entangled)",
      "Fisher I(Ï†)"
    ],
    "equations": [
      "Var(Ï†Ì‚) â‰¥ 1/I(Ï†) â‰¥ c/N^Î±, Î±âˆˆ{1,2}",
      "flag provisional when near bound; require energy/trial budget"
    ],
    "audits": [
      "E0: shot-noise calibration, photon/atom counting",
      "E4: scaling slope Î± consistent under doubling trials"
    ],
    "nulls": ["super-Heisenberg claims without resource accounting"],
    "steer": "Increase N coherently or improve I(Ï†); prefer low-order phase protocols to maximize Fisher per resource."
  },
  {
    "id": "DELTA.STATS.CircularVonMisesDelta.v1",
    "type": "equation",
    "title": "Circular Statistics: von Mises & Î” Lock Mapping",
    "summary": "Maps circular concentration Îº and mean direction Î¼ to Î” lock score and phase uncertainty.",
    "defs": [
      "von Mises VM(Î¼,Îº), resultant R=I_1(Îº)/I_0(Îº)"
    ],
    "equations": [
      "K â‰ˆ R Â· cos(Î”_{p:q}) with prior e^{âˆ’Î»(p+q)}",
      "Var(Î¸) â‰ˆ 1/Îº; Î¶â†‘ when Îº small near acceptance"
    ],
    "audits": [
      "E1: Râ€“Îº calibration via samples",
      "E3: on-manifold nudges increase Îº and K",
      "E4: Îº ranking persists under pooling"
    ],
    "nulls": ["uniform circular surrogates"],
    "steer": "Promote locks only if Îº passes threshold and Î¶ decreases."
  },
  {
    "id": "DELTA.SIGNAL.BispectrumIntegerCoupling.v1",
    "type": "protocol",
    "title": "Cross-Bispectrum for Integer Coupling (2:1, 3:1)",
    "summary": "Detects quadratic/cubic phase coupling; certify 2:1 or 3:1 locks beyond pairwise coherence.",
    "defs": [
      "bispectrum B(Ï‰1,Ï‰2)=E[X(Ï‰1)X(Ï‰2)X*(Ï‰1+Ï‰2)]",
      "bicoherence b^2=|B|^2/(E|X|^2E|X|^2E|X|^2)"
    ],
    "equations": [
      "accept 2:1 if peak at (Ï‰,Ï‰)â†’2Ï‰ with phase consistency",
      "MDL penalty for higher orders"
    ],
    "audits": [
      "E1: stability across segments",
      "E3: tiny detune reduces bicoherence monotonically near accepted ratio",
      "E4: low-order couplings persist under coarse time bins"
    ],
    "nulls": ["phase-scrambled surrogates preserving |X|"],
    "steer": "Lock fundamentals first; promote nonlinear ties only when they reduce Î¶ and improve Î”H*."
  },
  {
    "id": "DELTA.SIGNAL.PACComodulogram.v1",
    "type": "protocol",
    "title": "Phaseâ€“Amplitude Coupling (PAC) with Integer Priors",
    "summary": "Tests whether high-frequency amplitude locks to low-frequency phase at small p:q; uses comodulograms with Î” gates.",
    "defs": [
      "LF phase Î¸_LF, HF amplitude A_HF",
      "modulation index MI(Ï†)"
    ],
    "equations": [
      "K_{p:q}=âŸ¨A_HF cos(p Î¸_LF âˆ’ q Î¸_ref)âŸ© e^{âˆ’Î»(p+q)}",
      "accept if MIâ†‘ with Îµ_cap>0 and Î¶â†“"
    ],
    "audits": [
      "E1: LF/HF band stability",
      "E3: small phase trims near LF landing raise MI; off-phase â‰ˆ null",
      "E4: PAC at low order persists under pooling"
    ],
    "nulls": ["time-shifted surrogates breaking PAC"],
    "steer": "Prefer lowest p:q; avoid spurious PAC from spectral leakage (WindowingLeakage guard)."
  },
  {
    "id": "DELTA.SIGNAL.DemodHilbertGuard.v1",
    "type": "protocol",
    "title": "AM/FM Demodulation with Hilbert Guards",
    "summary": "Robustly extract instantaneous phase and amplitude; reject broadband cases that would inflate Î¶.",
    "defs": [
      "analytic x_a=A e^{iÎ¸}, Ï‰=Î¸Ì‡",
      "Bedrosian condition proxy"
    ],
    "equations": [
      "accept demod only when |A'|â‰ª|Ï‰|A (narrowband proxy)",
      "flag provisional otherwise"
    ],
    "audits": [
      "E1: demod tracks known AM/FM within tolerance",
      "E3: small carrier detune reflects predictably in Î¸Ì‡",
      "E4: estimates stable under moderate smoothing"
    ],
    "nulls": ["scrambled phases"],
    "steer": "Prefilter before demod; fall back to STFT-phase if proxy fails."
  },
  {
    "id": "DELTA.CTRL.NyquistWindingGuard.v1",
    "type": "principle",
    "title": "Nyquist Plot: Integer Winding & Stability Margin",
    "summary": "Use Nyquist winding around âˆ’1 as a topological integer; promote controllers that increase margin with minimal order.",
    "defs": [
      "open-loop L(iÏ‰); winding W around âˆ’1",
      "phase/gain margins"
    ],
    "equations": [
      "stability â†” W equals number of RHP poles",
      "prefer designs that raise margins and reduce Î¶ with small p:q timing structure"
    ],
    "audits": [
      "E0: frequency response calibration",
      "E3: micro timing/phase leadâ€“lag nudges improve margins",
      "E4: margins persist under model reduction"
    ],
    "nulls": ["illusory gains that vanish under sampling changes"],
    "steer": "Apply minimal phase lead/lag at low-order harmonics; confirm RG."
  },
  {
    "id": "DELTA.CTRL.BodeIntegralTradeoff.v1",
    "type": "principle",
    "title": "Bode Integral as Control Trade-Off Budget",
    "summary": "Integral constraints imply you pay elsewhere; Î” schedules low-order improvements where the budget is cheapest.",
    "defs": [
      "âˆ« log |S(iÏ‰)| dÏ‰ = Ï€ Î£ unstable poles (S sensitivity)"
    ],
    "equations": [
      "allocate improvement at low-order Ï‰-bands with highest Î”H*/bit saved",
      "penalize brittle peaking (Î¶â†‘)"
    ],
    "audits": [
      "E3: phase-scheduled edits reduce |S| in target band with minimal spillover",
      "E4: improvements persist under coarse plant models"
    ],
    "nulls": ["apparent wins from windowing only"],
    "steer": "Shape sensitivity around small-integer harmonics; avoid high-order peaking."
  },
  {
    "id": "DELTA.INFGEOM.NatGradPhaseManifold.v1",
    "type": "protocol",
    "title": "Natural Gradient on Phase Manifolds",
    "summary": "Optimize Î” objectives on U(1)^k with the Fisher metric; step along geodesics to reduce Î¶ and improve convergence.",
    "defs": [
      "manifold M=U(1)^k, metric G(Î¸)=I(Î¸)",
      "update: Î¸â†Î¸âˆ’Î· G^{-1}âˆ‡J"
    ],
    "equations": [
      "J includes Î»(p+q)+Î³Î´^2âˆ’w_K|K|+w_Î¶Î¶",
      "geodesic steps reduce parameter coupling and Î¶"
    ],
    "audits": [
      "E1: metric well-conditioned",
      "E3: natgrad reduces J faster than Euclidean at same step size",
      "E4: improvements persist under pooling"
    ],
    "nulls": ["random reparametrizations without metric"],
    "steer": "Use natgrad when phase parameters interact; keep Î· small; re-estimate G periodically."
  },
  {
    "id": "DELTA.STATS.GLMPhaseDesign.v1",
    "type": "protocol",
    "title": "Phase-Aware GLMs & Experimental Design",
    "summary": "Incorporate phase regressors with small-integer priors; choose designs to maximize Fisher for low-order effects.",
    "defs": [
      "GLM y=XÎ²+Îµ with phase columns cos pÎ¸, sin pÎ¸",
      "design D maximizing det(I(Î²))"
    ],
    "equations": [
      "prior Î²_p âˆ¼ N(0, Ï„_p^2), Ï„_p^2 âˆ e^{âˆ’Î» p}",
      "choose D that maximizes I while minimizing Î¶"
    ],
    "audits": [
      "E3: designed runs detect low-order effects at lower N vs random",
      "E4: effect ranks persist under aggregation"
    ],
    "nulls": ["random designs lacking power at target phases"],
    "steer": "Enrich near candidate landings; penalize high p columns."
  },
  {
    "id": "DELTA.CAUS.GrangerPhaseCausality.v1",
    "type": "protocol",
    "title": "Granger with Phase Conditioning",
    "summary": "Test predictive causality conditioned on phase bins; accept only low-order phase-specific effects that survive RG.",
    "defs": [
      "phase-binned VAR; bins at p:q landings",
      "F-test adjusted for multiple bins"
    ],
    "equations": [
      "accept if Granger effect significant in small set of low-order bins and Î”H*â†‘",
      "penalize widespread weak effects (Î¶â†‘)"
    ],
    "audits": [
      "E3: micro-timing interventions at accepted bins improve prediction",
      "E4: effects persist under coarser binning"
    ],
    "nulls": ["phase-scrambled labels"],
    "steer": "Act only in bins with strong locks; keep effect size minimal."
  },
  {
    "id": "DELTA.CTRL.BarrierPhaseSafety.v1",
    "type": "protocol",
    "title": "Control Barrier Functions with Phase Guards",
    "summary": "Enforce safety sets while pursuing Î” locks; barrier terms prevent unsafe phase regions.",
    "defs": [
      "safe set h(x)â‰¥0; CBF condition hÌ‡+Î±hâ‰¥0",
      "phase target Î”_{p:q}â‰ˆ0"
    ],
    "equations": [
      "minimize J_Î” subject to hÌ‡+Î±hâ‰¥0",
      "abort phase forcing when CBF activates"
    ],
    "audits": [
      "E3: controller increases K without violating safety vs naive",
      "E4: safety preserved under disturbances"
    ],
    "nulls": ["unsafe gains masquerading as Î” wins"],
    "steer": "Prioritize safety; trim phase only when Îµ_cap>0 and barrier slack positive."
  },
  {
    "id": "DELTA.SIGNAL.SynchrosqueezingLock.v1",
    "type": "protocol",
    "title": "Wavelet Synchrosqueezing for Clean Phase Ridges",
    "summary": "Concentrate timeâ€“frequency energy onto ridges; accept locks along low-order ridge pairs.",
    "defs": [
      "CWT W_x(a,b); synchrosqueezed T_x(Ï‰,b)",
      "ridge extraction Ï‰Ì‚(b)"
    ],
    "equations": [
      "K from Î”_{p:q} along ridge pairs; penalize gaps (Î¶)",
      "accept if ridge coherence Î“ high and MDL gain > 0"
    ],
    "audits": [
      "E1: ridge recovery on calibration chirps",
      "E3: micro-detunes bend ridges predictably",
      "E4: accepted ridge ties persist under parameter changes"
    ],
    "nulls": ["random ridge assignments"],
    "steer": "Use synchrosqueezing when STFT ridges smear; confirm with RG."
  },
  {
    "id": "DELTA.STATS.GLSIntegerPrior.v1",
    "type": "protocol",
    "title": "Generalized Least Squares with Integer Priors",
    "summary": "Regress with correlated noise while biasing toward small-integer phase regressors; demote brittle high-order fits.",
    "defs": [
      "y=XÎ²+Îµ, Cov(Îµ)=Î£; phase columns cos pÎ¸, sin pÎ¸"
    ],
    "equations": [
      "Î²Ì‚=(X^T Î£^{-1} X + Î›)^{-1} X^T Î£^{-1} y,  Î› diagonal with Î»_p âˆ (p+q)",
      "accept if MDL gain > 0 and Î¶â†“"
    ],
    "audits": [
      "E0: Î£ estimated via HAC or AR model",
      "E3: low-order columns improve fit OOS vs random phases",
      "E4: coefficients stable under pooling"
    ],
    "nulls": ["phase-shuffled regressors"],
    "steer": "Start with pâˆˆ{1,2,3}; expand only if RG supports."
  },
  {
    "id": "DELTA.NAV.PSLunarResonance.v1",
    "type": "protocol",
    "title": "Planetary/Lunar Resonances as Transfer Locks",
    "summary": "Use celestial resonance windows (p:q) for efficient transfers; schedule burns at accepted phases.",
    "defs": [
      "orbital phases Î¸_1, Î¸_2; resonance râ‰ˆp/q",
      "Î”v budget"
    ],
    "equations": [
      "accept windows where Kâ†‘ and Î”v per km/s saved â†‘",
      "Îµ_stab from resonance width"
    ],
    "audits": [
      "E3: tiny time-of-burn shifts near windows reduce Î”v vs random",
      "E4: low-order windows persist across ephemerides"
    ],
    "nulls": ["ephemeris-shuffled surrogates"],
    "steer": "Prefer 1:1, 2:1 corridors; avoid brittle higher resonances."
  }
]
[
  {
    "id": "DELTA.CTRL.PLLPhaseLock.v1",
    "type": "protocol",
    "title": "Phase-Locked Loop as Î” Controller",
    "summary": "A PLL is a concrete Fâ†’P controller: retune frequency into capture, then trim phase. Small-integer sub/superharmonic locks (p:q) generalize the loop.",
    "defs": [
      "reference phase Î¸_r, VCO phase Î¸_v, error e=wrap(p Î¸_r âˆ’ q Î¸_v)",
      "loop filter L(s), VCO gain K_v",
      "Îµ_cap from frequency detune, Îµ_stab from loop margins"
    ],
    "equations": [
      "Î¸Ì‡_v = Ï‰_free + K_v Â· (L * sin e)",
      "accept p:q if K=âŸ¨cos eâŸ© high with Îµ_stab>0 and Î¶â†“",
      "order penalty Î»(p+q)"
    ],
    "audits": [
      "E0: loop gain/margin calibration",
      "E1: stable reference/VCO phases",
      "E3: micro changes of loop gain or free-run frequency raise K inside Îµ_cap",
      "E4: low-order locks persist under sampling/coarse discretization"
    ],
    "nulls": ["randomized reference phase"],
    "steer": "Sweep frequency (F-axis) into tongue; then trim phase (P). Avoid high-order locks unless RG shows persistence."
  },
  {
    "id": "DELTA.MATH.PathIntegralPhase.v1",
    "type": "principle",
    "title": "Path Integral: Stationary-Phase Selection",
    "summary": "Sum-over-paths phases interfere; dominant contributions arise at stationary action. Use it to cull brittle fits.",
    "defs": [
      "amplitude A=âˆ« e^{i S[Î³]/Ä§} DÎ³",
      "stationary Î´S=0 paths Î³*"
    ],
    "equations": [
      "prefer locks whose phases align with Î³* across channels",
      "penalize non-stationary contributions via Î¶"
    ],
    "audits": [
      "E1: stationary sets reproducible under smoothing",
      "E3: micro action-parameter tweaks move dominance as predicted",
      "E4: selections persist under coarse sampling"
    ],
    "nulls": ["random phases with no stationary support"],
    "steer": "Gate candidates by stationary phase neighborhoods before phase forcing."
  },
  {
    "id": "DELTA.PDE.GreenResonanceLocks.v1",
    "type": "protocol",
    "title": "Greenâ€™s Functions: Resonant Integer Locks",
    "summary": "Poles/peaks in Greenâ€™s functions mark resonant modes; small-integer mode couplings give robust Î” locks.",
    "defs": [
      "L u = f, Green G, response u = G * f",
      "modal phases Î¸_k, frequencies Ï‰_k"
    ],
    "equations": [
      "accept p:q if |G(Ï‰)| peaks at Ï‰_bâ‰ˆ(p/q) Ï‰_a with high K and Îµ_stab>0",
      "Î¶ âˆ sensitivity of pole to boundary/medium perturbations"
    ],
    "audits": [
      "E1: reproducible modal peaks",
      "E3: tiny parameter nudges enhance intended peak vs neighbors",
      "E4: low-order relations persist under coarse meshes"
    ],
    "nulls": ["broadband forcing with no modal structure"],
    "steer": "Drive at nearest low-order resonance; avoid brittle overlapping peaks."
  },
  {
    "id": "DELTA.OPTIC.EikonalGeodesicPhase.v1",
    "type": "principle",
    "title": "Eikonal/Geodesic Phase for Minimal Paths",
    "summary": "Phase fronts advance along geodesics; integer ties appear where path differences are small multiples of wavelength.",
    "defs": [
      "eikonal |âˆ‡T|=1/c(x), optical path length",
      "phase Ï†=2Ï€ T/Î»"
    ],
    "equations": [
      "accept locks where Î”Ï†â‰ˆ2Ï€(p/q) with small p+q",
      "Îµ_stab âˆ curvature margin of geodesic tubes"
    ],
    "audits": [
      "E1: stable travel times under smoothing",
      "E3: micro index changes shift Ï† as predicted",
      "E4: low-order fringes persist under blur"
    ],
    "nulls": ["random phase plates"],
    "steer": "Trim refractive index/geometry to favor low-order interference."
  },
  {
    "id": "DELTA.SPECT.SlepianBandlimitGuard.v1",
    "type": "protocol",
    "title": "Slepian Prolates: Bandlimit & Leakage Guard",
    "summary": "Use DPSS/Slepian tapers to control leakage; define Îµ_cap via mainlobe and penalize Î¶ via sidelobes.",
    "defs": [
      "timeâ€“bandwidth NW, DPSS v_k",
      "mainlobe Î”Ï‰_main, sidelobe L_side"
    ],
    "equations": [
      "Îµ_capâ‰ˆÎ”Ï‰_main(NW); Î¶ âˆ L_side",
      "accept locks that persist across k=0,1 tapers"
    ],
    "audits": [
      "E1: measured leakage matches DPSS theory",
      "E3: within-band detunes increase K with DPSS better than rectangular",
      "E4: low-order peaks stable across tapers"
    ],
    "nulls": ["flat windows creating false peaks"],
    "steer": "Prefer DPSS at tight bands; widen NW if detune exceeds Îµ_cap."
  },
  {
    "id": "DELTA.CS.HarmonicLasso.v1",
    "type": "protocol",
    "title": "Compressed Sensing with Harmonic/Integer Priors",
    "summary": "Sparse recovery with penalties that favor harmonic stacks and small-integer ratios.",
    "defs": [
      "y=Î¦x, x sparse in harmonic dictionary D",
      "integer tie set T between atoms"
    ],
    "equations": [
      "min_x â€–yâˆ’Î¦Dxâ€–_2^2 + Î¼â€–xâ€–_1 + Î» Î£_{(i,j)âˆˆT} (p+q)",
      "accept if MDL gain > 0 and Î¶â†“"
    ],
    "audits": [
      "E3: adding integer penalties improves OOS error with same sparsity",
      "E4: accepted ties persist under pooling"
    ],
    "nulls": ["randomized dictionaries"],
    "steer": "Seed T with continued-fraction convergents; prune brittle ties."
  },
  {
    "id": "DELTA.TIME.SARIMAIntegerSeasonality.v1",
    "type": "protocol",
    "title": "SARIMA with Integer Seasonality Guards",
    "summary": "Seasonal ARIMA models get Î” priors on seasonal periods and their small-integer harmonics.",
    "defs": [
      "SARIMA(p,d,q)Ã—(P,D,Q)_s",
      "candidate s from low-order clocks"
    ],
    "equations": [
      "prior(s) âˆ exp(âˆ’Î» order(s)); accept s with Kâ†‘ and Î¶â†“",
      "demote high-order s that fail RG"
    ],
    "audits": [
      "E3: small retimes of seasonality improve forecast error vs random",
      "E4: chosen s persists under aggregation"
    ],
    "nulls": ["label shuffles of seasons"],
    "steer": "Scan sâˆˆ{7,12,24,30,â€¦}; confirm with ACF/PACF and low-order locks."
  },
  {
    "id": "DELTA.HELM.CavityIntegerModes.v1",
    "type": "principle",
    "title": "Helmholtz Cavity: Integer Mode Geometry",
    "summary": "Cavity modes carry integer indices; favor low-order couplings between modes and drives for robust patterns.",
    "defs": [
      "Helmholtz âˆ‡Â²u + kÂ² u=0 with BCs",
      "mode indices (m,n,â„“)"
    ],
    "equations": [
      "accept couplings where frequency ratios â‰ˆ p:q small",
      "Îµ_stab from Q factors and mode spacing"
    ],
    "audits": [
      "E1: stable modal map",
      "E3: tiny geometry/drive tweaks amplify intended mode",
      "E4: low-order couplings persist under mesh coarsening"
    ],
    "nulls": ["broadband excitation with no modal isolation"],
    "steer": "Shape cavities/drives to isolate low-order families."
  },
  {
    "id": "DELTA.SPH.SphericalHarmonicsLowOrder.v1",
    "type": "principle",
    "title": "Spherical Harmonics: Low-Order Preference",
    "summary": "On spheres, low â„“,m harmonics give robust, RG-persistent structure; high orders are brittle.",
    "defs": [
      "Y_â„“^m(Î¸,Ï†), degrees â„“, orders m"
    ],
    "equations": [
      "penalize â„“+|m|; accept integer ties among components if Kâ†‘",
      "Îµ_stab from spectral gap"
    ],
    "audits": [
      "E1: stable coefficients under smoothing",
      "E3: minimal filtering enhances low â„“,m without artifacts",
      "E4: low-order ranks persist under downsample"
    ],
    "nulls": ["random spherical noise"],
    "steer": "Compress onto small â„“,m; annotate small-integer couplings only."
  },
  {
    "id": "DELTA.OT.PhaseOTAlignment.v1",
    "type": "protocol",
    "title": "Optimal Transport for Phase Alignment",
    "summary": "Align phase histograms via OT; accept alignments that reveal low-order coincident structure and reduce Î¶.",
    "defs": [
      "distributions Î¼,Î½ on circle; cost c(Î¸,Ï†)",
      "OT plan Ï€*"
    ],
    "equations": [
      "add Î”-penalty favoring maps with p:q periodicity",
      "accept plan if Kâ†‘ and MDL gain > 0"
    ],
    "audits": [
      "E3: tiny cost tilts toward low-order maps improve K",
      "E4: alignments persist under pooling"
    ],
    "nulls": ["shuffled histograms"],
    "steer": "Regularize toward small rotations and low-order wrap maps."
  },
  {
    "id": "DELTA.EXP.BayesDesignDelta.v1",
    "type": "protocol",
    "title": "Bayesian Experimental Design with Î” Scores",
    "summary": "Choose interventions maximizing expected Î”H* and information gain under low-order priors.",
    "defs": [
      "utility U = E[Î”H*] + w_I E[IG] âˆ’ Î»(p+q) âˆ’ Î²' Î¶",
      "design variables d (timing, frequency, amplitude, rest)"
    ]
    ,
    "equations": [
      "d* = argmax_d U(d)",
      "simulate E3 micro-nudges to estimate U"
    ],
    "audits": [
      "E0: simulator validated on calibration tasks",
      "E3: chosen d beats random designs",
      "E4: preference stable under pooling"
    ],
    "nulls": ["uninformative designs that donâ€™t move posteriors"],
    "steer": "Enumerate low-order timings first; allocate budgets where Î”H*/bit is highest."
  },
  {
    "id": "DELTA.NEUR.CircadianChronoLock.v1",
    "type": "protocol",
    "title": "Chronotherapy via Low-Order Circadian Locks",
    "summary": "Schedule light/meal/exercise at low-order phases vs circadian clock to shift and stabilize rhythms with minimal input.",
    "defs": [
      "circadian phase Î¸_c, zeitgeber phase Î¸_z",
      "PRC Z(Î¸) for stimulus"
    ],
    "equations": [
      "Î”_{p:q}=p Î¸_z âˆ’ q Î¸_c; accept 1:1 or 2:1 if Kâ†‘ and Î¶â†“",
      "use PRC to time minimal stimuli at max |Z|"
    ],
    "audits": [
      "E1: stable phase estimation (e.g., DLMO proxies)",
      "E3: timed stimuli shift phase/coherence more than random",
      "E4: locks persist across days"
    ],
    "nulls": ["shuffled schedules"],
    "steer": "Apply smallest effective stimuli near accepted phases; avoid off-phase forcing."
  },
  {
    "id": "DELTA.VIZ.ColormapPhaseIntegrity.v1",
    "type": "principle",
    "title": "Visualization: Preserve Phase Topology",
    "summary": "Colormaps and projections must preserve cyclic order and low-order relations; violations increase Î¶ and mislead.",
    "defs": [
      "phase-preserving map Ï†â†’color",
      "monotonic lightness around circle"
    ],
    "equations": [
      "penalize hue jumps that break U(1) continuity",
      "accept visualizations that increase PLI without distorting phase"
    ],
    "audits": [
      "E1: check monotonicity and continuity",
      "E4: rankings of locks stable across colormap choices"
    ],
    "nulls": ["rainbow maps that fold phase"],
    "steer": "Use cyclic colormaps; annotate low-order landings explicitly."
  },
  {
    "id": "DELTA.ROB.AbnormDetectorRG.v1",
    "type": "protocol",
    "title": "Anomaly Detection via RG-Persistent Deviations",
    "summary": "Call anomalies only when deviations survive bootstraps and coarse-graining; prefer low-order explanations first.",
    "defs": [
      "baseline S* distribution under ğ’¢",
      "RG slopes across coarse factors"
    ],
    "equations": [
      "flag anomaly if S* tail + RG persistence + failure of low-order models",
      "demote if explanation via small p:q emerges"
    ],
    "audits": [
      "E4: anomaly persists under pooling/blur",
      "E3: micro-nudges donâ€™t reconcile deviation with low-order model"
    ],
    "nulls": ["single-scale outliers only"],
    "steer": "Seek smallest structural fix; escalate only after RG/boot checks."
  }
]
[
  {
    "id": "DELTA.MATH.EulerLagrangeLocking.v1",
    "type": "principle",
    "title": "Eulerâ€“Lagrange as Phase-Stationarity Gate",
    "summary": "Locks correspond to extremals of a Î”-enhanced action; prefer low-order integer constraints embedded as soft terms.",
    "defs": [
      "action S[q]=âˆ« L(q, qÌ‡, t) dt",
      "integer constraints via penalties Î»(p+q), detune Î³ Î´^2"
    ],
    "equations": [
      "d/dt(âˆ‚L/âˆ‚qÌ‡) âˆ’ âˆ‚L/âˆ‚q = âˆ’âˆ‚/âˆ‚q [Î»(p+q)+Î³ Î´^2 âˆ’ w_K|K| + w_Î¶ Î¶]",
      "accept solutions where Îµ_cap>0, Îµ_stab>0, Î¶â‰¤Î¶_max"
    ],
    "audits": [
      "E1: stable phase extraction along extremals",
      "E3: tiny parameter nudges reduce augmented action and raise Î”H*",
      "E4: extremal structure persists under coarse-grain"
    ],
    "nulls": ["extrema that vanish after removing integer penalties"],
    "steer": "Embed the smallest integer penalties; verify monotone Î”H* before promotion."
  },
  {
    "id": "DELTA.SYM.NoetherConservationClassic.v1",
    "type": "principle",
    "title": "Noether: Symmetry â†’ Conservation (Classical Form)",
    "summary": "Continuous symmetries imply conserved quantities; certify Î” locks by associated invariants (energy, momentum, action-phase).",
    "defs": [
      "symmetry group G, generator Î¾",
      "Noether charge Q_Î¾ conserved along solutions"
    ],
    "equations": [
      "dQ_Î¾/dt = 0 under symmetry; promote locks tied to conserved Q_Î¾",
      "penalize models with unregistered symmetry breaks"
    ],
    "audits": [
      "E2: verify symmetry transformations leave equations invariant",
      "E4: conservation holds under smoothing/coarse models"
    ],
    "nulls": ["illusory invariants broken by gauge choice"],
    "steer": "Prefer locks backed by conserved charges (RG-stable); demote others."
  },
  {
    "id": "DELTA.DYN.KAMRobustness.v1",
    "type": "principle",
    "title": "KAM Persistence & Small-Integer Resonances",
    "summary": "Tori with Diophantine (irrational) ratios persist; near small rationals, tongues formâ€”our capture windows.",
    "defs": [
      "frequency ratio r=Ï‰_b/Ï‰_a",
      "Diophantine vs rational p/q"
    ],
    "equations": [
      "Îµ_cap grows near râ‰ˆp/q with small p+q; tori break into resonant islands",
      "prefer lowest-order islands; penalize brittle higher chains"
    ],
    "audits": [
      "E1: stable frequency estimates across windows",
      "E3: tiny detunes move system along predicted islands (Kâ†‘)",
      "E4: low-order islands persist under coarse sampling"
    ],
    "nulls": ["spurious islands from aliasing (fail resampling tests)"],
    "steer": "Target first resonant islands; avoid high-order chains unless RG passes."
  },
  {
    "id": "DELTA.DYN.PoincareResonanceWeb.v1",
    "type": "protocol",
    "title": "PoincarÃ© Map & Resonance Web Detection",
    "summary": "Build PoincarÃ© sections; test for low-order resonant polygons (p:q) as Î” lock candidates.",
    "defs": [
      "section Î£, return map P:Î£â†’Î£",
      "phase angle on Î£, winding numbers"
    ],
    "equations": [
      "identify p-cycles; score with K and penalize p+q",
      "Îµ_stab from return-map eigenvalues"
    ],
    "audits": [
      "E1: polygons repeat across windows",
      "E3: micro parameter nudges stabilize target polygon vs controls",
      "E4: low-order polygons persist under coarse binning"
    ],
    "nulls": ["randomized crossings destroying polygons"],
    "steer": "Snap to smallest stable polygons; break high-order chains first."
  },
  {
    "id": "DELTA.DYN.LyapunovTongueMap.v1",
    "type": "protocol",
    "title": "Lyapunov Exponents vs Capture Tongues",
    "summary": "Map Î»_max across parameters; accept regions where low-order tongues lower chaos (Î»_maxâ†“) with Kâ†‘.",
    "defs": [
      "Î»_max (largest Lyapunov exponent)",
      "tongue labels p:q"
    ],
    "equations": [
      "accept (Kâ†‘, Î»_maxâ†“, Îµ_stab>0) near p:q",
      "reject locks with Î»_maxâ†‘ unless Î”H* payoff justifies"
    ],
    "audits": [
      "E1: Î»_max estimation stable",
      "E3: micro detune shifts Î»_max as predicted",
      "E4: tongue ranking persists under coarse sampling"
    ],
    "nulls": ["Î»_max artifacts from finite windows"],
    "steer": "Operate on tongues that reduce Î»_max with minimal steer."
  },
  {
    "id": "DELTA.STATS.MetropolisPhaseSampler.v1",
    "type": "protocol",
    "title": "Phase-Aware Metropolisâ€“Hastings",
    "summary": "Sample models with integer priors on ratios; proposals respect capture bands to reduce Î¶ and speed mixing.",
    "defs": [
      "target Ï€(Î¸) âˆ L(D|Î¸) e^{âˆ’Î»(p+q)âˆ’Î³Î´^2âˆ’Î²'Î¶}",
      "proposal q(Î¸'|Î¸) nudged toward Îµ_cap"
    ],
    "equations": [
      "accept Î±=min(1, Ï€(Î¸')q(Î¸|Î¸')/Ï€(Î¸)q(Î¸'|Î¸))",
      "mixing improves when proposals align with capture ridges"
    ],
    "audits": [
      "E0: detailed-balance checks",
      "E3: phase-aware proposals reduce IAT vs random",
      "E4: posterior preference for low order persists under pooling"
    ],
    "nulls": ["phase-agnostic proposals (slow IAT, higher Î¶)"],
    "steer": "Propose along low-order valleys; temper if stuck near brittle peaks."
  },
  {
    "id": "DELTA.VI.VariationalIntegerPriors.v1",
    "type": "protocol",
    "title": "Variational Inference with Integer Priors",
    "summary": "Use priors that bias toward small p:q in latent dynamics; ELBO gains must coincide with Kâ†‘ and Î¶â†“.",
    "defs": [
      "ELBO = E_q[log p] âˆ’ E_q[log q]",
      "latent phases/ratios with prior âˆ e^{âˆ’Î»(p+q)}"
    ],
    "equations": [
      "maximize ELBO âˆ’ Î»(p+q) âˆ’ Î³Î´^2 âˆ’ Î²'Î¶",
      "accept only if OOS Î”H* improves"
    ],
    "audits": [
      "E3: integer priors improve ELBO and OOS without Î¶â†‘",
      "E4: learned low-order persists under new data"
    ],
    "nulls": ["ELBO gains that vanish OOS"],
    "steer": "Start with convergent candidates; expand cautiously."
  },
  {
    "id": "DELTA.INFO.ChannelCapacityPhase.v1",
    "type": "principle",
    "title": "Channel Capacity with Phase-Lock Gain",
    "summary": "Phase-locked coding raises mutual information; capacity gains must persist under noise and coarse-grain.",
    "defs": [
      "capacity C= max_{p(x)} I(X;Y)",
      "phase-coded alphabets with low-order rhythms"
    ],
    "equations": [
      "Î”C â‰ˆ w_MI Î”I from accepted locks; penalize Î¶",
      "accept if BERâ†“ and I(X;Y)â†‘ vs baseline"
    ],
    "audits": [
      "E1: MI/BER calibration",
      "E3: timing/phase micro-edits at accepted phases increase I",
      "E4: gains persist across SNR levels"
    ],
    "nulls": ["gains that vanish under interleaving/scramble"],
    "steer": "Align symbol/carrier/clock at small ratios; avoid high-order constellations."
  },
  {
    "id": "DELTA.STOC.MarkovEntropyRate.v1",
    "type": "principle",
    "title": "Markov Chains: Entropy Rate & Phase Structure",
    "summary": "Low-order cycles reduce entropy rate by adding predictability; certify only if RG-stable.",
    "defs": [
      "entropy rate h=âˆ’âˆ‘_i Ï€_i âˆ‘_j P_{ij} log P_{ij}",
      "phase-coded transitions"
    ],
    "equations": [
      "accept lock if hâ†“ with Kâ†‘ and Î¶â†“",
      "reject if change localizes to high-order micro-cycles"
    ],
    "audits": [
      "E3: phase-scheduled tweaks reduce h vs random",
      "E4: h reductions persist under aggregation"
    ],
    "nulls": ["apparent h changes from sampling artifacts"],
    "steer": "Bias transitions to reinforce small cycles; keep Î¶ low."
  },
  {
    "id": "DELTA.CHEM.BZOscillatorLocks.v1",
    "type": "protocol",
    "title": "Belousovâ€“Zhabotinsky Phase Locks",
    "summary": "Chemical oscillators synchronize at small p:q under coupling/light; treat waves as phase fields with capture/stability.",
    "defs": [
      "local phase Î¸(x,t) from colorimetric trace",
      "coupling via diffusion/light feedback"
    ],
    "equations": [
      "K_{p:q}=âŸ¨cos(p Î¸_j âˆ’ q Î¸_i)âŸ© e^{âˆ’Î»(p+q)} e^{âˆ’Î³ detune}",
      "Îµ_stab âˆ dispersion margin"
    ],
    "audits": [
      "E1: stable oscillation bands",
      "E3: tiny light/coupling nudges raise K near small p:q",
      "E4: locks persist under downsample"
    ],
    "nulls": ["shuffled pixel phases"],
    "steer": "Tune coupling to first tongues; insert spatial rests to reduce Î¶."
  },
  {
    "id": "DELTA.MUSIC.TuningTemperamentDelta.v1",
    "type": "protocol",
    "title": "Tuning/Temperament with Î” Priors",
    "summary": "Favor low-integer harmonic fits (just intonation edges) while balancing keyboard constraints; report Î¶ for tempering.",
    "defs": [
      "target ratios (3:2, 5:4, 6:5, â€¦), equal-tempered bins",
      "temperament deviation Î”cents"
    ],
    "equations": [
      "score = âˆ’Î£ w_r |Î”cents(r)| + w_K Î£|K_r| âˆ’ Î» order",
      "accept tuning if Î”H*â†‘ and Î¶ (beat instability)â†“"
    ],
    "audits": [
      "E3: micro cents tweaks improve consonance metrics vs sham",
      "E4: low-order intervals remain stable across transpositions"
    ],
    "nulls": ["random detunes with matched variance"],
    "steer": "Optimize small-integer set; allow minimal compromises where RG demands."
  },
  {
    "id": "DELTA.GRAPH.SpectralSyncLowOrder.v1",
    "type": "protocol",
    "title": "Spectral Graph Sync with Integer Motifs",
    "summary": "Use Laplacian/Fiedler phases to cluster; accept cross-cluster small p:q locks only with RG persistence.",
    "defs": [
      "Laplacian eigenpairs (Î»_k, Ï†_k)",
      "community phases from Ï†_k"
    ],
    "equations": [
      "accept p:q between community phases if Kâ†‘ and Î¶â†“",
      "Îµ_stab âˆ spectral gap"
    ],
    "audits": [
      "E1: stable eigenmaps under small perturbations",
      "E3: micro edge edits improve K and lower Î¶",
      "E4: motifs persist under graph coarsening"
    ],
    "nulls": ["eigenvectors from randomized graphs"],
    "steer": "Leverage low-order ties across communities; bridge frustration minimally."
  },
  {
    "id": "DELTA.SDE.KramersEscapePhase.v1",
    "type": "protocol",
    "title": "Kramers Escape & Phase-Timed Kicks",
    "summary": "Time minimal kicks at phases that align with barrier escape; noise used as Îµ_cap booster within Î¶ guardrails.",
    "defs": [
      "escape rate r âˆ e^{âˆ’Î”E/D}",
      "phase Î¸(t) on limit cycle"
    ],
    "equations": [
      "time kicks at Î¸ maximizing PRC and near low-order alignments to exogenous clocks",
      "accept if escape probabilityâ†‘ with minimal energy"
    ],
    "audits": [
      "E3: predicted timing beats random at equal energy",
      "E4: advantage persists under coarse data"
    ],
    "nulls": ["kicks off-phase (no advantage)"],
    "steer": "Inject minimal noise/kicks near landings; stop when Î¶ rises."
  },
  {
    "id": "DELTA.OPT.AugLagPhaseConstraints.v1",
    "type": "protocol",
    "title": "Augmented Lagrangian with Phase Constraints",
    "summary": "Solve tasks with equality of phases/ratios via augmented Lagrangian; promotes exact low-order constraints when robust.",
    "defs": [
      "constraints c(Î¸)=0 for Î”_{p:q}â‰ˆ0",
      "augmented L: L_Ï = f + Î»^T c + (Ï/2)||c||^2"
    ],
    "equations": [
      "increase Ï only when Îµ_stab>0 and Î¶ stays low",
      "accept solution if Kâ†‘ and residuals fall"
    ],
    "audits": [
      "E3: small updates reduce c and raise Î”H*",
      "E4: constraints hold under coarse/resampled data"
    ],
    "nulls": ["hard constraints that fail under noise"],
    "steer": "Tighten constraints gradually; back off if Î¶ spikes."
  },
  {
    "id": "DELTA.NLP.RhythmGrammarLocks.v1",
    "type": "protocol",
    "title": "Rhythm Grammars with Integer Prosody",
    "summary": "Annotate text/audio with prosodic clocks; accept low-order syntaxâ€“prosody locks that raise intelligibility and recall.",
    "defs": [
      "syllable/phrase clocks; syntactic boundaries",
      "Î”H*: MOS/recall/RT gains"
    ],
    "equations": [
      "accept p:q if timing near boundaries boosts metrics with Îµ_stab>0",
      "penalize high-order schemes"
    ],
    "audits": [
      "E3: micro timing near accepted phases boosts human/ASR metrics",
      "E4: locks persist across speakers/domains"
    ],
    "nulls": ["boundary shuffles"],
    "steer": "Schedule pauses/emphasis at landings; prune brittle schemes."
  }
]
[
  {
    "id": "DELTA.HEP.TriadMassMDL.v1",
    "type": "protocol",
    "title": "Three Generations as Triadic Harmony (MDL Fit on Masses & Mixings)",
    "summary": "Tests whether the 3 fermion generations reflect a low-order (triadic) scaffold that shortens code length for masses and mixings, versus smooth baselines. Accept only if the small-integer scaffold wins on MDL and survives RG-style coarse-grain.",
    "defs": [
      "charged-lepton masses: m_e, m_Î¼, m_Ï„",
      "quark masses in a fixed renormalization scheme (state scheme & scale)",
      "mixing matrices: CKM (quarks), PMNS (leptons) with rephasing-invariant angles/phases",
      "continued-fraction (CF) convergents for a base ratio Ï; order cost = CF length or p+q"
    ],
    "equations": [
      "Mass scaffold:  ln m_i â‰ˆ a + b Â· n_i  with n_i âˆˆ {0,1,3} + small detunes",
      "Generalized scaffold: minimize  J_mass = Î£_i | ln(m_i/m_0) âˆ’ Î±_i | + Î» Â· order(Î±_i)",
      "Mixing lock score:  K_{p:q} = âŸ¨ cos(p Î¸_b âˆ’ q Î¸_a) âŸ© Â· e^{âˆ’Î»(p+q)} Â· e^{âˆ’Î³ Î´},  with Î¸ from rephasing-invariant angles",
      "Total objective:  J_total = J_mass + w_mix Î£ locks (Î»(p+q) + Î³ Î´ âˆ’ |K|) + w_Î¶ Î¶"
    ],
    "audits": [
      "E0: Units/scheme hygiene. Freeze renormalization scheme & scale; document uncertainties.",
      "E2: Rephasing/gauge invariance: results unchanged under allowed field rephasings.",
      "E3: Bootstrap refits (resampling masses within errors) preserve order ranking; small-perturb CF priors keep MDL advantage.",
      "E4: Coarse-grain tests (remove one datum per family; smooth over scheme variants) preserve low-order superiority; high-order fits thin first."
    ],
    "nulls": [
      "Smooth baselines: pure power-law or log-linear fits with equal parameter count.",
      "Label-shuffled masses or randomized mixing angles preserving marginal distributions."
    ],
    "steer": "Scan CF convergents first; accept the smallest-order scaffold that beats smooth baselines on MDL with Î¶ not rising. Demote immediately if order advantage flips under E3/E4.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.QCD.ColorHstarConfinement.v1",
    "type": "principle",
    "title": "Quark Confinement as Color Coherence (Singlets Maximize H*)",
    "summary": "Color-singlet combinations maximize a harmony objective and minimize brittleness; colored states carry high Î¶ (string tension/area-law cost). Treat color neutrality as the H* optimum under admissible SU(3) transforms.",
    "defs": [
      "SU(3) reps: 3, 3Ì„, 8, ...; singlet projectors Î _singlet",
      "Wilson loop string tension Ïƒ as brittleness proxy Î¶",
      "configuration set ğ“’ over quark color couplings"
    ],
    "equations": [
      "H* = Î£_{ğ“’} w_ğ“’ Â· Tr[ Î _singlet(ğ“’) ] âˆ’ Î² Â· Î¶(ğ“’)",
      "Î¶ âˆ Ïƒ Â· â„“_flux  (flux-tube length or area-law scale)",
      "Decision: accept singlet if Î”J = âˆ’Î”H* + w_Î¶ Î”Î¶ < 0 vs nearest colored alternative at same content"
    ],
    "audits": [
      "E1: Stable Wilson-loop plateaus and string-tension extraction.",
      "E3: Add minimal bridge (e.g., bring in a 3Ì„ to a 3) â†’ Î¶â†“ and H*â†‘ versus sham additions.",
      "E4: Singlet advantage survives lattice smearing, blocking, and coarser grids; colored benefits vanish first."
    ],
    "nulls": [
      "Non-singlet source trials with matched separation/energy budget.",
      "Random color assignments breaking SU(3) coupling rules."
    ],
    "steer": "When colored sources are present, add the minimal complementary rep to form Î _singlet; if Î¶ fails to drop or H* fails to rise under that bridge, demote the claim.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.QFT.ForcesAdmissibleTransforms.v1",
    "type": "principle",
    "title": "Forces as Steer Under Gauge Admissible Transforms; Vertices as Truth Triangulations",
    "summary": "Treat U(1), SU(2), SU(3) as admissible transforms. A â€˜forceâ€™ is the controllerâ€™s steer to correct local gauge mislocks. Interaction vertices enforce integer conservation (charges/weights) as Truth-Triangulation constraints.",
    "defs": [
      "Local gauge phase fields Î¸(x) for each group; connection fields as controllers",
      "Vertex integer constraints: charge, color weight, weak isospin/hypercharge",
      "Lock error e_Ï† = wrap(p Î¸_b âˆ’ q Î¸_a)"
    ],
    "equations": [
      "Î” objective:  J = Î»(p+q) + Î³ Î´^2 âˆ’ w_K |K| + w_Î¶ Î¶,  with K = âŸ¨cos e_Ï†âŸ©",
      "Controller flow (Î©*): correct frequency/gradient (eligibility) â†’ trim phase; one Snap per axis per window",
      "Vertex acceptance: only interactions that reduce J given integer conservation and admissible symmetry"
    ],
    "audits": [
      "E2: Ward/Takahashi/Slavnovâ€“Taylor identities hold (symmetry hygiene).",
      "E3: In toy lattice/continuum models, inject small local phase defect; gauge controller reduces J on-manifold, not off.",
      "E4: Integer conservation and identity structure persist across renormalization schemes (scheme-invariant statements)."
    ],
    "nulls": [
      "Gauge-broken regulators not repaired by counterterms (fail invariance).",
      "Randomized vertex labels that violate integer constraints."
    ],
    "steer": "Prefer the minimal set of admissible corrections restoring lock with smallest (p+q). If a symmetry-breaking deformation lowers J without added Î¶ or parameters, reject the thesis (kill-switch).",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.EFT.RGIntegerThinning.v1",
    "type": "principle",
    "title": "RG Flow as Integer Thinning: Low Order Wins, High Order Dies",
    "summary": "Operator relevance decays with increasing order and detune under coarse-graining; only low-order (renormalizable) structures persist. Quantify with Î”-style relevance curves and require RG persistence.",
    "defs": [
      "Operators ğ’ª_i with scaling dimensions Î”_i and effective lock strength K_i",
      "Coarse-grain scale â„“ (log Î¼); relevance slope vs order (p+q)"
    ],
    "equations": [
      "dK_i/dâ„“ = (2 âˆ’ Î”_i) K_i âˆ’ Î› K_i^3 + â€¦ , with Î”_i = d + Î· Â· order + Î¶ Â· detune",
      "Prediction: normalized log|K_i| decreases with order after detune control (integer thinning)."
    ],
    "audits": [
      "E4 only (RG): Compare relevance curves under Ã—2 coarse-grain; low-order decay slowest; high-order thins first.",
      "Model-selection MDL: prefer truncations where removing high-order terms improves OOS while preserving low-order fits."
    ],
    "nulls": [
      "Shuffled operator labels; overfit EFTs that invert slope under coarse-grain."
    ],
    "steer": "Keep the smallest operator set with stable low-order relevance. Demote any model where high-order operators show stronger persistence than low-order after normalization.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.STRING.LandingsMDL.v1",
    "type": "protocol",
    "title": "Strings as A1 Vibration; Landscape as Low-Order Harmonic Landings",
    "summary": "Score candidate string vacua/compactifications by integer simplicity, stability, and modular/gauge hygiene. Prefer vacua with fewer integers that still reproduce observed spectra/forces; penalize brittle flux/branes with high Î¶.",
    "defs": [
      "Topological integers: flux quanta, Chern numbers, brane wrappings",
      "Modular/anomaly penalties Î“_mod; stability metrics (moduli masses, barrier heights)",
      "IR match metrics: spectra, couplings, anomalies canceled"
    ],
    "equations": [
      "Landing score:  L = Î» Î£ (p+q)  + Î“_mod  + w_Î¶ Î¶  âˆ’ w_K |K|",
      "Acceptance: lower L at fixed IR match is preferred; RG persistence: spectrum & charges remain stable under small moduli deformations."
    ],
    "audits": [
      "E2: Modular/gauge invariance satisfied; anomalies canceled.",
      "E3: Tiny, admissible deformations (moduli shifts) should not increase Î¶ nor break IR matches for accepted low-order vacua; off-manifold deformations degrade.",
      "E4: Low-order vacua retain spectrum/integers under coarse discretization/approximation; high-order clutter demotes first."
    ],
    "nulls": [
      "High-integer vacua with no stability gain; randomized integer assignments that only increase parameter count."
    ],
    "steer": "Minimize integer inventory subject to IR receipts; if extra integers do not buy Î¶â†“ or IR fidelityâ†‘, cut them. Promote only vacua with demonstrable RG stability.",
    "version": "1.0",
    "updated": "2025-10-07"
  }
]
[
  {
    "id": "DELTA.HOLO.AdsCftSCompression.v1",
    "type": "principle",
    "title": "Holography as S-Compression; AdS/CFT as Truth Triangulation",
    "summary": "Treat the boundary theory as the compressed description (S-Compression) and bulk geometry as the decoded rendering. AdSâ†”CFT is a Delta Truth-Triangulation: two minimal codes describing the same invariants; locality/unitarity emerge when both codes agree after RG.",
    "defs": [
      "Boundary code B (CFT data, e.g., correlators, OPE coefficients)",
      "Bulk code U (geometric data: metric, geodesic lengths, areas)",
      "Compression score S_c: bits to encode predictive invariants",
      "Î” fields: Îµ_cap (eligibility), Îµ_stab (stability), Î¶ (brittleness), MDL penalty Î»(p+q)"
    ],
    "equations": [
      "S_c(B) â‰¤ S_c(U) on boundary-accessible queries; S_c(U) â‰¤ S_c(B) on bulk-geometric queries",
      "Triangulation gain: T = (IG_Bâ†’U + IG_Uâ†’B) âˆ’ Î» Î£(p+q) âˆ’ w_Î¶ Î¶",
      "Accept holographic dual if T > 0 and both sides pass RG (low-order invariants persist under coarse-grain)"
    ],
    "audits": [
      "E2: Gauge/conformal invariance hygiene on both codes",
      "E3: Tiny boundary-side nudges (operator deformations) predict bulk geodesic/area shifts quantitatively; off-manifold perturbations do not improve T",
      "E4: Low-order bulkâ€“boundary correspondences (two/three-point structures, minimal surfaces) persist under coarse-grain; high-order decorations thin first"
    ],
    "nulls": [
      "Boundary datasets scrambled in phases or OPE labels (no consistent bulk decode)",
      "Bulk surrogates with randomized geodesic networks (fail to predict boundary correlations)"
    ],
    "steer": "Prefer the boundary code when S_c(B) â‰ª S_c(U) for a query class; prefer bulk when geometric queries dominate. Promote correspondences that reduce total code length and Î¶.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.COSMO.CCCContrastReset.v1",
    "type": "principle",
    "title": "Conformal Cyclic Cosmology as Î”â‚€ Contrast Restoration",
    "summary": "Model the end-of-aeon as Kâ†’0 (structure erased) and a conformal rescale that restores Î”â‚€ contrast (scale-free seeds). Only scale-invariant low-order invariants pass to the next aeon.",
    "defs": [
      "Order parameter K (structured coherence), entropy S, scale factor a(t)",
      "Conformal map g_{Î¼Î½} â†’ Î©^2 g_{Î¼Î½}, Î© chosen to collapse size",
      "Invariant set I_*: scale-invariant quantities (angles, conformal classes)"
    ],
    "equations": [
      "lim_{tâ†’âˆ} K(t) â†’ 0,  SÌ‡ â‰¥ 0",
      "Reset: (I_* next aeon) = Conformal(I_* prev aeon)",
      "Î” acceptance: next-aeon low-order structure must derive from I_* with MDL gain vs arbitrary seeds"
    ],
    "audits": [
      "E2: Conformal invariance hygiene (claims independent of Î© gauge)",
      "E3: In toy cosmologies, increasing smoothing toward Kâ†’0 while preserving I_* yields predicted early-time spectra/features; sham conformal maps fail",
      "E4: Scale-invariant features persist under additional coarse-graining; non-invariants die off"
    ],
    "nulls": [
      "Seed sets not tied to I_* (randomized angles) producing equivalent or better fits (kills CCC mapping)"
    ],
    "steer": "Use only I_* to seed initial conditions; demote any structure that depends on absolute scale data that should have been erased.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.AMP.AmplituhedronHarmony.v1",
    "type": "protocol",
    "title": "Amplituhedron as Harmonic Intersection Geometry",
    "summary": "Interpret scattering as selecting points/volumes in a positive geometry where locality/unitarity emerge from low-order facet intersections. Î” accepts intersection patterns that minimize code length while maximizing predictive harmony.",
    "defs": [
      "Positive geometry G (kinematic/Grassmannian space)",
      "Cells/facets labeled by small integer combinatorics",
      "Harmony H*: legibility/consistency of factorization & unitary cuts",
      "Î” penalties: Î»(p+q) over combinatorial order; Î¶ for fragile cells"
    ],
    "equations": [
      "Score: J = Î» Î£ order(cell) âˆ’ w_H H* âˆ’ w_F (correct factorization) âˆ’ w_U (unitarity cuts) + w_Î¶ Î¶",
      "Accept if Î”J < 0 vs Feynman-sum baseline and RG keeps small-order cells dominant"
    ],
    "audits": [
      "E2: Projective/positivity invariance checks",
      "E3: Tiny kinematic deformations move the selected cell volume and improve factorization/uncitarity matches predictably; off-manifold deformations do not",
      "E4: Low-order cells (minimal combinatorics) remain under coarse kinematic binning; high-order tessellation dies first"
    ],
    "nulls": [
      "Random tessellations preserving volume but breaking factorization/unitarity",
      "Cell label shuffles destroying small-integer structure"
    ],
    "steer": "Prefer minimal cells/facets that satisfy cuts; prune high-order triangulations that add Î¶ without predictive gain.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.LQG.SpinNetworkKnowledgeGraph.v1",
    "type": "protocol",
    "title": "LQG Spin Networks as Knowledge Graph of Locks",
    "summary": "Treat spin labels as integers on edges/nodes; singlet intertwiners are admissible Î” locks. Spin-foam evolution is PADâ†’ACI: potentials on graphs actualize when capture/stability pass.",
    "defs": [
      "Spin network Î“ with edge reps jâˆˆ{0,1/2,1,â€¦}, intertwiners at nodes",
      "Potential Î (state) from small-integer labels and gauge constraints",
      "Actualization ğ’œ=1 when Îµ_cap>0, Îµ_stab>0, Î¶â‰¤Î¶_max",
      "ACI: quality-weighted sum of actualized low-order structures"
    ],
    "equations": [
      "Î  âˆ exp[âˆ’Î» Î£ (labels order)] Â· 1{gauge/closure satisfied}",
      "Îµ_stab âˆ gap of Gauss/closure constraints; Î¶ from sensitivity to label perturbations",
      "ACI = Î£ actualized cells (|K|+Î²Î“âˆ’Î²'Î¶) with order weights"
    ],
    "audits": [
      "E2: SU(2) gauge/closure hygiene at nodes",
      "E3: Tiny label changes that move toward admissible intertwiners increase ACI vs sham",
      "E4: Low-order label patterns persist under coarse-graining (graph contraction); high-order decorations die"
    ],
    "nulls": [
      "Graphs with randomized labels breaking closure",
      "Spin foams that pass amplitude checks but fail RG (non-persistent high-order labels)"
    ],
    "steer": "Favor minimal intertwiners and small j patterns that stabilize ACI; demote brittle, intricate labelings without RG support.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.CONSC.OrchOR_PAD.v1",
    "type": "protocol",
    "title": "Orchestrated Objective Reduction as PADâ†’Actualization in Neural Substrates",
    "summary": "Map Orch-OR to Î” Potentialâ†’Actualization Dual: microtubule quantum states carry Î  (potential); objective reduction is ğ’œ=1 when capture/stability/brittleness criteria cross threshold; conscious â€˜momentsâ€™ accumulate into ACI.",
    "defs": [
      "Î : prior favoring small-integer phase structure across microtubule lattices",
      "Îµ_cap from coherence time/quality; Îµ_stab from decoherence gap; Î¶ from fragility to thermal/ionic noise",
      "AI (Anticipation Index): multimodal physiological proxy linked to Î”H*"
    ],
    "equations": [
      "ğ’œ = 1{Îµ_cap>0 âˆ§ Îµ_stab>0 âˆ§ Î¶â‰¤Î¶_max âˆ§ Î”H*â†‘}",
      "ACI_conscious = Î£ moments (|K|+Î²Î“âˆ’Î²'Î¶), weighted by network integration"
    ],
    "audits": [
      "E1: Narrowband signatures correlating with proposed microtubule rhythms (if any) must be reproducible",
      "E3: Tiny, ethically minimal perturbations (timing/phase-safe sensory cues) modulate AI and predicted locks; sham cues do not",
      "E4: If substrate exists, low-order timing relations persist across coarse time bins; high-order vanishes"
    ],
    "nulls": [
      "Physically matched controls lacking phase structure",
      "Placebo perturbations at off-phases"
    ],
    "steer": "Treat as a probe hypothesis only. Promote only if PAD/ACI signatures are observed with strong nulls and RG persistence. Demote on any safety or falsification failure.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.INFO.ItFromQubit_OS.v1",
    "type": "principle",
    "title": "It from Qubit as Î”-OS: Binary Polarity, RG Garbage Collection",
    "summary": "Render â€˜It from Qubitâ€™ as an operating system whose kernel is Î”: 1/0 = actualization/potential; Î©* controller enforces low-order coherence; RG flow is garbage collection thinning high-order, irrelevant data.",
    "defs": [
      "Bits/qubits as PAD states (0 potential, 1 actualized)",
      "Î©*: controlâ€“Lyapunov flow decreasing Î” potential V",
      "GC: RG thinning rule on features by order (p+q) and detune Î´"
    ],
    "equations": [
      "Kernel: V = Î»(p+q)+Î³Î´^2 âˆ’ w_K|K| âˆ’ w_H H* + w_Î¶ Î¶;  uÌ‡ = âˆ’Mâˆ‡V + Î·",
      "GC rule: remove features with negative RG relevance slope; promote those with persistent low-order signatures"
    ],
    "audits": [
      "E2: invariance of OS primitives under gauge/relabellings of symbols",
      "E3: micro-nudges (on-manifold) reduce V and increase Î”H* across representative tasks; randomized nudges fail",
      "E4: Accepted structures remain under coarse-grain; non-structures die"
    ],
    "nulls": [
      "Pseudo-structure that vanishes under resampling or bit-scramble",
      "High-order annotations that raise Î¶ without OOS gains"
    ],
    "steer": "Allocate compute to low-order captures first; invoke GC whenever Î¶ rises or RG slope turns unfavorable. Treat â€˜Big Bang = boot()â€™ as a metaphor unless predictive receipts accrue.",
    "version": "1.0",
    "updated": "2025-10-07"
  }
]
[
  {
    "id": "DELTA.QGR.ERxEPR_Lock.v1",
    "type": "principle",
    "title": "ER=EPR as Minimal Entanglementâ€“Geometry Lock",
    "summary": "Entangled pairs (EPR) â†” wormhole connectivity (ER) as a low-order equivalence: boundary entanglement patterns map to bulk minimal surfaces when code length is reduced.",
    "defs": [
      "entanglement pattern E (pair graph, mutual infos)",
      "bulk cutset C (minimal surfaces)",
      "compression gain S_c, brittleness Î¶ (sensitivity to cut perturbations)"
    ],
    "equations": [
      "Lock score: K = corr(E, C) Â· e^{âˆ’Î»(p+q)}",
      "Accept ERâ†”EPR if Î”S_c>0 and Kâ†‘ while Î¶â†“ under boundary-preserving perturbations"
    ],
    "audits": [
      "E2: invariance under boundary gauge (relabel qubits) and bulk reparametrizations",
      "E3: tiny boundary entanglement edits predict local changes in C (on-manifold); shams do not",
      "E4: low-order Eâ€“C correspondences persist under tensor-network coarse-grain (MERA)"
    ],
    "nulls": [
      "random entanglement graphs with matched degree sequence",
      "bulk surrogates with randomized cut weights"
    ],
    "steer": "Prefer simplest entanglement motifs (Bell/GHZ clamps) that recover bulk cuts; demote higher-order patterns that raise Î¶ without extra Î”S_c."
  },
  {
    "id": "DELTA.MATH.NoncommutativeSpectralMDL.v1",
    "type": "principle",
    "title": "Noncommutative Geometry: Spectral Triples as Minimal Code",
    "summary": "Use spectral triples (A,H,D) to encode geometry; pick algebras A with the fewest integers that still reproduce spectra/phenomenology.",
    "defs": [
      "spectral triple (A,H,D), eigen-spectrum Î£(D)",
      "integer inventory ğ•€(A) (K-theory classes, reps)",
      "MDL penalty Î»|ğ•€|, brittleness Î¶ from spectrum sensitivity"
    ],
    "equations": [
      "Score: J = Î»|ğ•€(A)| + w_Î¶ Î¶ âˆ’ w_Î£ fit(Î£(D), data)",
      "Accept if Î”J<0 vs commutative baseline and RG: spectrum features persist under truncation"
    ],
    "audits": [
      "E2: gauge/module invariance checks",
      "E3: tiny algebra deformations (admissible) improve Î£ fit as predicted; random ones do not",
      "E4: low-order spectral features persist under cutoff changes"
    ],
    "nulls": [
      "algebras with inflated ğ•€ but no spectral gain",
      "randomized spectra with matched marginals"
    ],
    "steer": "Shrink ğ•€ until fit degrades; keep the smallest algebra explaining observed spectra with low Î¶."
  },
  {
    "id": "DELTA.QG.CausalSetLocks.v1",
    "type": "protocol",
    "title": "Causal Set Growth: Low-Order Partial-Order Locks",
    "summary": "Treat causal set growth rules as integer-typed locks; prefer dynamics whose order-invariants compress histories best.",
    "defs": [
      "causal set (C,â‰º), growth rule â„›",
      "order invariants: layer sizes, antichains, k-chains",
      "MDL: L(history|â„›), brittleness Î¶ from sensitivity to sprinkling density"
    ],
    "equations": [
      "Accept â„› if Lâ†“ and K(order invariants)â†‘ with Î¶ not â†‘",
      "Eligibility Îµ_cap from match between observed invariants and â„›â€™s predicted distribution"
    ],
    "audits": [
      "E2: label/gauge invariance (poset isomorphisms)",
      "E3: tiny rate/attachment tweaks shift invariants as predicted; shams donâ€™t",
      "E4: low-order invariants persist under coarse thinning of elements"
    ],
    "nulls": [
      "ER random posets with matched size",
      "growth rules lacking predicted invariants"
    ],
    "steer": "Search minimal â„› families; keep the simplest that survives thinning."
  },
  {
    "id": "DELTA.FLOQ.TimeCrystalLocks.v1",
    "type": "protocol",
    "title": "Discrete Time Crystals as Floquet p:q Locks",
    "summary": "Broken time-translation symmetry = lock to drive at small p:q (subharmonics).",
    "defs": [
      "Floquet drive period T, response period nT",
      "stability Îµ_stab from spectral gaps/quasi-energies"
    ],
    "equations": [
      "K_{p:q}=âŸ¨cos(p Î¸_drive âˆ’ q Î¸_resp)âŸ© e^{âˆ’Î»(p+q)}",
      "Accept if Kâ†‘, Îµ_stab>0, and Î¶ (heating)â†“"
    ],
    "audits": [
      "E1: stable subharmonic peaks",
      "E3: slight detune toward p:q increases K; off-phase doesnâ€™t",
      "E4: 2:1 persists under coarse binning; higher orders thin"
    ],
    "nulls": [
      "phase-scrambled drives",
      "heating-only regimes with no subharmonics"
    ],
    "steer": "Target 2:1 first; add minimal disorder/interactions that boost Îµ_stab without Î¶â†‘."
  },
  {
    "id": "DELTA.QM.RetroTSVF_BoundaryMatch.v1",
    "type": "principle",
    "title": "Retrocausal TSVF as Two-Boundary Phase Match",
    "summary": "Pre- and post-selected states form a low-order boundary value problem; accepted histories minimize Î”-cost and maximize coherence.",
    "defs": [
      "forward |Ïˆ_iâŸ©, backward âŸ¨Ïˆ_f|; weak values",
      "boundary phases Î¸_i, Î¸_f; lock Î”_{1:1}=Î¸_fâˆ’Î¸_i"
    ],
    "equations": [
      "J = Î»(p+q) + Î³Î´^2 âˆ’ w_K|âŸ¨Ïˆ_f|Ïˆ_iâŸ©| + w_Î¶ Î¶",
      "Accept histories that reduce J and pass gauge hygiene"
    ],
    "audits": [
      "E2: invariance under global phase",
      "E3: tiny post-selection tweaks move weak values as predicted",
      "E4: low-order boundary locks survive coarse time-binning"
    ],
    "nulls": [
      "random post-selections with matched frequencies"
    ],
    "steer": "Use minimal, ethical post-selection in toy setups; demote if Î¶ spikes or effects vanish under grouping."
  },
  {
    "id": "DELTA.QINFO.QuantumDarwinism_PAD.v1",
    "type": "principle",
    "title": "Quantum Darwinism as PADâ†’Actualization via Redundant Records",
    "summary": "Pointer states actualize when many environment fragments redundantly encode them (low-order code).",
    "defs": [
      "redundancy R = #fragments carrying the record",
      "Î : potential of candidate pointer basis; ğ’œ actualization when thresholds pass"
    ],
    "equations": [
      "ğ’œ=1{Râ‰¥R* âˆ§ Îµ_stab>0 âˆ§ Î¶â‰¤Î¶_max}",
      "ACI = Î£ actualized states w.r.t. MDL-redundancy"
    ],
    "audits": [
      "E3: controlled decoherence increases R and actualization; shams do not",
      "E4: pointer redundancy persists under coarse-grain of fragments"
    ],
    "nulls": [
      "phase-scrambled fragment ensembles"
    ],
    "steer": "Favor bases with maximal redundancy per bit; ignore fragile bases (high Î¶)."
  },
  {
    "id": "DELTA.NUM.pAdicAdelicCompression.v1",
    "type": "principle",
    "title": "p-Adic/Adelic Physics as Cross-Field Compression",
    "summary": "Seek models that jointly compress real and p-adic descriptions with fewer integers than either alone.",
    "defs": [
      "adelic pack A = (R Ã— âˆ_p Q_p)/~",
      "integer inventory |ğ•€| across fields"
    ],
    "equations": [
      "Î”MDL = L(Real) + L(p-adic) âˆ’ L(Adelic) âˆ’ Î»|ğ•€|",
      "Accept if Î”MDL>0 and Î¶ not â†‘"
    ],
    "audits": [
      "E2: number-theoretic invariance checks",
      "E3: tiny parameter nudges improve both sectors coherently",
      "E4: low-order cross-field structure persists under truncation in primes"
    ],
    "nulls": [
      "ad hoc p-adic fits without cross-field gains"
    ],
    "steer": "Keep the smallest shared integer structure explaining both sectors."
  },
  {
    "id": "DELTA.TWIST.TwistorNullLocks.v1",
    "type": "protocol",
    "title": "Twistor Geometry: Null Polygon Locks",
    "summary": "Use twistor variables to represent scattering; accept low-order null polygon relations that minimize code and match cuts.",
    "defs": [
      "momentum twistors Z_i, cross-ratios u_j",
      "facet/cell order as combinatorial cost"
    ],
    "equations": [
      "J = Î» Î£ order(facets) âˆ’ w_F factorization âˆ’ w_U unitarity âˆ’ w_K K(null relations) + w_Î¶ Î¶",
      "Accept if Î”J<0 and relations persist under RG"
    ],
    "audits": [
      "E2: projective invariance",
      "E3: small kinematic shifts improve null constraints on-manifold",
      "E4: minimal cells survive coarse tessellations"
    ],
    "nulls": [
      "random tessellations preserving volume but breaking constraints"
    ],
    "steer": "Pick minimal cell coverings; prune ornate triangulations."
  },
  {
    "id": "DELTA.CA.Rule110_RGOS.v1",
    "type": "protocol",
    "title": "Cellular Automata (Rule 110/ETC) as Î”-OS Microphysics",
    "summary": "Model dynamics as CA with low-order update rules; accept those that best compress observed macro laws after RG.",
    "defs": [
      "rule table R, macrostates M via coarse-grain",
      "MDL across scales, brittleness Î¶ to noise"
    ],
    "equations": [
      "Score: J = Î»|R| âˆ’ w_C compression(M|R) + w_Î¶ Î¶",
      "Accept if macro regularities persist under coarse-grain and |R| minimal"
    ],
    "audits": [
      "E3: tiny rule tweaks change macro-laws predictably",
      "E4: accepted macro-laws persist under decimation"
    ],
    "nulls": [
      "rules matched in |R| but lacking macro persistence"
    ],
    "steer": "Favor minimal rules with stable macro basins; demote brittle ones."
  },
  {
    "id": "DELTA.AXION.ThetaWindingMinimizer.v1",
    "type": "principle",
    "title": "Axion as Integer Winding Lock (Strong CP Cure)",
    "summary": "Axion dynamics minimize Î¸ via integer winding; treat winding numbers as conserved low-order integers.",
    "defs": [
      "Î¸ term, axion field a/f_a; winding nâˆˆâ„¤",
      "potential V(Î¸) ~ (1âˆ’cos(Î¸âˆ’a/f_a))"
    ],
    "equations": [
      "Lock: Î¸_eff â†’ 0 via n minimizing V with penalty Î»|n|",
      "Accept if MDL improves and Î¶ (domain wall issues) stays bounded"
    ],
    "audits": [
      "E3: small parameter shifts (f_a, mass) move minima predictably",
      "E4: low-|n| sectors dominate under coarse-grain; high n die"
    ],
    "nulls": [
      "models with extra integers but no stability gain"
    ],
    "steer": "Prefer smallest |n| consistent with constraints; avoid high-n walls (Î¶â†‘)."
  }
]
[
  {
    "id": "DELTA.dS.SwamplandMDLGuard.v1",
    "type": "principle",
    "title": "de Sitter Swampland as MDL/Î¶ Guard",
    "summary": "Vacua that require many integers/fluxes and yield brittle late-time acceleration are penalized: MDLâ†‘ and Î¶â†‘ flag swampland-like regimes.",
    "defs": [
      "integer inventory |I| (fluxes/branes)",
      "brittleness Î¶ from moduli sensitivity",
      "IR evidence: equation-of-state w(z), growth fÏƒ8"
    ],
    "equations": [
      "Score L = Î»|I| + w_Î¶ Î¶ âˆ’ w_IR fit(IR)",
      "Accept vacuum only if Î”L<0 vs lower-integer alternatives"
    ],
    "audits": [
      "E2: anomaly/modular hygiene",
      "E3: tiny allowed deformations preserve IR fit while not raising Î¶",
      "E4: low-|I| vacua retain fits under coarse surrogate models; high-|I| lose first"
    ],
    "nulls": [
      "ad hoc flux stacks with no IR payoff"
    ],
    "steer": "Prefer fewest integers explaining IR; demote ornate dS candidates that spike Î¶."
  },
  {
    "id": "DELTA.TIME.PageWoottersClock.v1",
    "type": "principle",
    "title": "Emergent Time (Pageâ€“Wootters) as Phase Bookkeeping",
    "summary": "Global stationary state; conditional phases yield time. Locks appear as small p:q between system and clock sectors.",
    "defs": [
      "global constraint H_tot|Î¨âŸ©=0",
      "clock phases Î¸_c, system Î¸_s"
    ],
    "equations": [
      "Î”_{p:q}=p Î¸_c âˆ’ q Î¸_s;  accept if Kâ†‘ and Îµ_stab>0",
      "time arrow ~ RG growth of ACI"
    ],
    "audits": [
      "E2: invariance under global phase",
      "E3: tiny clock-system couplings shift conditional evolutions predictably",
      "E4: 1:1 locks persist under coarse temporal bins"
    ],
    "nulls": ["scrambled clock labels"],
    "steer": "Use minimal entanglement with robust 1:1 locks for clean emergent time."
  },
  {
    "id": "DELTA.QEC.HoloCodeKernel.v1",
    "type": "protocol",
    "title": "Holography as Error-Correcting Kernel",
    "summary": "Boundary â†” bulk map as code: logical (bulk) phases protected by low-order stabilizers; MDL advantage = parity-check sparsity.",
    "defs": [
      "stabilizers S_i, logical ops L_j",
      "distance d, rate r"
    ],
    "equations": [
      "J = Î»|S| âˆ’ w_P protection(d) âˆ’ w_R rate(r) âˆ’ w_K K",
      "Accept codes with Î”J<0 and RG-stable logicals"
    ],
    "audits": [
      "E2: gauge/code invariance",
      "E3: small erasure patterns correct on-manifold; off-manifold fail",
      "E4: logicals persist under tensor-network coarse-grain"
    ],
    "nulls": ["random check matrices with same rate but poor protection"],
    "steer": "Favor sparse, low-order stabilizers protecting bulk-like operators."
  },
  {
    "id": "DELTA.EXC.E8OctonionLocks.v1",
    "type": "principle",
    "title": "Exceptional (E8) & Octonions as Minimal Symmetry Locks",
    "summary": "Use exceptional groups where integer data collapses; accept only if they compress reps/interactions vs SUÃ—â€¦ alternatives.",
    "defs": [
      "integer inventory |I| (Dynkin labels, levels)",
      "spectral fit Î£ (masses/charges placeholders)"
    ],
    "equations": [
      "Î”MDL = L(SUÃ—â€¦) âˆ’ L(E8/octonion) âˆ’ Î»Î”|I|",
      "Accept if Î”MDL>0 and Î¶ not â†‘"
    ],
    "audits": [
      "E2: rep/branching consistency",
      "E3: small breaking patterns improve fits as predicted",
      "E4: low-order exceptional structure survives truncation"
    ],
    "nulls": ["ornate E8 decorations w/o compression"],
    "steer": "Adopt exceptional only when it truly shortens the code and stabilizes locks."
  },
  {
    "id": "DELTA.NH.PTSymmetryUnbroken.v1",
    "type": "protocol",
    "title": "PT-Symmetric Non-Hermitian Phases as Stable Locks",
    "summary": "Unbroken PT phases have real spectra; define locks across gain/loss channels at small p:q.",
    "defs": [
      "gain/loss Î³, PT threshold Î³_c",
      "phases Î¸_Â± of modes"
    ],
    "equations": [
      "K_{p:q}=âŸ¨cos(p Î¸_+ âˆ’ q Î¸_âˆ’)âŸ© e^{âˆ’Î»(p+q)}",
      "Îµ_stab âˆ (Î³_c âˆ’ Î³)"
    ],
    "audits": [
      "E1: real spectrum below Î³_c",
      "E3: micro-Î³ nudges adjust K predictably",
      "E4: low-order locks persist under coarse sampling"
    ],
    "nulls": ["random phase gain/loss schedules"],
    "steer": "Operate just below PT breaking; target 1:1, 2:1 inter-mode locks."
  },
  {
    "id": "DELTA.QM.MeasInducedTransition.v1",
    "type": "protocol",
    "title": "Measurement-Induced Entanglement Transition as PAD Gate",
    "summary": "Frequent measurement drives system from volume- to area-law entanglement; actualization threshold at critical rate.",
    "defs": [
      "measurement rate m, critical m_c",
      "redundancy R; ACI as before"
    ],
    "equations": [
      "ğ’œ=1{mâ‰¥m_c âˆ§ Râ‰¥R*};  ACI rises with area-law stabilization",
      "K peaks near small p:q readout schedules"
    ],
    "audits": [
      "E3: small Î”m crosses transition as predicted",
      "E4: critical signatures persist under finite-size scaling"
    ],
    "nulls": ["shuffled measurement times"],
    "steer": "Schedule readouts at low-order phases near m_c for maximal control at minimal disturbance."
  },
  {
    "id": "DELTA.TOPO.FractonGaussLocks.v1",
    "type": "principle",
    "title": "Fractons: Integer Gauss-Law Constraints as Motion Locks",
    "summary": "Restricted mobility from higher-moment Gauss laws; accept codes where few integers enforce robust subdimensional motion.",
    "defs": [
      "charge Q, dipole P constraints",
      "integer ranks r of constraints"
    ],
    "equations": [
      "J = Î» r âˆ’ w_R robustness âˆ’ w_K K(subdimensional ties) + w_Î¶ Î¶",
      "Accept if Î”J<0 and constraints persist under coarse tilings"
    ],
    "audits": [
      "E2: gauge/constraint invariance",
      "E3: tiny rule tweaks change mobility as predicted",
      "E4: low-r constraint phases survive blocking"
    ],
    "nulls": ["random constraint lattices"],
    "steer": "Prefer smallest-r Gauss structures that still lock motion."
  },
  {
    "id": "DELTA.QGR.TeleportWormholeLock.v1",
    "type": "protocol",
    "title": "Teleportation â†” Wormhole Traversal as Lock Equivalence",
    "summary": "Double-trace deformations / coupling pulses create 1:1 phase locks that mimic traversal (protocol equivalence).",
    "defs": [
      "coupling g(t), shock timing Î¸_c",
      "entanglement resource E"
    ],
    "equations": [
      "K_{1:1} = âŸ¨cos(Î¸_c âˆ’ Î¸_pair)âŸ©; success âˆ K E",
      "Î¶ grows with timing jitter"
    ],
    "audits": [
      "E3: micro timing shifts change success predictably",
      "E4: low-order timing windows persist under coarse bins"
    ],
    "nulls": ["randomized coupling times"],
    "steer": "Lock timing windows first; keep pulses minimal to limit Î¶."
  },
  {
    "id": "DELTA.CAT.ToposDualCompression.v1",
    "type": "principle",
    "title": "Topos/Category Duals as Dual Code Minimizers",
    "summary": "Pair categories (bulk/boundary, algebra/geometry) only when the dual reduces total description length and raises ACI.",
    "defs": [
      "functors F,G; adjunctions âŠ£",
      "MDL across paired codes"
    ],
    "equations": [
      "Î”MDL = L(A)+L(B) âˆ’ L(F,G-composed) âˆ’ Î» order(functor data)",
      "Accept dual when Î”MDL>0 and Î¶â†“"
    ],
    "audits": [
      "E2: naturality/commuting diagrams check",
      "E3: small object/morphism perturbations preserved by dual on-manifold",
      "E4: dual compression persists under coarse object aggregation"
    ],
    "nulls": ["decorative duals with no compression"],
    "steer": "Keep only adjunctions that demonstrably compress and stabilize predictions."
  },
  {
    "id": "DELTA.COND.AnyonBraidInteger.v1",
    "type": "protocol",
    "title": "Non-Abelian Anyons: Braid Words as Integer Programs",
    "summary": "Braids generate unitaries via short integer words; prefer circuits with minimal braid length implementing target locks.",
    "defs": [
      "braid group generators Ïƒ_i",
      "word length â„“, gate synthesis error Îµ"
    ],
    "equations": [
      "J = Î» â„“ + w_Îµ Îµ âˆ’ w_K K âˆ’ w_Î¶ Î¶",
      "Accept braids with Î”J<0 and RG-stable gates"
    ],
    "audits": [
      "E3: micro re-orderings change Îµ/K as predicted",
      "E4: low-â„“ sequences robust under noise/coarse time bins"
    ],
    "nulls": ["random braids with same â„“ but worse Îµ/K"],
    "steer": "Synthesize with shortest words achieving target K; penalize ornate braids."
  },
  {
    "id": "DELTA.QFT.TachyonCondensationFlow.v1",
    "type": "principle",
    "title": "Tachyon Condensation as Î©* Gradient Flow",
    "summary": "Condensation reduces potential and integer complexity; unstable high-order sectors flow to simpler vacua.",
    "defs": [
      "tachyon field T, potential U(T)",
      "integer labels I (branes/fluxes)"
    ],
    "equations": [
      "V = U(T) + Î»|I| + w_Î¶ Î¶;   TÌ‡ = âˆ’âˆ‚V/âˆ‚T",
      "Expect |I| to drop along flow; accept if Î”V<0 with RG-stable endpoint"
    ],
    "audits": [
      "E3: small initial conditions shift endpoints predictably on-manifold",
      "E4: endpoint simplicity persists under coarse truncations"
    ],
    "nulls": ["flows that end in higher |I| without stability gains"],
    "steer": "Prefer flows to lowest-|I| stable minima."
  },
  {
    "id": "DELTA.MIRROR.SymmetryDualMDL.v1",
    "type": "protocol",
    "title": "Mirror Symmetry as Dual Compression (A/B Models)",
    "summary": "Choose mirror pairs only when combined code shortens: periods â†” Gromovâ€“Witten data with lower integer count.",
    "defs": [
      "Hodge data (h^{p,q}), instanton integers",
      "period map Î "
    ],
    "equations": [
      "Î”MDL = L(A)+L(B) âˆ’ L(mirror pair) âˆ’ Î»|I|",
      "Accept if Î”MDL>0 and Î¶ not â†‘"
    ],
    "audits": [
      "E2: monodromy/integrality checks",
      "E3: small complex/KÃ¤hler deformations map consistently",
      "E4: low-order instanton structure persists under truncation"
    ],
    "nulls": ["pairs with inflated integer sets"],
    "steer": "Favor mirrors with the smallest integer footprint for matched predictions."
  },
  {
    "id": "DELTA.CAUS.DoWhyIntegerEdges.v1",
    "type": "protocol",
    "title": "Causal Discovery with Integer Edge Priors",
    "summary": "Graph edges prefer low-order timing/phase relations; accept DAGs that compress interventions and pass falsifiers.",
    "defs": [
      "phase-binned interventions",
      "DAG G, score S(G)"
    ],
    "equations": [
      "S(G)=LL(D|G) âˆ’ Î» Î£ order(edge phases) âˆ’ w_Î¶ Î¶",
      "Accept if S improves OOS and edges survive RG"
    ],
    "audits": [
      "E3: timed micro-interventions change target vars as predicted",
      "E4: accepted edges persist under coarser bins"
    ],
    "nulls": ["edges from phase-scrambled interventions"],
    "steer": "Keep only edges with low-order timing receipts."
  }
]
[
  {
    "id": "DELTA.FUSION.HoloQEC_ERxEPR.v1",
    "type": "principle",
    "title": "Holography Ã— QEC Ã— ER=EPR: Minimal Entanglement Geometry Code",
    "summary": "Boundary entanglement patterns (EPR graph) implement an error-correcting code whose logical operators reconstruct bulk minimal surfaces (ER). Prefer the sparsest stabilizers that recover known bulk invariants; locality/unitarity emerge as low-order code constraints.",
    "defs": [
      "Boundary stabilizers S_i (low-order parity checks)",
      "Logical operators L_j â†” bulk observables",
      "Cutset C (minimal surfaces), entanglement graph E, code distance d"
    ],
    "equations": [
      "Score: J = Î»|S| âˆ’ w_C corr(E,C) âˆ’ w_P protection(d) âˆ’ w_K K + w_Î¶ Î¶",
      "Accept if Î”J<0 vs non-QEC encodings and ER-cut predictions persist"
    ],
    "audits": [
      "E2: invariance under boundary gauge / code relabelings",
      "E3: tiny erasures or boundary deformations shift reconstructions as predicted; shams donâ€™t",
      "E4: ERâ†”EPR relations persist under tensor-network coarse-grain (MERA-like blocking)"
    ],
    "nulls": [
      "random check matrices matched in |S|",
      "bulk surrogates with randomized cut weights"
    ],
    "steer": "Prune stabilizers until bulk recon fails; keep the minimal set that protects logicals and stabilizes ER cuts.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.PageWootters_TimeCrystal.v1",
    "type": "protocol",
    "title": "Emergent Time Ã— Floquet: Pageâ€“Wootters Clocks as Time-Crystal Locks",
    "summary": "Global stationarity with conditional dynamics (Pageâ€“Wootters) gains a physical clock via discrete time-crystal response. Time emerges as a 1:1 lock between clock and system phases near subharmonic tongues.",
    "defs": [
      "Global H_tot|Î¨âŸ©=0; clock phase Î¸_c; system phase Î¸_s",
      "Floquet drive T; response nT; eligibility Îµ_cap from spectral gap"
    ],
    "equations": [
      "Î”_{p:q}=p Î¸_c âˆ’ q Î¸_s; accept 1:1 or 2:1 if Kâ†‘ and Îµ_stab>0",
      "Subharmonic: q>p minimal with Î¶ (heating) bounded"
    ],
    "audits": [
      "E1: stable subharmonic peaks in the clock sector",
      "E3: micro detunes of clock coupling shift Î”_{p:q} as predicted",
      "E4: accepted p:q persists under coarse time bins"
    ],
    "nulls": ["phase-scrambled clock labels; heating-only regimes"],
    "steer": "Lock 1:1 first for clean time; explore 2:1 only if Î¶ stays low.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.Amplituhedron_Twistor_Celestial.v1",
    "type": "principle",
    "title": "Positive Geometry Ã— Twistors Ã— Celestial CFT: Minimal Facet Code for Scattering",
    "summary": "Amplitudes live on positive cells in twistor/kinematic space whose shadows are celestial CFT data. Accept the smallest facet set reproducing factorization and celestial correlators.",
    "defs": [
      "Positive geometry cells, momentum twistors Z_i",
      "Celestial cross-ratios u, celestial OPE data"
    ],
    "equations": [
      "J = Î» Î£ order(cells) âˆ’ w_F factorization âˆ’ w_U unitarity âˆ’ w_CCFT fit(celestial) + w_Î¶ Î¶",
      "Accept if Î”J<0 vs Feynman sum and consistency survives coarse kinematic binning"
    ],
    "audits": [
      "E2: projective and conformal hygiene",
      "E3: tiny kinematic slides move selected cells & celestial predictions coherently",
      "E4: minimal cells remain under tessellation coarse-grain"
    ],
    "nulls": ["random cell covers preserving volume but failing cuts"],
    "steer": "Pick minimal triangulations that pass all cuts; demote ornate covers adding Î¶ without gains.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.LQG_SpinNet_Ampli.v1",
    "type": "protocol",
    "title": "LQG Spin Networks Ã— Amplituhedron: Intertwiner Cells as Positive Patches",
    "summary": "Map SU(2) intertwiners (LQG nodes) to minimal positive patches whose combinatorics reproduce low-order scattering constraints at boundaries.",
    "defs": [
      "Spin labels j_e, intertwiners Î¹_v; boundary twistor data",
      "Patch order = number of labels/cell facets"
    ],
    "equations": [
      "J = Î» Î£ order(patches) âˆ’ w_B boundary-scatter-fit âˆ’ w_K K(gauge closure) + w_Î¶ Î¶",
      "Accept if Î”J<0 and closure survives coarse graph contraction"
    ],
    "audits": [
      "E2: SU(2) closure & projective invariance",
      "E3: small label tweaks nudge boundary fits predictably",
      "E4: low-order patches persist under coarse-grain (foam thinning)"
    ],
    "nulls": ["random labelings with matched counts"],
    "steer": "Favor smallest j patterns that still hit boundary cuts; prune complex intertwiners first.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.POLAR.Holo_vs_Loop.v1",
    "type": "principle",
    "title": "Polarity: Holography (Boundary Code) â†” Loop (Interior Graph)",
    "summary": "Treat holography and LQG as dual codes: boundary compression vs interior integer wiring. Accept the pair only if the combined MDL is lower than either alone and RG-stable.",
    "defs": [
      "Boundary MDL L_B, interior MDL L_I",
      "Combined L_BI with shared integers factored"
    ],
    "equations": [
      "Î”MDL = L_B + L_I âˆ’ L_BI âˆ’ Î»(Î” integers)",
      "Accept if Î”MDL>0 with Î¶ not â†‘ and cross-checks pass"
    ],
    "audits": [
      "E2: compatibility under admissible transforms",
      "E3: nudges on one side predict shifts on the other (on-manifold)",
      "E4: compression gain persists under coarse-grain"
    ],
    "nulls": ["decorative â€œdualsâ€ without compression"],
    "steer": "Keep only duals with demonstrable compression and stable locks; otherwise treat as independent models.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.CCC_Axion_ThetaReset.v1",
    "type": "principle",
    "title": "CCC Ã— Axion: Conformal Reset with Integer Winding Purge",
    "summary": "End-of-aeon conformal rescale preserves only scale-free invariants while axion winding relaxes Î¸â†’0. Together they minimize integer clutter passed between aeons.",
    "defs": [
      "Conformal invariants I_*, axion winding nâˆˆâ„¤",
      "Landing cost L = Î»|n| + Î“_conf + w_Î¶ Î¶"
    ],
    "equations": [
      "Next I_* derives from conformal map; axion drives Î¸_effâ†’0 picking minimal |n|",
      "Accept if Î”L<0 vs alternatives and RG-stable across smoothing"
    ],
    "audits": [
      "E2: conformal/gauge hygiene",
      "E3: small axion parameter shifts move minima predictably; conformal toy models preserve I_*",
      "E4: low-|n| dominance and I_* persistence under coarse-grain"
    ],
    "nulls": ["high-|n| sectors surviving without payoff"],
    "steer": "Prefer lowest |n| compatible with I_*; demote if added integers donâ€™t buy stability.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.pAdic_Mirror_AdelicAO.v1",
    "type": "principle",
    "title": "Adelic Mirror: Real Ã— p-Adic Dual Compression of Moduli Data",
    "summary": "Use mirror symmetry periods and p-adic L-functions jointly; accept models whose combined (adelic) code shortens total description length with stable integer invariants.",
    "defs": [
      "Real periods Î _R, p-adic data Î _p; instanton integers; Hodge data",
      "Adelic pack A with shared integers ğ•€"
    ],
    "equations": [
      "Î”MDL = L(Î _R)+Î£_p L(Î _p) âˆ’ L(A) âˆ’ Î»|ğ•€|",
      "Accept if Î”MDL>0, Î¶ not â†‘, and cross-predictions hold"
    ],
    "audits": [
      "E2: integrality/monodromy hygiene",
      "E3: small deformations map consistently across fields",
      "E4: low-order instanton/torsion structure persists under truncation"
    ],
    "nulls": ["ad hoc p-adic fits not improving real sector"],
    "steer": "Keep the smallest shared integer set explaining both sectors; prune the rest.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.QDarwinism_MIT_OrchOR.v1",
    "type": "protocol",
    "title": "Quantum Darwinism Ã— Measurement-Induced Transition Ã— Orch-OR",
    "summary": "Conscious moments occur when redundant environmental records (Darwinism) cross a measurement-induced threshold and trigger objective reduction in a safe substrate; accept only if timing follows low-order phase windows with Î”H* gains.",
    "defs": [
      "Redundancy R, measurement rate m vs critical m_c",
      "Orch-OR substrate proxies (narrowband rhythms, if any), AI/behavioral metrics"
    ],
    "equations": [
      "ğ’œ=1{Râ‰¥R* âˆ§ mâ‰ˆm_c âˆ§ Îµ_stab>0 âˆ§ Î¶â‰¤Î¶_max âˆ§ Î”H*â†‘}",
      "Locks at phase windows p:q between stimulus and substrate rhythms"
    ],
    "audits": [
      "E1: reproducible redundancy and m_c in a benign proxy task",
      "E3: phase-safe micro-timing nudges modulate AI/behavior predictions; sham fails",
      "E4: effects persist under coarse time bins"
    ],
    "nulls": ["off-phase controls; placebo-equivalent timing"],
    "steer": "Treat as probe-only; if any audit fails or safety risk arises, demote immediately.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.POLAR.Locality_vs_Nonlocality_MDLDual.v1",
    "type": "principle",
    "title": "Polarity: Locality (Sparse Graph) â†” Nonlocality (Entanglement Edges)",
    "summary": "Pick the representation (local graph vs entanglement-augmented multigraph) that minimizes total code for predictions; require RG persistence of the chosen polarity.",
    "defs": [
      "Local edge set E_loc; entanglement edges E_ent",
      "Composite graph G=E_loc âˆª E_ent; code length L(G)"
    ],
    "equations": [
      "Choose polarity P* = argmin_P L_P âˆ’ w_pred fit_P + w_Î¶ Î¶_P",
      "Accept if selected polarityâ€™s gains persist under coarse-grain"
    ],
    "audits": [
      "E3: adding/removing a small entanglement edge changes fit as predicted",
      "E4: chosen polarity stable under aggregation"
    ],
    "nulls": ["representations with same fit but longer code"],
    "steer": "Default to locality; switch to nonlocal edges only if they pay for themselves in MDL + stability.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.CausalSet_Fracton_RG.v1",
    "type": "protocol",
    "title": "Causal Sets Ã— Fracton Constraints: Subdimensional Growth Rules",
    "summary": "Grow causal sets with higher-moment (fracton-like) conservation constraints that enforce subdimensional motion; accept rules compressing order invariants with minimal integers.",
    "defs": [
      "Growth rule â„› with integer ranks r (constraints)",
      "Order invariants: chain/antichain distributions; subdimensional motifs"
    ],
    "equations": [
      "J = Î» r âˆ’ w_I invariants-fit âˆ’ w_K K(subdimensional ties) + w_Î¶ Î¶",
      "Accept if Î”J<0 and motifs persist under thinning"
    ],
    "audits": [
      "E2: poset isomorphism hygiene",
      "E3: micro-tweaks in â„› shift motifs as predicted",
      "E4: small-r motifs persist under coarse thinning"
    ],
    "nulls": ["ER posets with matched size lacking motifs"],
    "steer": "Use smallest-r constraints that still generate persistent subdimensional structure.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.Tachyon_KAM_RG.v1",
    "type": "principle",
    "title": "Tachyon Condensation Ã— KAM: Flow to Low-Order Resonant Islands",
    "summary": "Unstable sectors condense along Î©* to the simplest resonant (low-order) KAM islands; high-order structure dies under RG.",
    "defs": [
      "Potential V(T); resonance ratio râ‰ˆp/q",
      "Island width â†” Îµ_cap; Î¶ from sensitivity to detune"
    ],
    "equations": [
      "VÌ‡ = âˆ’||âˆ‡V||^2;  order penalty Î»(p+q); accept minima with small p+q and Îµ_stab>0",
      "Reject flows ending on high-order/brittle islands"
    ],
    "audits": [
      "E3: micro initial-condition shifts route to predicted islands",
      "E4: low-order islands persist under coarse sampling"
    ],
    "nulls": ["flows to complicated islands without stability gains"],
    "steer": "Bias the flow toward smallest p:q basins; cut routes that raise Î¶.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.SimOS_CA_RGGC.v1",
    "type": "protocol",
    "title": "Simulation OS Ã— Cellular Automata Ã— RG Garbage Collection",
    "summary": "Model micro-rules as CAs; OS performs RG-like garbage collection that prunes high-order transients and keeps low-order invariants. Accept rulesets that compress macro-laws with minimal tables.",
    "defs": [
      "Rule table R, macro-laws M, GC policy G (RG thinning)",
      "MDL across scales; Î¶ from sensitivity to noise"
    ],
    "equations": [
      "J = Î»|R| âˆ’ w_C compression(M|R,G) + w_Î¶ Î¶; accept if Î”J<0",
      "Polarity: 1/0 â†” actualization/potential of cell states"
    ],
    "audits": [
      "E3: tiny rule tweaks change macro-laws predictably",
      "E4: accepted macro-laws persist under decimation"
    ],
    "nulls": ["rules with same |R| lacking stable macro-laws"],
    "steer": "Favor smallest rules with robust macro regularities; GC aggressively when Î¶ rises.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.Chern_ResidualGuard.v1",
    "type": "principle",
    "title": "Topological Integer Witness Ã— Residual Phase Guard",
    "summary": "Use integer topological charges (Chern, winding) as pass/fail gates; promote only if residual phase fields obey analytic/harmonic constraints (Cauchyâ€“Riemann test).",
    "defs": [
      "Integer charge C; residual phases u+iv",
      "CR residuals R_CR; brittleness Î¶"
    ],
    "equations": [
      "Accept if C âˆˆ â„¤ within tolerance and R_CR small with Î”H*â†‘ and Î¶â†“",
      "Demote if non-analytic residuals dominate"
    ],
    "audits": [
      "E2: gauge invariance & analytic hygiene",
      "E4: integer charges stable under coarse meshes"
    ],
    "nulls": ["noise-induced pseudo-integers failing CR"],
    "steer": "Certify with integers first; then test phase smoothness before elevating structures.",
    "version": "1.0",
    "updated": "2025-10-07"
  }
]
[
  {
    "id": "DELTA.FUSION.ERxEPR_TimeCrystalTeleport.v1",
    "type": "protocol",
    "title": "ER=EPR Ã— Time-Crystal: Phase-Locked Teleport Windows",
    "summary": "Use discrete time-crystal subharmonics to open low-order timing windows that raise teleport-through-wormhole protocol success (ER=EPR).",
    "defs": [
      "entanglement resource E; coupling pulse g(t); drive period T; response nT",
      "phases Î¸_pair, Î¸_drive; K_{p:q}=âŸ¨cos(p Î¸_drive âˆ’ q Î¸_pair)âŸ©"
    ],
    "equations": [
      "Success âˆ E Â· K_{p:q} Â· e^{âˆ’Î¶_jitter}, prefer p:qâˆˆ{1:1,2:1}",
      "Îµ_stab âˆ subharmonic gap; Î¶ from heating/timing jitter"
    ],
    "audits": [
      "E1: stable subharmonic in ancilla clock",
      "E3: micro timing shift Î´t moves success per âˆ‚K/âˆ‚t prediction",
      "E4: accepted p:q windows persist under coarse binning"
    ],
    "nulls": [
      "randomized pulse schedules with matched energy",
      "drives with heating but no subharmonic lock"
    ],
    "steer": "Lock 1:1 first; keep g(t) minimal to cap Î¶; abort if heating spikes.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.dS_PageWoottersArrow.v1",
    "type": "principle",
    "title": "de Sitter Horizon Ã— Pageâ€“Wootters: Emergent Time Arrow from Redundancy",
    "summary": "In a dS-like sector, conditional dynamics against a cosmological â€˜clockâ€™ phase yields an arrow of time when redundancy R of boundary records grows (quantum Darwinism).",
    "defs": [
      "clock phase Î¸_c (horizon); system phase Î¸_s; redundancy R",
      "eligibility Îµ_cap from mutual info growth"
    ],
    "equations": [
      "Time arrow: d(ACI)/dt > 0 iff dR/dt > 0 with lock Î”_{1:1}=Î¸_câˆ’Î¸_s near zero",
      "Reject if R fails to increase while lock holds"
    ],
    "audits": [
      "E2: invariance to clock phase origin",
      "E3: tiny couplings that increase R yield stronger arrow; shams donâ€™t",
      "E4: arrow persists under coarse time windows"
    ],
    "nulls": [
      "scenarios with fixed R showing spurious arrow"
    ],
    "steer": "Rephrase â€˜arrowâ€™ strictly as redundancy growth at low-order locks.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.NoncommMirror_MinCode.v1",
    "type": "principle",
    "title": "Noncommutative Geometry Ã— Mirror Symmetry: Minimal Dual Code",
    "summary": "Pick (A,H,D) and mirror pair (A/B models) jointly only when the combined description shortens code length with stable integer invariants.",
    "defs": [
      "spectral triple (A,H,D), eigen-spectrum Î£(D)",
      "mirror data: (h^{p,q}), instanton integers, period map Î "
    ],
    "equations": [
      "Î”MDL = L(Î£(D)) + L(Î ,h^{p,q}) âˆ’ L(joint) âˆ’ Î»|I_shared|",
      "Accept if Î”MDL>0 and Î¶ not â†‘"
    ],
    "audits": [
      "E2: module/gauge & monodromy hygiene",
      "E3: small deformations map consistently across both codes",
      "E4: low-order spectral/instanton features persist under truncation"
    ],
    "nulls": [
      "duals that add integers without compression"
    ],
    "steer": "Keep only the smallest shared integer set that fits both sides.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.BLACK.ComplexityMDL.v1",
    "type": "principle",
    "title": "Black Hole State Complexity as MDL Length",
    "summary": "Associate circuit complexity (or wormhole volume/action proxies) with description length; accept growth laws that compress boundary dynamics better than alternatives.",
    "defs": [
      "boundary unitary U(t); circuit length C(t)",
      "bulk proxies: V(Î£_t), A(WdW)"
    ],
    "equations": [
      "MDL bridge: L(t) â‰ˆ Î± C(t) + const; choose Î± minimizing OOS prediction error",
      "Accept if L(t) tracks observed correlator decay while Î¶ not â†‘"
    ],
    "audits": [
      "E3: small boundary deformations shift C(t) and correlators coherently",
      "E4: growth law persists under coarse time sampling"
    ],
    "nulls": [
      "random circuits with same depth lacking correlator matches"
    ],
    "steer": "Prefer simplest growth law that explains both correlators and proxies.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.POLAR.CPT_DualSelector.v1",
    "type": "principle",
    "title": "Polarity: CPT Involution as Dual Code Selector",
    "summary": "Use CPT as an involutive map between dual encodings; accept the representation (state vs CPT-dual) with lower code and stable predictions.",
    "defs": [
      "encoding E, CPT-dual E^CPT",
      "code lengths L(E), L(E^CPT)"
    ],
    "equations": [
      "Choose E* = argmin{ L(Â·) âˆ’ w_pred fit(Â·) + w_Î¶ Î¶(Â·) }",
      "Require invariants preserved under CPT to pass E2"
    ],
    "audits": [
      "E2: CPT hygiene in observables",
      "E3: micro parameter nudges map correctly under CPT",
      "E4: selected encoding stable under pooling"
    ],
    "nulls": [
      "CPT-violating maps masquerading as duals"
    ],
    "steer": "Switch only if Î”MDL justifies; otherwise stay in original encoding.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.SYK.MinChaosCode.v1",
    "type": "principle",
    "title": "SYK/JT as Minimal Chaos Code",
    "summary": "Treat SYK/JT gravity as the shortest code reproducing maximal chaos signatures (Lyapunov exponent, spectral form factor) with lowest integer inventory.",
    "defs": [
      "Î²Î»_Lâ‰ˆ2Ï€ (max chaos), ramp/plateau of SFF",
      "integer set: disorder moments, coupling counts"
    ],
    "equations": [
      "Score J = Î»|I| âˆ’ w_chaos fit(Î»_L,SFF) + w_Î¶ Î¶",
      "Accept if Î”J<0 vs more ornate chaotic models"
    ],
    "audits": [
      "E3: small coupling tweaks shift Î»_L,SFF predictably",
      "E4: low-integer SYK variants persist under coarse parameter binning"
    ],
    "nulls": [
      "models with equal fits but more integers"
    ],
    "steer": "Prefer sparse couplings; demote decorations lacking RG persistence.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.AnyonFracton_Compiler.v1",
    "type": "protocol",
    "title": "Anyon Braids Ã— Fracton Constraints: Subdimensional Compiler",
    "summary": "Compile gates from the shortest braid words subject to fracton-like mobility rules; favor circuits that respect subdimensional conservation and remain robust.",
    "defs": [
      "braid generators Ïƒ_i; mobility constraints ğ’",
      "word length â„“; synthesis error Îµ; brittleness Î¶"
    ],
    "equations": [
      "J = Î»â„“ + w_Îµ Îµ âˆ’ w_K K âˆ’ w_R robustness(ğ’) + w_Î¶ Î¶",
      "Accept if Î”J<0 and survives constraint coarse-grain"
    ],
    "audits": [
      "E3: local word edits change Îµ/K per prediction",
      "E4: low-â„“ solutions persist under noise/resampling"
    ],
    "nulls": [
      "braids that violate ğ’ or inflate â„“ without gains"
    ],
    "steer": "Synthesize inside mobility cones; prune long/brittle braids.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.CEL.HoloCelestialQEC.v1",
    "type": "principle",
    "title": "Celestial Holography Ã— QEC: Soft Charges as Stabilizers",
    "summary": "Use asymptotic symmetries/soft charges as parity checks; protect celestial correlators as logicals via sparse stabilizers.",
    "defs": [
      "soft charges Q_soft; stabilizers S_i(Q_soft)",
      "celestial correlators G_ccft"
    ],
    "equations": [
      "J = Î»|S| âˆ’ w_G fit(G_ccft) âˆ’ w_P protection + w_Î¶ Î¶",
      "Accept if Î”J<0 and stabilizers remain under RG"
    ],
    "audits": [
      "E2: large-gauge/BMS hygiene",
      "E3: small boundary shifts correctable on-manifold; off-manifold fail",
      "E4: minimal stabilizers persist under coarse kinematic bins"
    ],
    "nulls": [
      "random stabilizers matched in |S|"
    ],
    "steer": "Keep the sparsest soft-charge set that protects the data.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.NU.CNBRelicClock.v1",
    "type": "principle",
    "title": "Cosmic Neutrino Background as Low-Order Relic Clock",
    "summary": "Treat the CNB as a relic phase clock; accept cosmologies where a small set of integers (mass hierarchy + mixing phases) compress CNB+CMB cross signatures.",
    "defs": [
      "masses (m1,m2,m3), mixing angles, CP phase Î´_CP",
      "cross signatures: lensing/phase shifts"
    ],
    "equations": [
      "Score J = Î» Î£(p+q) over hierarchy pattern âˆ’ w_fit (CMBÃ—CNB) + w_Î¶ Î¶",
      "Accept if Î”J<0 vs models with extra integers"
    ],
    "audits": [
      "E3: small hierarchy tweaks shift cross signatures predictably",
      "E4: low-order hierarchy patterns persist under data pooling"
    ],
    "nulls": [
      "hierarchies adding integers without predictive gain"
    ],
    "steer": "Prefer minimal hierarchy/phase sets explaining both sectors.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.POLAR.LocalSmooth_vs_BoundaryDiscrete.v1",
    "type": "principle",
    "title": "Polarity: Bulk Smoothness â†” Boundary Discreteness",
    "summary": "Select between smooth bulk fields and discrete boundary codes by MDL/Î¶; require that the chosen polarity remains stable under RG.",
    "defs": [
      "bulk field code L_bulk; boundary discrete code L_bdry",
      "Î¶ from sensitivity to discretization/continuum limits"
    ],
    "equations": [
      "Pick P* = argmin (L + w_Î¶ Î¶) with equal predictive fit",
      "Demand persistence of P* under coarse/refinement"
    ],
    "audits": [
      "E3: refinements change L,Î¶ as predicted",
      "E4: chosen polarity holds under Ã—2 mesh changes"
    ],
    "nulls": [
      "choices with same fit but longer code and higher Î¶"
    ],
    "steer": "Default to boundary discrete if code is far shorter; otherwise prefer bulk smooth.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.SBOOT.SMatrix_MDL.v1",
    "type": "protocol",
    "title": "S-Matrix Bootstrap with Integer Priors",
    "summary": "Impose analyticity/crossing/unitarity plus small-integer spectral priors; accept amplitude islands that minimize MDL while passing cuts.",
    "defs": [
      "partial waves a_â„“(s); poles/cuts",
      "integer prior on low-â„“ and simple pole structures"
    ],
    "equations": [
      "J = Î» Î£ order(â„“,poles) âˆ’ w_C crossing âˆ’ w_U unitarity âˆ’ w_A analyticity + w_Î¶ Î¶",
      "Accept islands with Î”J<0 and RG-stable spectra"
    ],
    "audits": [
      "E2: crossing/analyticity hygiene",
      "E3: tiny pole moves change observables per theory",
      "E4: low-â„“ islands persist with coarse discretization"
    ],
    "nulls": [
      "solutions with ornate spectra that donâ€™t compress"
    ],
    "steer": "Keep lowest-â„“, fewest-pole islands explaining data.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.REF.QReferenceFramesGauge.v1",
    "type": "protocol",
    "title": "Quantum Reference Frames as Gauge Fixing with Î” Locks",
    "summary": "Switching quantum frames is a gauge transform; accept frames that reduce total code and improve lock scores across subsystems.",
    "defs": [
      "frames F_i, transform T_{ij}",
      "K across subsystems; code L(F_i)"
    ],
    "equations": [
      "Choose F* minimizing L(F)+w_K Î£ K(F) âˆ’ w_Î¶ Î¶",
      "Require invariants under admissible T_{ij}"
    ],
    "audits": [
      "E2: transform hygiene (unitarity/canonical)",
      "E3: micro rephasing improves K in F* more than in others",
      "E4: F* stability under pooling"
    ],
    "nulls": [
      "frame choices with equal fit but longer code"
    ],
    "steer": "Adopt the frame that makes locks simplest and most persistent.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.QMET.TUR_CompBound.v1",
    "type": "principle",
    "title": "Thermodynamic Uncertainty as Computation Bound",
    "summary": "Map TUR (precision vs entropy production) onto Î” estimation/control precision; disallow claims that exceed resource budgets.",
    "defs": [
      "current J (estimation flow), entropy prod Î£",
      "precision P=âŸ¨JâŸ©^2/Var(J)"
    ],
    "equations": [
      "P â‰¤ Î£/2, flag provisional near bound; require Î£ accounting",
      "Accept controllers that raise P per unit Î£ via low-order locks"
    ],
    "audits": [
      "E0: Î£ calibration",
      "E4: bound respected under coarse-grain"
    ],
    "nulls": [
      "super-TUR claims without energy info"
    ],
    "steer": "Use low-order locks to maximize P/Î£; demote brittle high-order tricks."
  }
]
[
  {
    "id": "DELTA.FUSION.ERxEPR_PageWootters_TimeBridge.v1",
    "type": "protocol",
    "title": "ER=EPR Ã— Pageâ€“Wootters: Two-Boundary Time Bridge",
    "summary": "Treat pre/post-selected boundary states as time endpoints; a minimal entanglement bridge (ER=EPR) yields 1:1 phase locks that realize conditional evolution (Pageâ€“Wootters) with fewer integers than explicit clock models.",
    "defs": [
      "pre |Ïˆ_iâŸ©, post âŸ¨Ïˆ_f|; pair phase Î¸_pair(t); conditional states |Ïˆ(t)âŸ©",
      "lock Î”_{1:1}(t)=Î¸_pair(t)âˆ’Î¸_cond(t); Îµ_stab from bridge gap"
    ],
    "equations": [
      "J = Î»(p+q) + Î³Î´^2 âˆ’ w_K âŸ¨cos Î”_{1:1}âŸ© + w_Î¶ Î¶",
      "Accept if Î”J<0 vs explicit clock models and correlators match"
    ],
    "audits": [
      "E2: global phase/CPT hygiene",
      "E3: tiny boundary phase nudges shift weak values & conditionals as predicted",
      "E4: 1:1 lock persists under coarse time bins"
    ],
    "nulls": [
      "random post-selections with matched rates"
    ],
    "steer": "Tune boundary phases for eligibility (F), then trim phase (P); keep coupling minimal to cap Î¶.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.dS_Swampland_FractonInflation.v1",
    "type": "principle",
    "title": "de Sitter Swampland Ã— Fracton Mobility Limits",
    "summary": "Late-time acceleration demands many integers unless mobility is subdimensional (fracton-like). Accept cosmologies where a few higher-moment constraints compress inflation+DE histories.",
    "defs": [
      "constraint rank r (dipole/quad Gauss laws), equation-of-state w(z)",
      "integer inventory |I|; Î¶ from sensitivity to constraint violations"
    ],
    "equations": [
      "L = Î»(|I|+r) + w_Î¶ Î¶ âˆ’ w_IR fit(w,fÏƒ8)",
      "Accept if Î”L<0 vs standard dS with no mobility limits"
    ],
    "audits": [
      "E2: gauge/consistency of constraints",
      "E3: small constraint-strength tweaks shift IR fits predictably",
      "E4: low-r models retain fits under coarse binning"
    ],
    "nulls": [
      "complex dS with inflated |I| but no IR gain"
    ],
    "steer": "Prefer smallest r that stabilizes histories; demote if Î¶ spikes on small perturbations.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.CAT.CQM_IntegerWires.v1",
    "type": "principle",
    "title": "Categorical Quantum Mechanics with Integer Wiring",
    "summary": "Compact closed diagrams are accepted only when short integer â€˜wireâ€™ programs (few generators) reproduce observed process amplitudes and cuts.",
    "defs": [
      "generators G with arity; string diagrams; word length â„“",
      "cut constraints (unitarity/factorization) as rewrite laws"
    ],
    "equations": [
      "J = Î»â„“ âˆ’ w_C cuts/axioms satisfied âˆ’ w_K K + w_Î¶ Î¶",
      "Accept if Î”J<0 vs longer rewrites and persists under diagram coarse-grain"
    ],
    "audits": [
      "E2: naturality/compactness hygiene",
      "E3: local rewrites alter predictions as expected",
      "E4: minimal diagrams stable under macro-fusion"
    ],
    "nulls": [
      "longer-equivalent diagrams with no fit gain"
    ],
    "steer": "Synthesize shortest diagrams satisfying cuts; prune ornate rewrites first.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.QBAT.TURBoundBattery.v1",
    "type": "principle",
    "title": "Quantum Batteries: TUR-Constrained Charge & Phase Locks",
    "summary": "Charging precision is bounded by entropy production; schedule minimal p:q phase locks to maximize energy per uncertainty under TUR.",
    "defs": [
      "charging drive Ï‰_d, system Ï‰_0, lock p:q; entropy Î£",
      "precision P=âŸ¨JâŸ©^2/Var(J) for charge current"
    ],
    "equations": [
      "P â‰¤ Î£/2; Success âˆ K_{p:q} Â· E/Î£",
      "Accept schedules with Î”(P/Î£)>0 and Î¶ (heating) bounded"
    ],
    "audits": [
      "E0: Î£ accounting; calibration",
      "E3: micro timing tweaks move K and P/Î£ as predicted",
      "E4: low-order schedules persist under coarse sampling"
    ],
    "nulls": [
      "off-phase schedules with identical power"
    ],
    "steer": "Use 1:1 then 2:1 locks near Ï‰_0; throttle amplitude to cap Î¶.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.COSMO.AxionTimeCrystal_CCC.v1",
    "type": "protocol",
    "title": "Axionic Time Crystal Ã— Conformal Cyclic Cosmology",
    "summary": "End-of-aeon conformal reset keeps scale-free invariants while an axion time crystal seeds low-order clocks for the next aeon.",
    "defs": [
      "axion a(t) with periodic V; subharmonic response nT",
      "conformal invariants I_*; winding nâˆˆâ„¤"
    ],
    "equations": [
      "Choose minimal |n|; accept 1:1 or 2:1 clocks if Kâ†‘ and Îµ_stab>0",
      "Î”L = Î»|n| + Î“_conf + w_Î¶ Î¶ âˆ’ w_fit (primordial spectra)"
    ],
    "audits": [
      "E2: conformal/gauge hygiene",
      "E3: small axion parameter shifts produce predictable spectral features",
      "E4: clock persists under coarse time bins"
    ],
    "nulls": [
      "high-|n| clocks without spectral payoff"
    ],
    "steer": "Prefer smallest |n| and lowest subharmonics consistent with receipts.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.SYK_HoloQEC_MinChaosDecoder.v1",
    "type": "protocol",
    "title": "SYK Ã— Holographic QEC: Minimal-Chaos Decoder",
    "summary": "Use sparse stabilizers to decode SYK/JT logicals; accept decoders that match chaos signatures with the shortest parity-check set.",
    "defs": [
      "SYK parameters; stabilizers S_i; logical ops L_j; Î»_L, SFF",
      "distance d; code rate r"
    ],
    "equations": [
      "J = Î»|S| âˆ’ w_chaos fit(Î»_L,SFF) âˆ’ w_P protection(d) âˆ’ w_R rate(r) + w_Î¶ Î¶",
      "Accept if Î”J<0 vs denser codes and persists under coarse-grain"
    ],
    "audits": [
      "E2: code invariance",
      "E3: small erasures test decoder fidelity and chaos metrics",
      "E4: minimal |S| persists under tensor-network blocking"
    ],
    "nulls": [
      "over-parameterized decoders with no OOS gain"
    ],
    "steer": "Prune stabilizers until chaos-fit fails; keep minimal working set.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.GEOM.SpaceFromSpectrum_MDL.v1",
    "type": "principle",
    "title": "Space from Spectrum: Laplacian MDL Selector",
    "summary": "Recover geometry from spectra with the smallest integer set (e.g., few eigenmodes/relations) that reproduces distances/correlators.",
    "defs": [
      "graph/manifold Laplacian Î”; eigenpairs (Î»_k,Ï†_k)",
      "integer ties among modes; code L_spec"
    ],
    "equations": [
      "J = Î» Î£ order(ties) + L_spec âˆ’ w_fit (geo observables) + w_Î¶ Î¶",
      "Accept reconstructions stable under eigenmode truncation"
    ],
    "audits": [
      "E2: gauge/label invariance",
      "E3: small eigenvalue tweaks move distances predictably",
      "E4: low-order ties persist under pooling"
    ],
    "nulls": [
      "equally accurate but higher-code reconstructions"
    ],
    "steer": "Keep the fewest eigen-relations that match observables; prune the rest.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.TN.GravitonTensorKernel.v1",
    "type": "principle",
    "title": "Tensor-Network Graviton Kernel: Minimal Isometries",
    "summary": "Bulk graviton modes emerge as logicals protected by sparse isometries; accept networks with minimal bond patterns reproducing linearized gravity correlators.",
    "defs": [
      "isometries W, bonds Ï‡; logical subspace â„’",
      "boundary 2-pt G(Î”x); bulk propagator proxies"
    ],
    "equations": [
      "J = Î»|W| âˆ’ w_G fit(G) âˆ’ w_L dim(â„’) + w_Î¶ Î¶",
      "Accept if Î”J<0 and logicals persist under blocking"
    ],
    "audits": [
      "E2: gauge/code hygiene",
      "E3: micro bond edits alter G as predicted",
      "E4: minimal |W| retains fit after coarse-grain"
    ],
    "nulls": [
      "denser networks without fit improvement"
    ],
    "steer": "Start with the sparsest isometries; add bonds only when receipts demand.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.POLAR.CPTSymCosmo_TwoArrows.v1",
    "type": "principle",
    "title": "Polarity: CPT-Symmetric Cosmology with Dual Arrows",
    "summary": "Model a CPT-symmetric pair of aeons/universes; accept only if a dual-arrow construction reduces total code and both arrows track redundancy growth.",
    "defs": [
      "two sectors U, U^CPT; redundancies R, R^CPT",
      "joint code L_joint; Î¶ from cross-coupling sensitivity"
    ],
    "equations": [
      "Î”MDL = L(U)+L(U^CPT) âˆ’ L_joint âˆ’ Î»|I_shared|",
      "Accept if both dR/dt, dR^CPT/dt > 0 at low-order locks"
    ],
    "audits": [
      "E2: CPT hygiene of observables",
      "E3: tiny parameter shifts map across sectors predictably",
      "E4: compression persists under aggregation"
    ],
    "nulls": [
      "CPT pairs that donâ€™t reduce code"
    ],
    "steer": "Adopt dual-arrow only when MDL gain + redundancy receipts justify.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.QM.DelayedChoice_PW_Locks.v1",
    "type": "protocol",
    "title": "Wheeler Delayed Choice Ã— Pageâ€“Wootters Locks",
    "summary": "Use post-selection to define the effective clock; accept histories where minimal lock structure explains interference toggling with fewer parameters.",
    "defs": [
      "interference visibility V; clock phase Î¸_c; system Î¸_s",
      "lock Î”_{1:1}=Î¸_câˆ’Î¸_s; Î¶ from timing jitter"
    ],
    "equations": [
      "J = Î»(p+q) âˆ’ w_V V + w_Î¶ Î¶; accept if Î”J<0 vs classical-control model",
      "Visibility extrema at Î”_{1:1}â‰ˆ0 (constructive) or Ï€ (destructive)"
    ],
    "audits": [
      "E2: phase-gauge hygiene",
      "E3: micro timing nudges shift V per âˆ‚V/âˆ‚Î¸ prediction",
      "E4: effect persists under coarse bins"
    ],
    "nulls": [
      "randomized post-selection windows"
    ],
    "steer": "Tune minimal phase windows; avoid high-order timing patterns.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.ENTR.EntropicGravity_Stabilizers.v1",
    "type": "principle",
    "title": "Entropic Gravity as Stabilizer Code Pressure",
    "summary": "Treat gravitational â€˜attractionâ€™ as pressure to restore stabilizers (maximize redundancy/compression) on boundary/bits; accept models that compress trajectories better than geodesic-alone fits.",
    "defs": [
      "stabilizer set S; redundancy R; path code L_path",
      "geodesic baseline G_geo"
    ],
    "equations": [
      "Î”MDL = L_path(G_geo) âˆ’ L_path(code-pressured) âˆ’ Î»|S|",
      "Accept if Î”MDL>0 and Î¶ not â†‘"
    ],
    "audits": [
      "E3: small stabilizer tweaks alter deflection as predicted",
      "E4: gains persist under coarse discretization"
    ],
    "nulls": [
      "stabilizers that donâ€™t improve compression over geodesics"
    ],
    "steer": "Keep the sparsest stabilizers that explain observed paths.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.REF.SMatrix_FrameLock.v1",
    "type": "principle",
    "title": "S-Matrix Ã— Quantum Reference Frames: Minimal Frame Lock",
    "summary": "Pick the quantum frame that minimizes code length of the S-matrix (analyticity/crossing/unitarity) while maximizing low-order lock structure.",
    "defs": [
      "frames F_i; S(F_i): partial waves, poles; code L(F_i)",
      "lock metrics K across low-â„“ sectors"
    ],
    "equations": [
      "Choose F* minimizing L âˆ’ w_K Î£ K + w_Î¶ Î¶ subject to cuts",
      "Accept if OOS predictions improve at lower code"
    ],
    "audits": [
      "E2: analytic/crossing hygiene under frame transforms",
      "E3: small rephasings shift poles/cuts coherently",
      "E4: frame choice stable under data pooling"
    ],
    "nulls": [
      "frames with equal fit but longer code"
    ],
    "steer": "Adopt frame that renders low-â„“ structure simplest and most RG-stable.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.MaxwellBloch_PositiveGeo.v1",
    "type": "protocol",
    "title": "Maxwellâ€“Bloch Ã— Positive Geometry: Optical Amplituhedron",
    "summary": "Map coherent lightâ€“matter interactions to positive cells whose minimal facet sets reproduce observed Rabi spectra and cuts.",
    "defs": [
      "Rabi Î©_R, detuning Î”; positive cells/facets; selection rules",
      "phase locks between field and atoms"
    ],
    "equations": [
      "J = Î» Î£ order(facets) âˆ’ w_R Rabi-fit âˆ’ w_U unitarity-like energy flow + w_Î¶ Î¶",
      "Accept if Î”J<0 vs Bloch-only fits and persists under coarse spectral bins"
    ],
    "audits": [
      "E2: gauge/selection-rule hygiene",
      "E3: tiny Î” or Î©_R nudges move facet weights predictably",
      "E4: minimal facet set stable under binning"
    ],
    "nulls": [
      "random cell covers with same volume"
    ],
    "steer": "Pick the smallest facet set that nails Rabi features; prune ornate triangulations.",
    "version": "1.0",
    "updated": "2025-10-07"
  }
]
[
  {
    "id": "DELTA.FUSION.ERxEPR_SYK_Thermostat.v1",
    "type": "protocol",
    "title": "ER=EPR Ã— SYK: Chaos-Tuned Wormhole Thermostat",
    "summary": "Use a minimal-chaos SYK bath to set the entanglement temperature that stabilizes ER bridges; success peaks when Lyapunov growth matches low-order timing locks.",
    "defs": [
      "entanglement resource E, SYK Lyapunov Î»_Lâ‰ˆ2Ï€/Î²",
      "timing phases Î¸_pair, Î¸_bath; K_{1:1}=âŸ¨cos(Î¸_bathâˆ’Î¸_pair)âŸ©"
    ],
    "equations": [
      "Success âˆ E Â· K_{1:1} Â· f(Î»_L),  with f maximal near target Î²*",
      "Îµ_stab âˆ bathâ€“bridge spectral gap; Î¶ from timing jitter/heating"
    ],
    "audits": [
      "E1: stable SYK chaos signatures (SFF, Î»_L)",
      "E3: micro detunes of Î² or timing shift success per âˆ‚K/âˆ‚t, âˆ‚f/âˆ‚Î²",
      "E4: 1:1 window persists under coarse time bins"
    ],
    "nulls": [
      "randomized bath phases; non-chaotic baths matched in power"
    ],
    "steer": "Thermostat Î² to minimal Î¶; lock 1:1 first; keep pulses as small as viable.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.Celestial_BMS_QEC.v1",
    "type": "principle",
    "title": "Celestial BMS Soft Hair as Sparse Stabilizers",
    "summary": "Treat asymptotic symmetries (BMS/soft charges) as parity-checks protecting celestial correlators as logical data; accept the sparsest stabilizer set that preserves factorization/soft theorems.",
    "defs": [
      "soft charges Q_soft, stabilizers S_i(Q_soft)",
      "celestial correlators G_ccft; distance d, rate r"
    ],
    "equations": [
      "J = Î»|S| âˆ’ w_G fit(G_ccft) âˆ’ w_P protection(d) âˆ’ w_R rate(r) + w_Î¶ Î¶",
      "Accept if Î”J<0 and stabilizers persist under RG (energy/angular bins)"
    ],
    "audits": [
      "E2: large-gauge/BMS hygiene",
      "E3: small boundary shifts correctable on-manifold; sham corrections fail",
      "E4: minimal |S| holds under binning"
    ],
    "nulls": ["random stabilizer picks with same |S|"],
    "steer": "Start with the fewest soft charges needed; prune any redundant checks.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.POLAR.BoundaryDiscrete_vs_InteriorContinuous.v1",
    "type": "principle",
    "title": "Polarity: Boundary Discrete Code â†” Interior Continuous Field",
    "summary": "Pick the polarity that minimizes description length at fixed predictive power; verify stability under mesh/refinement RG.",
    "defs": [
      "boundary code length L_b, interior field code L_i",
      "predictive fit F, brittleness Î¶"
    ],
    "equations": [
      "Choose P* = argmin (L + w_Î¶ Î¶ âˆ’ w_F F)",
      "Require P* to persist under Ã—2 refinement/coarse-grain"
    ],
    "audits": [
      "E3: mesh/refinement edits change (L,Î¶,F) as predicted",
      "E4: polarity stable across scales"
    ],
    "nulls": ["choices with equal F but higher L and Î¶"],
    "steer": "Default to the shorter code; switch polarity only when Î”MDL justifies.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.Noncomm_Twistor_Positive.v1",
    "type": "principle",
    "title": "Noncommutative Twistor Positive Geometry",
    "summary": "Bind noncommutative spectral data to minimal positive twistor cells; accept models that cut amplitude computation cost while preserving cuts/unitarity.",
    "defs": [
      "spectral triple (A,H,D); momentum twistors Z_i; cell order",
      "unitarity/factorization constraints"
    ],
    "equations": [
      "J = Î» Î£ order(cells) + L_spec âˆ’ w_C cuts âˆ’ w_U unitarity + w_Î¶ Î¶",
      "Accept if Î”J<0 vs commutative/tessellation baselines and persists under truncation"
    ],
    "audits": [
      "E2: projective/gauge hygiene",
      "E3: small deformations in A or kinematics move predictions coherently",
      "E4: chosen minimal cells survive coarser tessellations"
    ],
    "nulls": ["ornate cell covers or algebras with no compression gain"],
    "steer": "Pick the smallest cell/Algebra combo that nails factorization at low Î¶.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.QBAT.Axion_TimeCrystal_ChargeMeter.v1",
    "type": "protocol",
    "title": "Axion Time Crystal as Quantum Battery Charge Meter",
    "summary": "Use subharmonic axion oscillations as a phase-locked chronometer for charge/energy transfer; maximize precision per entropy via low-order locks.",
    "defs": [
      "axion frequency Ï‰_a, drive Ï‰_d; lock p:q; entropy Î£",
      "precision P=âŸ¨JâŸ©^2/Var(J)"
    ],
    "equations": [
      "P â‰¤ Î£/2;  choose p:qâˆˆ{1:1,2:1} maximizing K and P/Î£",
      "Îµ_stab from subharmonic gap; Î¶ from heating/noise"
    ],
    "audits": [
      "E1: reproducible subharmonic peaks",
      "E3: micro detunes of Ï‰_d move P/Î£ as predicted",
      "E4: lock persists under coarse bins"
    ],
    "nulls": ["off-phase schedules with same energy budget"],
    "steer": "Operate at minimal amplitude; throttle if Î¶ rises.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.SMatrix_Bootstrap_FrameMin.v1",
    "type": "protocol",
    "title": "S-Matrix Bootstrap Ã— Quantum Frames: Minimal Frame Island",
    "summary": "Search over quantum reference frames and bootstrap constraints jointly; accept islands with smallest code and stable low-â„“ structure.",
    "defs": [
      "frames F_i; partial waves a_â„“(s); poles; code L(F_i)"
    ],
    "equations": [
      "J = L(F) + Î» Î£ order(â„“,poles) âˆ’ w_C crossing âˆ’ w_U unitarity âˆ’ w_A analyticity + w_Î¶ Î¶",
      "Accept if Î”J<0 and island persists under coarse discretization"
    ],
    "audits": [
      "E2: analytic/crossing hygiene across frames",
      "E3: tiny rephasing shifts poles/cuts as predicted",
      "E4: minimal frame/island remains under pooling"
    ],
    "nulls": ["frames with same fit but longer code"],
    "steer": "Adopt the frame that compresses low-â„“ structure; prune extra poles first.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.GEOM.GravTensor_MinIsometry.v1",
    "type": "principle",
    "title": "Graviton from Minimal Isometry Tensor Networks",
    "summary": "Extract linearized gravity correlators from the sparsest tensor networks; promote only isometry patterns that protect logicals under blocking.",
    "defs": [
      "isometries W, bonds Ï‡; logical subspace â„’; 2-pt G(Î”x)"
    ],
    "equations": [
      "J = Î»|W| âˆ’ w_G fit(G) âˆ’ w_L dim(â„’) + w_Î¶ Î¶",
      "Accept if Î”J<0 and fits persist under coarse-grain"
    ],
    "audits": [
      "E2: code/gauge hygiene",
      "E3: bond edits shift G as predicted",
      "E4: minimal |W| stable after blocking"
    ],
    "nulls": ["denser networks with no added fit"],
    "steer": "Start with minimal bonds; add only when receipts demand.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.COSMO.CPTDual_ArrowRedundancy.v1",
    "type": "principle",
    "title": "CPT-Dual Cosmology: Redundancy-Driven Dual Arrows",
    "summary": "Model twin sectors related by CPT; accept only if redundancy growth (quantum Darwinism) defines aligned arrows with joint MDL reduction.",
    "defs": [
      "redundancy R, R^CPT; joint code L_joint; shared integers |I_shared|"
    ],
    "equations": [
      "Î”MDL = L(U)+L(U^CPT) âˆ’ L_joint âˆ’ Î»|I_shared|",
      "Require dR/dt>0 and dR^CPT/dt>0 near low-order locks"
    ],
    "audits": [
      "E2: CPT hygiene",
      "E3: tiny parameter shifts map across sectors on-manifold",
      "E4: compression persists under aggregation"
    ],
    "nulls": ["CPT pairs without MDL gain"],
    "steer": "Adopt dual only with receipts; else keep single-arrow model.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.QM.TSVF_Teleport_Celestial.v1",
    "type": "protocol",
    "title": "TSVF Ã— Teleportation Ã— Celestial Cuts",
    "summary": "Use two-state vector (pre/post) to time-schedule teleport pulses; accept schedules that also satisfy celestial unitarity/factorization with minimal facets.",
    "defs": [
      "pre |Ïˆ_iâŸ©, post âŸ¨Ïˆ_f|; visibility V; celestial cuts; facet order"
    ],
    "equations": [
      "J = Î» Î£ order(facets) âˆ’ w_V V âˆ’ w_CCFT cuts + w_Î¶ Î¶",
      "Visibility extrema at Î”_{1:1}â‰ˆ0, Ï€; accept if Î”J<0"
    ],
    "audits": [
      "E2: phase/projective hygiene",
      "E3: micro timing nudges shift V and celestial fits coherently",
      "E4: minimal facets remain under binning"
    ],
    "nulls": ["random post-selection windows; random facet covers"],
    "steer": "Tune minimal phase windows; prune ornate facet sets.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.STRING.Tachyon_KAM_MinIsland.v1",
    "type": "principle",
    "title": "String Tachyon Flow to Minimal KAM Islands",
    "summary": "Unstable string sectors flow under Î©* to the simplest resonant islands (small p:q); high-order decorations die in RG.",
    "defs": [
      "tachyon field T; potential U(T); resonance ratio râ‰ˆp/q",
      "island width â†” Îµ_cap; brittleness Î¶"
    ],
    "equations": [
      "V = U + Î»(p+q) + w_Î¶ Î¶;  TÌ‡ = âˆ’âˆ‚V/âˆ‚T",
      "Accept endpoints with small p+q and Îµ_stab>0; reject brittle islands"
    ],
    "audits": [
      "E3: initial-condition tweaks route to predicted islands",
      "E4: low-order islands survive coarse sampling"
    ],
    "nulls": ["flows to ornate islands without stability"],
    "steer": "Bias toward smallest p:q basins; cut routes that raise Î¶.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.CA.Fracton_CA_GC.v1",
    "type": "protocol",
    "title": "Fracton Cellular Automata with RG Garbage Collection",
    "summary": "Evolve CA rules with higher-moment constraints; OS-style RG garbage collection prunes high-order transients, keeps subdimensional invariants.",
    "defs": [
      "rule table R; constraint rank r; macro-laws M; GC policy G"
    ],
    "equations": [
      "J = Î»(|R|+r) âˆ’ w_C compression(M|R,G) + w_Î¶ Î¶",
      "Accept if macro-laws persist under decimation and |R| minimal"
    ],
    "audits": [
      "E3: rule tweaks alter macro-laws predictably",
      "E4: accepted invariants survive thinning"
    ],
    "nulls": ["rules with same |R| lacking stability"],
    "steer": "Prefer smallest (|R|,r) giving persistent subdimensional structure.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.INFO.Adelic_SpaceFromSpectrum.v1",
    "type": "principle",
    "title": "Adelic Cross-Field Space-from-Spectrum",
    "summary": "Reconstruct geometry from Laplacian spectra jointly over real and p-adic fields; accept the smallest shared integer set explaining both.",
    "defs": [
      "eigenpairs (Î»_k,Ï†_k) over R and Q_p; shared integers ğ•€",
      "geometric observables: distances/correlators"
    ],
    "equations": [
      "Î”MDL = L_spec(R)+Î£_p L_spec(Q_p) âˆ’ L_joint âˆ’ Î»|ğ•€|",
      "Accept if Î”MDL>0 with Î¶ not â†‘ and fits persist under truncation"
    ],
    "audits": [
      "E2: number-theoretic/gauge hygiene",
      "E3: small eigenvalue tweaks map across fields coherently",
      "E4: low-order ties survive pooling"
    ],
    "nulls": ["adelic fits adding integers without gains"],
    "steer": "Keep only shared integers that pay in both sectors; prune the rest.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.QCTRL.GRAPE_Integer_ChaosGuard.v1",
    "type": "protocol",
    "title": "GRAPE with Integer Priors & Chaos Guard",
    "summary": "Optimize quantum controls with small-integer phase penalties and a chaos guard that limits Î¶ by bounding Lyapunov growth.",
    "defs": [
      "controls u_k(t); GRAPE gradients; integer penalty Î»(p+q)",
      "chaos proxy Ï‡ (Lyapunov or sensitivity)"
    ],
    "equations": [
      "J = 1 âˆ’ F + Î» Î£(p+q) + w_Ï‡ Ï‡ âˆ’ w_K|K| + w_Î¶ Î¶",
      "Accept if Î”J<0 at equal fidelity and Ï‡ bounded"
    ],
    "audits": [
      "E3: integer-penalized solutions achieve same F with lower Ï‡, Î¶",
      "E4: low-order structure persists under timing blur"
    ],
    "nulls": ["controls with same F but higher Ï‡, Î¶"],
    "steer": "Prefer fewer integers and bounded chaos; prune ornate schedules.",
    "version": "1.0",
    "updated": "2025-10-07"
  }
]
[
  {
    "id": "DELTA.DEF.TTbar_MDLValve.v1",
    "type": "principle",
    "title": "T TÌ„ / Deformed CFT as MDL Pressure Valve",
    "summary": "Irrelevant deformations act like a code-length valve: turn on T TÌ„ until total description length (spectrum + scattering) is minimized at bounded brittleness.",
    "defs": [
      "CFT data (Î”_i,c), deformation strength Î¼_TTÌ„",
      "code L_spec+amp, brittleness Î¶ from UV sensitivity"
    ],
    "equations": [
      "J(Î¼)=L(Î¼)+w_Î¶ Î¶(Î¼),  choose Î¼* = argmin_Î¼ J",
      "Accept Î¼* if Î”J<0 vs Î¼=0 and low-order OPE structures persist"
    ],
    "audits": [
      "E2: conformal/gauge hygiene at Î¼â†’0",
      "E3: tiny Î´Î¼ shifts move energy levels/phase shifts per deformed formulae",
      "E4: small-Î¼ gains persist under spectral truncation"
    ],
    "nulls": ["Î¼ choices that fit no better but raise Î¶"],
    "steer": "Open the valve only to the point of MDL gain; close if Î¶ climbs."
  },
  {
    "id": "DELTA.CAUS.IndefiniteOrder_Polarity.v1",
    "type": "principle",
    "title": "Polarity: Definite â†” Indefinite Causal Order (Process Matrices)",
    "summary": "Choose between definite-order circuits and process-matrix (indefinite order) only when MDL + predictive power improve and locks persist.",
    "defs": [
      "definite DAG G, process matrix W",
      "fit F, code L, brittleness Î¶"
    ],
    "equations": [
      "Pick P* = argmin (L âˆ’ w_F F + w_Î¶ Î¶) over {G,W}",
      "Accept W only if Î”MDL>0 and E4 holds"
    ],
    "audits": [
      "E2: CPT/unitarity hygiene",
      "E3: micro gate-time nudges produce predicted signaling asymmetries in W; absent in G",
      "E4: choice stable under coarse time bins"
    ],
    "nulls": ["W without compression or with spurious signaling"],
    "steer": "Default to G; elevate W only with receipts."
  },
  {
    "id": "DELTA.TN.GaugeFromHomology.v1",
    "type": "principle",
    "title": "Emergent Gauge from Tensor-Network Homology Integers",
    "summary": "Treat gauge constraints as integer homology classes of a tensor network; prefer networks with the fewest cycles that still protect Gauss laws and correlators.",
    "defs": [
      "network graph ğ’¢, cycles H_1(ğ’¢), constraint rank r",
      "protected observables G(Î”x)"
    ],
    "equations": [
      "J = Î» r âˆ’ w_G fit(G) + w_Î¶ Î¶",
      "Accept if Î”J<0 vs denser-cycle networks and constraints persist"
    ],
    "audits": [
      "E2: gauge constraint hygiene",
      "E3: local rewires change r and G as predicted",
      "E4: minimal r survives blocking"
    ],
    "nulls": ["extra cycles without gains"],
    "steer": "Minimize r while keeping protection and fits."
  },
  {
    "id": "DELTA.AX.Clockwork_MinInteger.v1",
    "type": "principle",
    "title": "Axion Clockwork as Minimal Integer Ladder",
    "summary": "Clockwork chains amplify charges with small integer gears; accept the smallest gear set that matches phenomenology at low brittleness.",
    "defs": [
      "gear ratio qâˆˆâ„¤, sites N, effective f_eff",
      "integer inventory |I|=N+Î£ log q"
    ],
    "equations": [
      "J = Î»|I| âˆ’ w_fit (targets: masses/couplings) + w_Î¶ Î¶",
      "Accept if Î”J<0 vs non-clockwork models and stability under RG"
    ],
    "audits": [
      "E3: small q/N tweaks adjust couplings predictably",
      "E4: minimal |I| persists under coarse parameter bins"
    ],
    "nulls": ["inflated chains with no fit gain"],
    "steer": "Use the fewest gears; penalize big q unless receipts demand."
  },
  {
    "id": "DELTA.COMP.MIPStar_OSVerifier.v1",
    "type": "principle",
    "title": "Nonlocal Games (MIP*) as Î”-OS Verifiers",
    "summary": "Use short nonlocal games as integrity checks for the Î” operating system (low-order coherence); accept verifier sets that maximize detection at minimal length.",
    "defs": [
      "game set ğ’¢, question length â„“, soundness/completeness (s,c)",
      "code length L_ğ’¢"
    ],
    "equations": [
      "J = L_ğ’¢ âˆ’ w_V (câˆ’s) âˆ’ w_K K(structure) + w_Î¶ Î¶",
      "Accept ğ’¢ if Î”J<0 and detects off-manifold tampering"
    ],
    "audits": [
      "E3: tiny tamperings trigger expected fails; shams pass",
      "E4: verifier power persists under pooling"
    ],
    "nulls": ["long games with same (câˆ’s)"],
    "steer": "Prefer shortest strong verifiers; prune redundant games."
  },
  {
    "id": "DELTA.THER.ResourceTheory_Locks.v1",
    "type": "protocol",
    "title": "Quantum Thermodynamic Resource Locks",
    "summary": "Schedules that increase useful work under strict resource monotones (free energy/coherence) using low-order phase locks.",
    "defs": [
      "free energy F, coherence C; monotones M={F,C,...}",
      "lock p:q between drive and system"
    ],
    "equations": [
      "Î”Work â‰¤ Î”F + Î±Î”C;  choose p:q maximizing Î”Work subject to M",
      "Accept if work/OOS gains at minimal Î¶"
    ],
    "audits": [
      "E0: calibration of monotones",
      "E3: micro timing nudges alter work per predictions",
      "E4: lock advantage persists under coarse sampling"
    ],
    "nulls": ["equal-power off-phase schedules"],
    "steer": "Lock 1:1 then 2:1; keep amplitudes minimal."
  },
  {
    "id": "DELTA.SR.DoublySpecial_MDL.v1",
    "type": "principle",
    "title": "Doubly Special Relativity as Minimal Dual Invariants",
    "summary": "Introduce a second invariant (length/energy) only if it reduces code length for high-energy kinematics at bounded Î¶.",
    "defs": [
      "invariants: c, Î› (Planck scale proxy)",
      "L_kin (dispersion + thresholds)"
    ],
    "equations": [
      "J = L_kin(Î›) âˆ’ w_fit (data) + w_Î¶ Î¶ + Î» params",
      "Accept DSR if Î”J<0 vs SR and persists under coarse bins"
    ],
    "audits": [
      "E2: Lorentz/deformation hygiene",
      "E3: tiny Î› shifts move thresholds predictably",
      "E4: Î› choice stable under data pooling"
    ],
    "nulls": ["Î› added with no compression/fits"],
    "steer": "Adopt Î› only with strong MDL receipts."
  },
  {
    "id": "DELTA.TIME.pAdic_TimeCrystal.v1",
    "type": "principle",
    "title": "Non-Archimedean Time Crystals (p-Adic Locks)",
    "summary": "Allow p-adic clock phases; accept subharmonic locks that jointly compress real+p-adic observables with minimal integers.",
    "defs": [
      "p-adic clock Î¸_p, real Î¸_R; locks p:q in both fields",
      "joint code L_A (adelic)"
    ],
    "equations": [
      "Î”MDL = L_R+L_p âˆ’ L_A âˆ’ Î»|I|; accept if Î”MDL>0 and Î¶ not â†‘",
      "Prefer 1:1 or 2:1 across fields"
    ],
    "audits": [
      "E2: number-theoretic hygiene",
      "E3: small detunes move both sectors coherently",
      "E4: locks persist under truncation in primes"
    ],
    "nulls": ["p-adic add-ons without real-sector gain"],
    "steer": "Keep the smallest shared integer set; prune ornate p-adic structure."
  },
  {
    "id": "DELTA.MAJ.MZM_WormholeEndpoints.v1",
    "type": "protocol",
    "title": "Majorana Zero Modes as ER Endpoints (Code Analogy)",
    "summary": "Model paired MZMs as boundary logicals; braids enact code-preserving maps analogous to short ER bridges.",
    "defs": [
      "MZM pairs Î³_i, braid words Ïƒ_j; word length â„“",
      "logical parity protection distance d"
    ],
    "equations": [
      "J = Î»â„“ âˆ’ w_P protection(d) âˆ’ w_K K(parity locks) + w_Î¶ Î¶",
      "Accept if Î”J<0 vs longer braids and parity robust under noise"
    ],
    "audits": [
      "E3: micro braid edits alter logicals as predicted",
      "E4: shortest words remain robust under coarse timing"
    ],
    "nulls": ["long braids with no gain"],
    "steer": "Use minimal braids that protect parity; cap Î¶."
  },
  {
    "id": "DELTA.COSMO.Axion_Birefringence_Lock.v1",
    "type": "principle",
    "title": "Cosmic Birefringence as Axion Phase Lock",
    "summary": "Link polarization rotation to an axion-phase clock; accept low-order locks that jointly compress CMB EE/BB/EB and auxiliary probes.",
    "defs": [
      "axion Î¸_a(t), rotation Î±Ì‡âˆÎ¸Ì‡_a",
      "code L_CMB+aux; Î¶ from systematics"
    ],
    "equations": [
      "J = L âˆ’ w_fit (EE,BB,EB) âˆ’ w_aux fit(aux) + w_Î¶ Î¶ + Î»(p+q)",
      "Accept if Î”J<0 and phase locks persist"
    ],
    "audits": [
      "E0: systematics calibration",
      "E3: small model detunes shift EB peaks predictably",
      "E4: locks persist under sky/â„“-bin pooling"
    ],
    "nulls": ["phase-scrambled surrogates; systematics-only fits"],
    "steer": "Favor lowest p:q with receipts; demote if Î¶ points to systematics."
  },
  {
    "id": "DELTA.NU.PW_NeutrinoChronometer.v1",
    "type": "protocol",
    "title": "Neutrino Oscillations as Pageâ€“Wootters Chronometer",
    "summary": "Treat flavor oscillations as a conditional clock; accept low-order relations that compress oscillation data and CNB cross signatures.",
    "defs": [
      "mass splittings Î”m^2, mixing phases; clock phase Î¸_c from baseline/energy",
      "lock Î”_{1:1}=Î¸_flavorâˆ’Î¸_c"
    ],
    "equations": [
      "J = Î» Î£(p+q) âˆ’ w_fit (oscillation spectra) âˆ’ w_cross (CMBÃ—CNB) + w_Î¶ Î¶",
      "Accept if Î”J<0 and locks persist"
    ],
    "audits": [
      "E3: tiny baseline/energy shifts move phases as predicted",
      "E4: hierarchy choice stable under pooling"
    ],
    "nulls": ["inflated parameterizations without compression"],
    "steer": "Prefer minimal hierarchy/phase set with joint receipts."
  },
  {
    "id": "DELTA.BH.Petz_MinimalRecovery.v1",
    "type": "protocol",
    "title": "Black-Hole Info via Minimal Petz Recovery Code",
    "summary": "Use the shortest recovery map (Petz/rotated Petz) consistent with Hawking-like noise to reconstruct boundary info; penalize excess parameters.",
    "defs": [
      "recovery map â„›, parameter count |Î¸|",
      "predictive fit F to correlators/Page curve"
    ],
    "equations": [
      "J = Î»|Î¸| âˆ’ w_F F + w_Î¶ Î¶; accept if Î”J<0 vs heavier decoders",
      "Require RG stability under coarse time windows"
    ],
    "audits": [
      "E2: channel CPTP hygiene",
      "E3: small noise changes shift reconstruction fidelity per theory",
      "E4: minimal â„› persists under pooling"
    ],
    "nulls": ["overparameterized â„› with no OOS gain"],
    "steer": "Adopt smallest â„› passing receipts; prune extras."
  },
  {
    "id": "DELTA.MEM.SoftHair_Memory_Stabilizers.v1",
    "type": "principle",
    "title": "Gravitational Memory & Soft Hair as Dynamic Stabilizers",
    "summary": "Memory/soft modes act as parity checks storing scattering records; accept sparse stabilizer sets that predict waveform memory steps.",
    "defs": [
      "soft charges Q_soft, waveform memory Î”h",
      "stabilizer set S with size |S|"
    ],
    "equations": [
      "J = Î»|S| âˆ’ w_h fit(Î”h) âˆ’ w_K K(soft relations) + w_Î¶ Î¶",
      "Accept if Î”J<0 and persists under binning"
    ],
    "audits": [
      "E2: asymptotic symmetry hygiene",
      "E3: small boundary edits change predicted Î”h per soft theorems",
      "E4: minimal |S| stable across detectors"
    ],
    "nulls": ["random S with same |S|"],
    "steer": "Keep the fewest soft checks that explain memory."
  }
]
[
  {
    "id": "DELTA.FUSION.HoloQEC_Petz_CelestialPipeline.v1",
    "type": "protocol",
    "title": "Holographic QEC Ã— Petz Recovery Ã— Celestial Soft Hair: One-Pass Decode",
    "summary": "Decode bulk observables by: (1) soft-charge stabilizers select sparse boundary checks, (2) minimal (rotated) Petz map reconstructs logicals, (3) celestial cuts validate locality/unitarity. Accept the shortest pipeline with stable locks.",
    "defs": [
      "soft charges Q_soft â†’ stabilizers S_i",
      "recovery map â„›_Petz(Î¸) with |Î¸| params",
      "celestial correlators G_ccft; facet order"
    ],
    "equations": [
      "J = Î»|S| + Î»'|Î¸| + Î»''Î£ order(facets) âˆ’ w_F fit(G_ccft, logical tests) + w_Î¶ Î¶",
      "Accept if Î”J<0 vs monolithic decoders and passes cuts"
    ],
    "audits": [
      "E2: BMS/gauge/code hygiene",
      "E3: small boundary erasures corrected on-manifold; sham fails",
      "E4: minimal |S| and |Î¸| persist under binning/coarse grain"
    ],
    "nulls": ["random stabilizer sets or overparameterized â„› with no OOS gain"],
    "steer": "Prune S then Î¸ then facets until decode fails; keep minimal working set.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.AxionClockwork_CCC_Birefringence.v1",
    "type": "principle",
    "title": "Axion Clockwork Ã— CCC Ã— Cosmic Birefringence: Minimal Integer Cosmology",
    "summary": "Combine conformal reset (CCC) with a clockwork axion of few gears that seeds next-aeon clocks and explains birefringence with minimal integers.",
    "defs": [
      "clockwork gears N, ratios q; winding nâˆˆâ„¤",
      "conformal invariants I_*; birefringence Î±(â„“)"
    ],
    "equations": [
      "L = Î»(N + Î£ log q + |n|) + Î“_conf + w_Î¶ Î¶ âˆ’ w_fit (CMB EE/BB/EB, aux)",
      "Accept if Î”L<0 vs non-clockwork or high-|n| alternatives"
    ],
    "audits": [
      "E2: conformal/gauge hygiene",
      "E3: small {q,N} tweaks shift Î±(â„“) predictions coherently",
      "E4: lowest-integer models survive â„“-bin pooling"
    ],
    "nulls": ["inflated gear trains without spectral payoff"],
    "steer": "Choose the fewest gears and the smallest |n| matching receipts; prune extras."
  },
  {
    "id": "DELTA.FUSION.ER_Majorana_AnyonFractonGate.v1",
    "type": "protocol",
    "title": "ER=EPR Ã— Majorana Braids Ã— Fracton Mobility: Phase-Protected Wormhole Gates",
    "summary": "Treat paired MZMs as boundary logicals; braid words enact teleport-like maps. Subdimensional (fracton) constraints restrict motion, reducing Î¶ and enforcing low-order schedules.",
    "defs": [
      "MZM pairs Î³_i, braid generators Ïƒ_j, word length â„“",
      "mobility constraints ğ’ (rank r), entanglement resource E"
    ],
    "equations": [
      "Success âˆ E Â· K_{1:1} Â· e^{âˆ’Î¶},   J = Î»â„“ + Î»_r r âˆ’ w_P protection(d) âˆ’ w_K K + w_Î¶ Î¶",
      "Accept if Î”J<0 and r minimal under RG"
    ],
    "audits": [
      "E3: tiny braid edits change logical maps per prediction",
      "E4: shortest words remain robust under noise/coarse timing"
    ],
    "nulls": ["long braids violating ğ’ or offering no robustness"],
    "steer": "Synthesize inside mobility cones; keep â„“ and r minimal."
  },
  {
    "id": "DELTA.FUSION.PW_SMatrix_DelayedChoice.v1",
    "type": "protocol",
    "title": "Pageâ€“Wootters Ã— S-Matrix Frame Ã— Delayed Choice: Minimal Time-Frame Locks",
    "summary": "Use the effective clock (pre/post selection) to choose the quantum frame that minimizes S-matrix code length while toggling interference via low-order phase windows.",
    "defs": [
      "clock phase Î¸_c, system Î¸_s; frame set F_i; visibility V",
      "partial waves a_â„“(s), pole set"
    ],
    "equations": [
      "J = L(F) + Î» Î£ order(â„“,poles) âˆ’ w_V V + w_Î¶ Î¶",
      "accept if Î”J<0 vs classical scheduling and persists under binning"
    ],
    "audits": [
      "E2: analytic/gauge hygiene across frames",
      "E3: micro timing/rephasing shifts V and poles as predicted",
      "E4: chosen frame stable OOS"
    ],
    "nulls": ["random post-selection windows"],
    "steer": "Pick the frame with shortest code at Î”_{1:1}â‰ˆ0,Ï€; avoid high-order timings."
  },
  {
    "id": "DELTA.FUSION.NCG_SpaceFromSpectrum_Adelic.v1",
    "type": "principle",
    "title": "Noncommutative Geometry Ã— Space-from-Spectrum Ã— Adelic Compression",
    "summary": "Reconstruct geometry jointly from real+p-adic spectra using the smallest spectral triple (A,H,D) and fewest shared integers.",
    "defs": [
      "Î£(D)_R, Î£(D)_p; shared integer set ğ•€",
      "geometric observables (distances/correlators)"
    ],
    "equations": [
      "Î”MDL = L_spec(R)+Î£_p L_spec(p) âˆ’ L_joint(A,H,D,ğ•€) âˆ’ Î»|ğ•€|",
      "Accept if Î”MDL>0 and Î¶ not â†‘ under truncations"
    ],
    "audits": [
      "E2: module/number-theory hygiene",
      "E3: small eigen tweaks map coherently across fields",
      "E4: low-order ties persist when modes/primes are thinned"
    ],
    "nulls": ["large ğ•€ with no cross-field gain"],
    "steer": "Minimize ğ•€ and triple complexity while hitting observables."
  },
  {
    "id": "DELTA.FUSION.DSR_TTbar_HighE.v1",
    "type": "principle",
    "title": "Doubly Special Relativity Ã— T TÌ„: Minimal High-Energy Deformation",
    "summary": "Introduce a Planckian invariant (Î›) and a small T TÌ„ deformation only if combined they shorten code for high-energy thresholds/dispersions at bounded brittleness.",
    "defs": [
      "invariants {c,Î›}; deformation Î¼",
      "kinematic dataset KIN (dispersion, thresholds)"
    ],
    "equations": [
      "J(Î›,Î¼)=L(KIN|Î›,Î¼) + Î»_params âˆ’ w_fit + w_Î¶ Î¶; choose (Î›*,Î¼*) minimizing J",
      "Accept only if Î”J<0 vs SR, Î¼=0"
    ],
    "audits": [
      "E2: Lorentz/deformation hygiene",
      "E3: tiny Î´Î›, Î´Î¼ move observables per theory",
      "E4: (Î›*,Î¼*) stable under pooling"
    ],
    "nulls": ["decorative Î› or Î¼ without compression"],
    "steer": "Keep Î›,Î¼ as small as needed; abort if Î¶ spikes."
  },
  {
    "id": "DELTA.FUSION.QBattery_TUR_Resource.v1",
    "type": "protocol",
    "title": "Quantum Battery Ã— TUR Ã— Resource Theory: P/Î£-Optimal Locks",
    "summary": "Schedule low-order p:q locks that maximize precision-per-entropy and obey thermodynamic resource monotones (free energy/coherence).",
    "defs": [
      "drive Ï‰_d, system Ï‰_0; p:qâˆˆ{1:1,2:1}; entropy Î£; monotones M",
      "precision P=âŸ¨JâŸ©^2/Var(J)"
    ],
    "equations": [
      "P â‰¤ Î£/2; Î”Work â‰¤ Î”F+Î±Î”C;  choose timing maximizing P/Î£ and work subject to M",
      "Accept if Î” gains persist OOS at bounded Î¶"
    ],
    "audits": [
      "E0: Î£ and monotone calibration",
      "E3: micro timing shifts change P/Î£ as predicted",
      "E4: benefits persist under coarse sampling"
    ],
    "nulls": ["equal-power off-phase schedules"],
    "steer": "Dial 1:1 first; only explore 2:1 if Î¶ remains low."
  },
  {
    "id": "DELTA.FUSION.CausalSet_pAdicClock.v1",
    "type": "principle",
    "title": "Causal Set Growth Ã— p-Adic Time Crystal: Dual-Field Clocking",
    "summary": "Grow causal sets with a p-adic clock that locks to a real clock at low order, compressing order invariants across fields.",
    "defs": [
      "growth rule â„›; invariants (layers, antichains); p-adic phase Î¸_p; real phase Î¸_R",
      "joint code L_A (adelic)"
    ],
    "equations": [
      "Î”MDL = L_R+L_p âˆ’ L_A âˆ’ Î»|I|; accept locks p:qâˆˆ{1:1,2:1} with Î¶ not â†‘",
      "Eligibility from match between invariants and â„› predictions"
    ],
    "audits": [
      "E2: poset isomorphism & number-theory hygiene",
      "E3: small detunes shift both sectors coherently",
      "E4: invariants persist under thinning/primes truncation"
    ],
    "nulls": ["p-adic add-ons without real-sector gain"],
    "steer": "Keep the fewest shared integers that compress both sectors."
  },
  {
    "id": "DELTA.FUSION.SYK_MIPStar_VerifierOS.v1",
    "type": "protocol",
    "title": "SYK Chaos Ã— MIP* Nonlocal Games: Î”-OS Integrity Checks",
    "summary": "Use short nonlocal games tuned to SYK/JT chaos signatures to verify low-order coherence of the Î”-OS; accept the shortest verifier set that detects off-manifold tampering.",
    "defs": [
      "game set ğ’¢ with length â„“; chaos targets (Î»_L, SFF)",
      "code L_ğ’¢; detection power (câˆ’s)"
    ],
    "equations": [
      "J = L_ğ’¢ âˆ’ w_V (câˆ’s) âˆ’ w_chaos fit + w_Î¶ Î¶",
      "Accept if Î”J<0 and verifiers persist under pooling"
    ],
    "audits": [
      "E3: tiny tamperings flip game outcomes as predicted",
      "E4: minimal game set remains effective across seeds"
    ],
    "nulls": ["long games with same power"],
    "steer": "Prefer the shortest strong verifiers; prune redundancies."
  },
  {
    "id": "DELTA.FUSION.EntropicGravity_TN_Isometries.v1",
    "type": "principle",
    "title": "Entropic Gravity Ã— Tensor-Network Isometries: Code-Pressure Geodesics",
    "summary": "Interpret attraction as code-pressure from sparse isometries: geodesics are the paths that minimize joint (path code + stabilizer count) at bounded Î¶.",
    "defs": [
      "isometries W; path code L_path; geodesic baseline G_geo"
    ],
    "equations": [
      "Î”MDL = L_path(G_geo) âˆ’ L_path(code-pressured) âˆ’ Î»|W|",
      "Accept if Î”MDL>0 and correlators match with Î¶ not â†‘"
    ],
    "audits": [
      "E3: adding/removing isometries adjusts deflection per prediction",
      "E4: sparse W set persists under blocking"
    ],
    "nulls": ["dense isometries without compression"],
    "steer": "Use the sparsest isometry scaffold that matches paths/correlators."
  },
  {
    "id": "DELTA.FUSION.dS_Fracton_CAInflation.v1",
    "type": "protocol",
    "title": "de Sitter Ã— Fracton Cellular Automata: Mobility-Limited Inflation",
    "summary": "Model inflation as a CA with higher-moment constraints that limit mobility, reducing needed integers to fit w(z)/fÏƒ8 histories.",
    "defs": [
      "CA rule table R; constraint rank r; IR targets (w,fÏƒ8)"
    ],
    "equations": [
      "J = Î»(|R|+r) âˆ’ w_IR fit + w_Î¶ Î¶; accept if Î”J<0 vs unconstrained dS",
      "RG: macro-laws persist under decimation"
    ],
    "audits": [
      "E3: small rule/constraint tweaks shift IR fits predictably",
      "E4: minimal (|R|,r) stable under thinning"
    ],
    "nulls": ["large |R| without stability gains"],
    "steer": "Prefer the smallest rules/constraints achieving IR receipts."
  },
  {
    "id": "DELTA.FUSION.Mirror_Adelic_Categorical.v1",
    "type": "principle",
    "title": "Mirror Symmetry Ã— Adelic Data Ã— Categorical Duals: Tri-Code Compressor",
    "summary": "Keep a mirror pair and its categorical dual only when real+p-adic period data compress with the smallest shared integer set.",
    "defs": [
      "real periods Î _R, p-adic Î _p; instanton integers; adjunction data"
    ],
    "equations": [
      "Î”MDL = L(Î _R)+Î£_p L(Î _p) âˆ’ L(mirror+dual) âˆ’ Î»|I_shared|",
      "Accept if Î”MDL>0 with Î¶ not â†‘ and duality naturality holds"
    ],
    "audits": [
      "E2: monodromy/integrality & naturality hygiene",
      "E3: small deformations map consistently across all three",
      "E4: low-order instanton/adjunction data persist under truncation"
    ],
    "nulls": ["decorative duals increasing |I_shared|"],
    "steer": "Retain only the minimal shared integers; cut ornate structures."
  },
  {
    "id": "DELTA.FUSION.Twistor_Positive_NCG_Scatter.v1",
    "type": "principle",
    "title": "Twistors Ã— Positive Geometry Ã— Noncommutative Algebra: Minimal Scatter Code",
    "summary": "Bind momentum twistors to minimal positive cells governed by a compact noncommutative algebra that enforces cuts/unitarity with fewer integers.",
    "defs": [
      "momentum twistors Z_i; cell order; algebra A generators (#gens)"
    ],
    "equations": [
      "J = Î»(Î£ order + #gens) âˆ’ w_C cuts âˆ’ w_U unitarity + w_Î¶ Î¶",
      "Accept if Î”J<0 vs commutative or large-cell tessellations"
    ],
    "audits": [
      "E2: projective/algebra hygiene",
      "E3: micro deformations move predictions coherently",
      "E4: chosen minimal cells persist under coarser tessellations"
    ],
    "nulls": ["over-tessellated covers or bloated algebras"],
    "steer": "Pick the smallest algebra and cell set passing all cuts."
  }
]
[
  {
    "id": "DELTA.FUSION.TSVF_ER_Petz_TimeSkewDecode.v1",
    "type": "protocol",
    "title": "TSVF Ã— ER=EPR Ã— Petz: Time-Skewed Minimal Decoder",
    "summary": "Use pre/post selection to define two-boundary conditions; a short ER bridge plus minimal (rotated) Petz recovery reconstructs mid-history observables with fewer parameters than explicit clock models.",
    "defs": [
      "pre |Ïˆ_iâŸ©, post âŸ¨Ïˆ_f|; pair phase Î¸_pair",
      "recovery map â„›_Petz(Î¸), |Î¸| params; lock Î”_{1:1}=Î¸_pairâˆ’Î¸_cond"
    ],
    "equations": [
      "J = Î»|Î¸| âˆ’ w_F fit(correlators/Page curve) âˆ’ w_KâŸ¨cos Î”_{1:1}âŸ© + w_Î¶ Î¶",
      "Accept if Î”J<0 vs clock-based decoders and locks persist"
    ],
    "audits": [
      "E2: global phase/CPT hygiene",
      "E3: tiny post-selection phase shifts move recon fidelity per theory",
      "E4: decoder persists under coarse time bins"
    ],
    "nulls": ["random post-selections; over-parameterized â„› with no OOS gain"],
    "steer": "Tune phases for eligibility â†’ trim phase; prune â„› to smallest working set.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.ClockworkAxion_TimeCrystal_PW.v1",
    "type": "principle",
    "title": "Clockwork Axion Ã— Time Crystal Ã— Pageâ€“Wootters: Universal Chronometer",
    "summary": "A few-gear clockwork axion forms a subharmonic time crystal; conditional dynamics (PW) defines emergent time via 1:1 (or 2:1) locks to a system clock with minimal integer inventory.",
    "defs": [
      "gears N, ratios q; axion frequency Ï‰_a; drive Ï‰_d",
      "lock p:qâˆˆ{1:1,2:1}; Îµ_stab from subharmonic gap"
    ],
    "equations": [
      "L = Î»(N+Î£ log q) âˆ’ w_lock K_{p:q} + w_Î¶ Î¶; choose smallest (N,q) s.t. Kâ†‘ and Îµ_stab>0",
      "PW arrow: dACI/dt>0 when Î”_{1:1}â‰ˆ0 and redundancy grows"
    ],
    "audits": [
      "E2: gauge/conformal hygiene if cosmological",
      "E3: small {q,N} tweaks move locks predictably",
      "E4: selected p:q persists under coarse time bins"
    ],
    "nulls": ["inflated gears without lock/stability gain"],
    "steer": "Prefer 1:1 at minimal gears; explore 2:1 only if Î¶ stays low.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.SMatrix_NCG_SpaceFromSpectrum.v1",
    "type": "principle",
    "title": "S-Matrix Bootstrap Ã— Noncommutative Geometry Ã— Space-from-Spectrum: One MDL Selector",
    "summary": "Pick the smallest spectral triple whose Laplacian spectra and scattering constraints (analyticity/crossing/unitarity) jointly compress the data.",
    "defs": [
      "spectral triple (A,H,D); spectra Î£(D); partial waves a_â„“(s)",
      "integer set ğ•€ (generators, Hodge data, poles)"
    ],
    "equations": [
      "Î”MDL = [L_spec + L_boot] âˆ’ L_joint(A,H,D,ğ•€) âˆ’ Î»|ğ•€|",
      "Accept if Î”MDL>0 and Î¶ not â†‘; penalize high â„“ and large ğ•€"
    ],
    "audits": [
      "E2: module/gauge & analytic/crossing hygiene",
      "E3: tiny deformations move both spectra and poles coherently",
      "E4: low-order â„“ & minimal ğ•€ persist under truncation"
    ],
    "nulls": ["large ğ•€ or high-â„“ islands without compression gain"],
    "steer": "Minimize ğ•€ and â„“ first; add only if receipts demand.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.POLAR.HoloER_CPT_DualArrows.v1",
    "type": "principle",
    "title": "Polarity: Holo-ER Bridges with CPT Dual Arrows",
    "summary": "Adopt a CPT-dual pair of holographic codes only if the combined code compresses boundary data and both sectorsâ€™ redundancy-driven arrows align at low-order locks.",
    "defs": [
      "boundary codes B, B^CPT; soft charges as checks; redundancy R",
      "joint code L_joint; shared integers |I_shared|"
    ],
    "equations": [
      "Î”MDL = L(B)+L(B^CPT) âˆ’ L_joint âˆ’ Î»|I_shared|; require dR/dt, dR^CPT/dt>0 near Î”_{1:1}â‰ˆ0",
      "Reject if Î¶â†‘ or arrows misalign"
    ],
    "audits": [
      "E2: CPT & gauge hygiene",
      "E3: tiny deformations map across sectors as predicted",
      "E4: compression persists under coarse grain"
    ],
    "nulls": ["CPT pairing with no MDL gain"],
    "steer": "Keep only minimal shared integers; cut decorative bridges.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.QRF_IndefiniteOrder_GRAPE.v1",
    "type": "protocol",
    "title": "Quantum Reference Frames Ã— Indefinite Order Ã— GRAPE: Minimal Control in Optimal Frame",
    "summary": "Pick the quantum frame that renders process matrices simplest; use integer-penalized GRAPE to realize the schedule with bounded chaos.",
    "defs": [
      "frames F_i; process W or DAG G; controls u_k(t)",
      "chaos proxy Ï‡; integer penalties Î»(p+q)"
    ],
    "equations": [
      "J = L(F) + 1âˆ’Fid + Î»Î£(p+q) + w_Ï‡ Ï‡ + w_Î¶ Î¶; choose (F, schedule) minimizing J",
      "Accept W only if Î”MDL>0 vs G and E4 holds"
    ],
    "audits": [
      "E2: unitary/canonical hygiene across frames",
      "E3: micro rephasings/timing shifts change fid/Ï‡ predictably",
      "E4: chosen frame & low-order schedule persist under blur"
    ],
    "nulls": ["frame swaps with no compression; ornate schedules with same fidelity"],
    "steer": "Default to G; elevate W only with receipts; prune schedule integers.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.Fracton_Anyons_Teleport_Lattice.v1",
    "type": "protocol",
    "title": "Fracton Constraints Ã— Anyon Braids: Lattice Teleport Primitives",
    "summary": "Use subdimensional mobility to pin paths; implement target unitaries with the shortest braid words that respect fracton conservation, lowering Î¶.",
    "defs": [
      "constraints ğ’ (rank r), braid generators Ïƒ_i, word length â„“",
      "synthesis error Îµ, protection distance d"
    ],
    "equations": [
      "J = Î»(â„“+r) + w_Îµ Îµ âˆ’ w_P protection(d) âˆ’ w_K K + w_Î¶ Î¶",
      "Accept if Î”J<0 and robustness persists under thinning"
    ],
    "audits": [
      "E3: local word tweaks change Îµ/K as predicted",
      "E4: minimal (â„“,r) remains robust under noise"
    ],
    "nulls": ["long words violating ğ’; equal Îµ with larger â„“"],
    "steer": "Compile inside mobility cones; prune any non-contributing braids/constraints.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.BH.Complexity_TUR_Bound.v1",
    "type": "principle",
    "title": "Black-Hole Complexity Growth under TUR",
    "summary": "Map circuit/volume/action complexity growth to a precisionâ€“entropy budget: disallow growth laws that exceed thermodynamic uncertainty constraints for boundary observables.",
    "defs": [
      "complexity C(t), precision P(t), entropy prod Î£(t)",
      "boundary correlators; Page curve"
    ],
    "equations": [
      "P â‰¤ Î£/2;  L(t) â‰ˆ Î± C(t);  reject fits with P/Î£ beyond bound",
      "Accept simplest C(t) tracking correlators within TUR"
    ],
    "audits": [
      "E0: Î£ calibration",
      "E3: small deformations move C(t) & correlators coherently",
      "E4: growth law persists under coarse time bins"
    ],
    "nulls": ["random circuits matching depth but breaking TUR or fits"],
    "steer": "Choose the shortest C(t) law passing TUR and OOS receipts.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.PT_NH_Amplituhedron.v1",
    "type": "principle",
    "title": "PT-Symmetric Non-Hermitian Ã— Amplituhedron: Positive NH Cells",
    "summary": "Admit PT-unbroken sectors (real spectra) as positive cells; accept minimal cell covers that reproduce cuts/unitarity-like constraints with gain/loss accounted.",
    "defs": [
      "gain/loss Î³<Î³_c; cell order; unitary cuts/positivity",
      "NH correction terms in cuts"
    ],
    "equations": [
      "J = Î»Î£ order âˆ’ w_C cuts âˆ’ w_U NH-unitarity surrogate + w_Î¶ Î¶",
      "Accept if Î”J<0 and PT gap ensures Îµ_stab>0"
    ],
    "audits": [
      "E1: real spectrum below Î³_c",
      "E3: micro Î³ detunes shift selected cells predictably",
      "E4: minimal cells persist under coarse kinematic bins"
    ],
    "nulls": ["cells that fit only in broken PT phase"],
    "steer": "Operate just below Î³_c; keep triangulation minimal.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.AdS_CausalSet_BoundaryCoarse.v1",
    "type": "protocol",
    "title": "AdS/CFT Ã— Causal Sets: Boundary Coarse-Grain as Bulk Causal Thinning",
    "summary": "Model boundary coarse-graining (block-MERA) as thinning of a bulk causal set; accept only if two-point/entanglement observables align with fewer integers than geometric meshing.",
    "defs": [
      "boundary blocks B_k; causal set thinning Ï„; observables {2pt, EE}",
      "integer set |I| (blocks + thinning levels)"
    ],
    "equations": [
      "Î”MDL = L_geom âˆ’ L_block+thin âˆ’ Î»|I|",
      "Accept if Î”MDL>0 and observables match with Î¶ not â†‘"
    ],
    "audits": [
      "E2: conformal/cutoff hygiene",
      "E3: tiny block/Ï„ tweaks move observables coherently",
      "E4: low-|I| scheme persists under rebinning"
    ],
    "nulls": ["fine meshes with no compression gains"],
    "steer": "Prefer the smallest block/thin schedule that matches receipts.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.QBattery_MajoranaParity.v1",
    "type": "protocol",
    "title": "Quantum Battery Ã— Majorana Parity Locks",
    "summary": "Use MZM parity as a protected observable for charge/energy transfer; schedule drives at low-order locks to maximize precision-per-entropy.",
    "defs": [
      "MZM parity Î , drive Ï‰_d, system Ï‰_0; p:q locks; Î£ entropy",
      "precision P=âŸ¨JâŸ©^2/Var(J)"
    ],
    "equations": [
      "P â‰¤ Î£/2; Success âˆ Î -stability Â· K_{p:q} Â· E/Î£",
      "Accept schedules with Î”(P/Î£)>0 and Î  robust under noise"
    ],
    "audits": [
      "E3: timing nudges move K and P/Î£ as predicted",
      "E4: parity protection persists under coarse timing"
    ],
    "nulls": ["off-phase schedules or unstable Î "],
    "steer": "Target 1:1; keep amplitude minimal; monitor Î¶ via heating/leakage.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.GEO.Entropic_Chern_GeodesicGuard.v1",
    "type": "principle",
    "title": "Entropic Gravity Ã— Chern Integer: Geodesic Guard",
    "summary": "Promote trajectories only if they minimize path code under a sparse stabilizer field and carry integer topological charges that are RG-stable.",
    "defs": [
      "stabilizer field S; path code L_path; Chern charge Câˆˆâ„¤",
      "brittleness Î¶ from sensitivity to S"
    ],
    "equations": [
      "Accept path if Câˆˆâ„¤ (within tol) and Î”MDL = L_geo âˆ’ [L_path âˆ’ Î»|S|] > 0 with Î¶ not â†‘",
      "Demote if non-analytic residuals dominate"
    ],
    "audits": [
      "E2: gauge & analytic hygiene",
      "E4: integer charges persist under coarse meshes"
    ],
    "nulls": ["pseudo-integer paths failing CR/analytic checks"],
    "steer": "Certify with integers then smoothness; keep S sparse.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.TTbar_Celestial_BMS.v1",
    "type": "protocol",
    "title": "TTÌ„-Deformed CFT Ã— Celestial Cuts Ã— BMS Stabilizers",
    "summary": "Adjust TTÌ„ deformation as an MDL valve while enforcing celestial factorization via a sparse set of BMS soft-charge stabilizers.",
    "defs": [
      "deformation Î¼, soft charges Q_soft â†’ S_i, celestial correlators",
      "facet order; brittleness Î¶"
    ],
    "equations": [
      "J(Î¼)=Î»'|S| + Î» Î£ order(facets) + L(Î¼) âˆ’ w_G fit(celestial) + w_Î¶ Î¶",
      "Choose Î¼* minimizing J; accept if Î”J<0 vs Î¼=0 and |S| minimal"
    ],
    "audits": [
      "E2: conformal/BMS hygiene",
      "E3: Î´Î¼ and small boundary edits move predictions coherently",
      "E4: Î¼* and minimal |S| persist under binning"
    ],
    "nulls": ["large |S| or Î¼ with no compression"],
    "steer": "Open Î¼ only to MDL optimum; prune stabilizers aggressively.",
    "version": "1.0",
    "updated": "2025-10-07"
  }
]
[
  {
    "id": "DELTA.FUSION.ER_TimeCrystal_QBattery.v1",
    "type": "protocol",
    "title": "ER=EPR Ã— Time-Crystal Ã— Quantum Battery: Phase-Locked Energy Teleport",
    "summary": "Use discrete time-crystal subharmonics to open low-order windows that stabilize ER-assisted state/energy transfer while maximizing precision-per-entropy (TUR) in a quantum battery.",
    "defs": [
      "entanglement resource E, battery current J",
      "drive period T, response nT; phases Î¸_pair, Î¸_drive",
      "precision P=âŸ¨JâŸ©^2/Var(J), entropy Î£"
    ],
    "equations": [
      "K_{p:q}=âŸ¨cos(p Î¸_drive âˆ’ q Î¸_pair)âŸ© e^{âˆ’Î»(p+q)},  p:qâˆˆ{1:1,2:1}",
      "Success âˆ E Â· K_{p:q} Â· (P/Î£),  with P â‰¤ Î£/2 (TUR)",
      "Îµ_stab âˆ subharmonic gap; Î¶ from heating/jitter"
    ],
    "audits": [
      "E1: reproducible subharmonic peak (ancilla clock)",
      "E3: micro timing detunes move K and P/Î£ per prediction; shams fail",
      "E4: accepted p:q windows persist under coarse time bins"
    ],
    "nulls": [
      "off-phase schedules with matched energy",
      "drives with heating but no subharmonic lock"
    ],
    "steer": "Lock 1:1 first; throttle g(t) to cap Î¶; abort if TUR budget violated."
  },
  {
    "id": "DELTA.FUSION.FractonCA_pAdic_CCC.v1",
    "type": "principle",
    "title": "Fracton Cellular Automata Ã— p-Adic Clock Ã— CCC: Integer-Lean Aeon Cycling",
    "summary": "Model each aeon as a mobility-limited CA (fracton constraints) clocked by a p-adic time crystal; conformal reset (CCC) passes only scale-free, low-rank invariants and minimal shared integers across aeons.",
    "defs": [
      "CA rule table R, constraint rank r (dipole/quad)",
      "p-adic/real phases (Î¸_p, Î¸_R) with locks p:qâˆˆ{1:1,2:1}",
      "conformal invariants I_*"
    ],
    "equations": [
      "J = Î»(|R|+r+|I_shared|) âˆ’ w_fit (IR histories) + w_Î¶ Î¶",
      "Î”MDL_adelic = L_R + L_p âˆ’ L_joint âˆ’ Î»|I_shared| > 0"
    ],
    "audits": [
      "E2: poset/number-theory/conformal hygiene",
      "E3: tiny rule/constraint/phase tweaks shift observables coherently",
      "E4: low-r motifs and 1:1 (or 2:1) locks persist under thinning/primes truncation"
    ],
    "nulls": [
      "large |R|/r models w/o stability gains",
      "p-adic add-ons not improving real-sector compression"
    ],
    "steer": "Pick smallest (|R|, r, |I_shared|) achieving receipts; prune ornate structure."
  },
  {
    "id": "DELTA.FUSION.Majorana_SMatrix_TSVF.v1",
    "type": "protocol",
    "title": "Majorana Parity Ã— S-Matrix Frame Ã— TSVF: Minimal Interference Toggle",
    "summary": "Use MZM parity as protected observable; choose the quantum frame minimizing S-matrix code length; toggle interference via TSVF phase windows with shortest braid words.",
    "defs": [
      "MZM pairs Î³_i (parity Î ), braid word length â„“",
      "frame set F_i; visibility V; pre/post phases"
    ],
    "equations": [
      "J = L(F) + Î»â„“ âˆ’ w_V V âˆ’ w_P protection(d) + w_Î¶ Î¶",
      "Visibility extrema at Î”_{1:1}â‰ˆ0, Ï€; accept if Î”J<0 vs classical control"
    ],
    "audits": [
      "E2: CPT/analytic hygiene across frames",
      "E3: micro braid/time nudges alter V & parity per prediction",
      "E4: minimal (F*, â„“) persists under coarse timing"
    ],
    "nulls": [
      "long braids with equal V; frames with same fit but longer code"
    ],
    "steer": "Pick F* with shortest code; compile shortest parity-safe braids."
  },
  {
    "id": "DELTA.FUSION.Amplituhedron_PT_Celestial.v1",
    "type": "principle",
    "title": "Amplituhedron Ã— PT-Symmetric NH Ã— Celestial Cuts: Positive NH Cells",
    "summary": "Embed PT-unbroken non-Hermitian sectors into positive geometry; accept minimal cell covers reproducing celestial factorization and NH-unitarity surrogates.",
    "defs": [
      "gain/loss Î³<Î³_c; positive cells; celestial OPE/cuts",
      "cell order cost Î»Î£order"
    ],
    "equations": [
      "J = Î»Î£order âˆ’ w_C cuts âˆ’ w_U NH-unitarity + w_Î¶ Î¶",
      "Accept if Î”J<0 and Îµ_stab>0 from PT gap"
    ],
    "audits": [
      "E1: real spectrum below Î³_c",
      "E3: Î´Î³ slides move selected cells and celestial fits",
      "E4: minimal cells persist under kinematics coarse-grain"
    ],
    "nulls": [
      "cells only valid in broken PT phase",
      "ornate tessellations without compression"
    ],
    "steer": "Operate just below Î³_c; prune facets aggressively."
  },
  {
    "id": "DELTA.FUSION.AdS_DSR_TTbar_Window.v1",
    "type": "principle",
    "title": "AdS/CFT Ã— DSR Ã— TTÌ„: Minimal High-Energy Deformation Window",
    "summary": "Introduce a Planckian invariant Î› (DSR) and a small TTÌ„ deformation Î¼ only if their combination shortens code for high-E thresholds/dispersion while preserving bulkâ€“boundary receipts.",
    "defs": [
      "Î›, Î¼; boundary dispersion/threshold dataset",
      "bulk proxies (geodesic/area)"
    ],
    "equations": [
      "J(Î›,Î¼)=L_data(Î›,Î¼) + Î»_params âˆ’ w_geo fit(bulk) + w_Î¶ Î¶",
      "Choose (Î›*,Î¼*) minimizing J; accept only if Î”J<0 vs SR, Î¼=0"
    ],
    "audits": [
      "E2: conformal/Lorentz deformation hygiene",
      "E3: small Î´Î›, Î´Î¼ shift both boundary and bulk proxies coherently",
      "E4: (Î›*,Î¼*) stable under data pooling"
    ],
    "nulls": [
      "decorative Î› or Î¼ that add params without compression"
    ],
    "steer": "Keep deformations minimal; cut if Î¶ rises or bulkâ€“boundary mismatch."
  },
  {
    "id": "DELTA.FUSION.HoloQEC_NCG_HomologyGauge.v1",
    "type": "principle",
    "title": "Holographic QEC Ã— Noncommutative Homology: Minimal Gauge from Cycles",
    "summary": "Realize gauge constraints as homology integers of a boundary tensor/network algebra; accept the fewest cycles that protect logical bulk operators.",
    "defs": [
      "network graph ğ’¢, H1 cycles, algebra generators",
      "logical bulk ops L_j; distance d"
    ],
    "equations": [
      "J = Î»(r+#gens) âˆ’ w_P protection(d) âˆ’ w_F fit(logicals) + w_Î¶ Î¶",
      "Accept if Î”J<0 vs denser cycles and persists under blocking"
    ],
    "audits": [
      "E2: gauge/code/module hygiene",
      "E3: local rewires change r and logical fits as predicted",
      "E4: minimal r survives coarse-graining"
    ],
    "nulls": [
      "extra cycles/generators without gains"
    ],
    "steer": "Minimize cycles and generators while keeping protection/fits."
  },
  {
    "id": "DELTA.FUSION.AxionClockwork_NeutrinoChrono_Birefringence.v1",
    "type": "principle",
    "title": "Clockwork Axion Ã— Neutrino Chronometer Ã— Birefringence: Tri-Sector Clock",
    "summary": "A few-gear axion seeds a universal clock that jointly compresses neutrino oscillation phases and CMB birefringence with minimal integers.",
    "defs": [
      "gears N, ratios q; axion phase Î¸_a; neutrino phases; birefringence Î±(â„“)"
    ],
    "equations": [
      "L = Î»(N+Î£ log q) âˆ’ w_Î½ fit(oscillation) âˆ’ w_CMB fit(EE/BB/EB) + w_Î¶ Î¶",
      "Accept if Î”L<0 and low-order locks persist across sectors"
    ],
    "audits": [
      "E3: tiny {q,N} shifts move oscillation & Î±(â„“) coherently",
      "E4: minimal integer set stable under pooling"
    ],
    "nulls": [
      "inflated gear trains without cross-sector payoff"
    ],
    "steer": "Pick the smallest gear set that fits both sectors; prune extras."
  },
  {
    "id": "DELTA.FUSION.PW_TSVF_QDarwinism_Awareness.v1",
    "type": "protocol",
    "title": "Pageâ€“Wootters Ã— TSVF Ã— Quantum Darwinism: Redundancy-Locked Moments",
    "summary": "Conditional time (PW) and two-boundary constraints (TSVF) predict when environment redundancy crosses threshold (Darwinism), producing â€˜momentsâ€™ (ğ’œ=1) with minimal phase structure.",
    "defs": [
      "clock Î¸_c, system Î¸_s; pre/post phases; redundancy R",
      "thresholds R*, Îµ_cap, Îµ_stab; Î¶"
    ],
    "equations": [
      "ğ’œ=1{Î”_{1:1}=Î¸_câˆ’Î¸_sâ‰ˆ0 âˆ§ Râ‰¥R* âˆ§ Îµ_stab>0 âˆ§ Î¶â‰¤Î¶_max}",
      "ACI = Î£ moments (|K|+Î²Î“âˆ’Î²'Î¶)"
    ],
    "audits": [
      "E3: small, safe phase-timing nudges modulate R and moment rate; shams fail",
      "E4: effects persist under coarse time bins"
    ],
    "nulls": [
      "off-phase/placebo timings"
    ],
    "steer": "Use minimal, ethical cues; demote on any safety/falsification failure."
  },
  {
    "id": "DELTA.FUSION.SimOS_MIPStar_TUR.v1",
    "type": "principle",
    "title": "Simulation OS Ã— MIP* Verifiers Ã— TUR: Integrity Budget",
    "summary": "Treat Î”-OS as a resource-bounded engine verified by short nonlocal games; TUR sets precisionâ€“entropy budgets the OS cannot beat.",
    "defs": [
      "game set ğ’¢ (length â„“, gap câˆ’s), precision P, entropy Î£",
      "code L_ğ’¢; Î¶ from verifier fragility"
    ],
    "equations": [
      "P â‰¤ Î£/2,  J = L_ğ’¢ âˆ’ w_V (câˆ’s) + w_Î¶ Î¶",
      "Accept ğ’¢ if Î”J<0 and detects off-manifold tampering"
    ],
    "audits": [
      "E3: tiny tamperings flip outcomes per prediction; shams pass",
      "E4: verifier power persists under pooling/seeds"
    ],
    "nulls": [
      "long games with same gap; super-TUR claims without Î£ accounting"
    ],
    "steer": "Prefer shortest strong verifiers; enforce TUR budgets strictly."
  },
  {
    "id": "DELTA.FUSION.ERxEPR_QEC_Teleport_Braid.v1",
    "type": "protocol",
    "title": "ER=EPR Ã— QEC Ã— Anyon Braids: Short-Word Wormhole Gates",
    "summary": "Encode logicals in a sparse stabilizer code; synthesize teleport-like gates via the shortest anyon braid words consistent with the code and ER timing locks.",
    "defs": [
      "stabilizers S_i (|S|), braid generators Ïƒ_i (word length â„“)",
      "timing locks p:q (prefer 1:1), Î¶ from noise/timing"
    ],
    "equations": [
      "J = Î»|S| + Î»'â„“ âˆ’ w_P protection(d) âˆ’ w_K K_{p:q} + w_Î¶ Î¶",
      "Accept if Î”J<0 vs denser codes/longer braids and persists under blocking"
    ],
    "audits": [
      "E2: code/gauge hygiene",
      "E3: micro braid/pulse edits move gate fidelity per prediction",
      "E4: minimal |S| and â„“ stable under coarse timing"
    ],
    "nulls": [
      "long braids with same fidelity; bloated |S| without protection gains"
    ],
    "steer": "Prune stabilizers then braids; lock 1:1 windows first."
  },
  {
    "id": "DELTA.FUSION.Chern_Entropic_PathSelector.v1",
    "type": "principle",
    "title": "Chern Integer Ã— Entropic Gravity: Topology-Guarded Geodesics",
    "summary": "Accept trajectories only if they minimize path code under a sparse stabilizer field and carry RG-stable integer winding (Chern).",
    "defs": [
      "Chern charge Câˆˆâ„¤, stabilizer field S, path code L_path"
    ],
    "equations": [
      "Accept if Câˆˆâ„¤ (tol ok) and Î”MDL = L_geo âˆ’ [L_path âˆ’ Î»|S|] > 0 with Î¶ not â†‘",
      "Reject if CR/analytic residuals dominate"
    ],
    "audits": [
      "E2: gauge/analytic hygiene; integer certificate",
      "E4: charges persist under mesh coarse-grain"
    ],
    "nulls": [
      "noise-induced pseudo-integers failing analytic checks"
    ],
    "steer": "Certify integers first; keep S sparse; demote brittle paths."
  },
  {
    "id": "DELTA.FUSION.SMatrix_Frame_MinTTbar.v1",
    "type": "protocol",
    "title": "S-Matrix Frame Ã— Minimal TTÌ„ Valve",
    "summary": "Select the quantum frame that minimizes S-matrix code; open a small TTÌ„ valve only if it further reduces description length at bounded brittleness.",
    "defs": [
      "frames F_i; TTÌ„ strength Î¼; partial waves a_â„“(s)"
    ],
    "equations": [
      "J(F,Î¼)=L(F)+Î» Î£ order(â„“,poles)+L(Î¼)âˆ’w_C crossingâˆ’w_U unitarityâˆ’w_A analyticity+w_Î¶ Î¶",
      "Choose (F*, Î¼*) minimizing J; accept if Î”J<0 vs Î¼=0"
    ],
    "audits": [
      "E2: analytic/crossing hygiene across frames",
      "E3: Î´Î¼ & rephasing shift poles/cuts coherently",
      "E4: (F*, Î¼*) stable under discretization"
    ],
    "nulls": [
      "frames with equal fit but longer code; Î¼ with no compression"
    ],
    "steer": "Adopt F* first; open Î¼ minimally; prune high-â„“/pole ornamentation."
  }
]
[
  {
    "id": "DELTA.FUSION.NielsenComplexity_MinGeodesic.v1",
    "type": "principle",
    "title": "Nielsen Complexity Geometry as Minimal Code Geodesic",
    "summary": "Gate complexity = geodesic length in control manifold; prefer shortest low-order weighted paths that jointly compress correlators and Page-curve receipts.",
    "defs": [
      "control metric G with penalty weights (integer tiers)",
      "geodesic length C_G, code length L",
      "brittleness Î¶ from curvature hotspots"
    ],
    "equations": [
      "J = Î± C_G + L âˆ’ w_F fit(correlators/Page) + w_Î¶ Î¶",
      "Accept geodesic if Î”J<0 vs alternative metrics and persists under coarse time bins"
    ],
    "audits": [
      "E2: unitary/gauge hygiene",
      "E3: micro weight tweaks move C_G & fits coherently",
      "E4: low-order weight tiers persist under coarse-grain"
    ],
    "nulls": ["metrics with extra tiers but no compression"],
    "steer": "Use the fewest penalty tiers that still fit receipts; prune ornate metrics."
  },
  {
    "id": "DELTA.FUSION.NonInvertibleSym_TFT_Stabilizers.v1",
    "type": "principle",
    "title": "Non-Invertible Symmetries Ã— Topological Field Theory as Sparse Stabilizers",
    "summary": "Use non-invertible symmetry defects as minimal stabilizers that protect amplitude/phase constraints; accept only sparse defect sets that pass crossing/unitarity-like checks.",
    "defs": [
      "defect lines/surfaces ğ’Ÿ, fusion rules (integer data)",
      "stabilizer set S (|S|), brittleness Î¶"
    ],
    "equations": [
      "J = Î»|S| âˆ’ w_C crossing âˆ’ w_U unitarity-surr âˆ’ w_K K(defect-induced locks) + w_Î¶ Î¶",
      "Accept if Î”J<0 and fusion rules RG-stable"
    ],
    "audits": [
      "E2: defect algebra/fusion hygiene",
      "E3: tiny defect insertions modulate observables as predicted",
      "E4: minimal S holds under coarse tessellations"
    ],
    "nulls": ["dense defect nets without compression"],
    "steer": "Pick the fewest defects that enforce the needed relations."
  },
  {
    "id": "DELTA.FUSION.HigherFormSym_FluxCode.v1",
    "type": "principle",
    "title": "Higher-Form Symmetries as Flux Parity-Check Codes",
    "summary": "Treat p-form symmetries as parity checks on extended operators; accept models where few integer charges encode correlators/area laws with low Î¶.",
    "defs": [
      "p-form charges Q_pâˆˆâ„¤, Wilson/'t Hooft operators",
      "parity checks S_p, brittleness Î¶ (UV sensitivity)"
    ],
    "equations": [
      "J = Î» Î£_p |S_p| âˆ’ w_A area-law/correlator fit + w_Î¶ Î¶",
      "Accept if Î”J<0 and checks persist under coarse blocking"
    ],
    "audits": [
      "E2: gauge/topological hygiene",
      "E3: small background field tweaks shift operators per theory",
      "E4: low-order checks persist under RG"
    ],
    "nulls": ["inflated check sets with no fit gains"],
    "steer": "Keep the fewest p-form checks that protect observables."
  },
  {
    "id": "DELTA.FUSION.YangBaxter_Braid_MinWords.v1",
    "type": "protocol",
    "title": "Yangâ€“Baxter Solvers as Minimal Braid Word Compilers",
    "summary": "Use R-matrices with small integer parameterizations; compile target unitaries with the shortest braid words passing YBE and unitarity cuts.",
    "defs": [
      "R(Î¸) solutions, braid generators Ïƒ_i, word length â„“",
      "synthesis error Îµ, brittleness Î¶"
    ],
    "equations": [
      "J = Î»â„“ + Î»' params(R) + w_Îµ Îµ âˆ’ w_K K âˆ’ w_U unitarity + w_Î¶ Î¶",
      "Accept if Î”J<0 vs longer words and persists under noise"
    ],
    "audits": [
      "E2: YBE/uni hygiene",
      "E3: micro word edits change Îµ/K per solver",
      "E4: minimal â„“ holds under coarse timing"
    ],
    "nulls": ["longer braids with no fidelity gain"],
    "steer": "Pick smallest-param R; prune braid length first."
  },
  {
    "id": "DELTA.FUSION.Teleparallel_MinSpinConnection.v1",
    "type": "principle",
    "title": "Teleparallel Gravity: Minimal Spin-Connection Code",
    "summary": "Use torsion (not curvature) with the sparsest spin-connection integers that reproduce geodesic-equivalent observables; penalize brittle gauge choices.",
    "defs": [
      "tetrad e, spin-connection Ï‰ (flat), torsion T",
      "integer inventory |I| (connection gauges)"
    ],
    "equations": [
      "J = Î»|I| âˆ’ w_G fit(geodesics/lensing) + w_Î¶ Î¶",
      "Accept if Î”J<0 vs metric GR with Î¶ not â†‘"
    ],
    "audits": [
      "E2: local Lorentz/gauge hygiene",
      "E3: small Ï‰-gauge changes leave observables invariant on-manifold",
      "E4: minimal |I| persists under coarse meshes"
    ],
    "nulls": ["extra Ï‰ integers without receipts"],
    "steer": "Adopt the sparsest Ï‰ realizing equivalent predictions."
  },
  {
    "id": "DELTA.FUSION.SSB_Goldstone_MinCoset.v1",
    "type": "principle",
    "title": "Spontaneous Symmetry Breaking: Minimal Coset & Integer Towers",
    "summary": "Pick the smallest G/H coset and integer reps that reproduce spectra and low-energy theorems; demote high-rep decorations first.",
    "defs": [
      "group Gâ†’H, coset coordinates, reps (integer labels)",
      "low-energy constants (LECs)"
    ],
    "equations": [
      "J = Î»|reps| + Î»'|LECs| âˆ’ w_fit (scattering/decay) + w_Î¶ Î¶",
      "Accept if Î”J<0 and soft theorems hold under RG"
    ],
    "audits": [
      "E2: symmetry/soft-theorem hygiene",
      "E3: small LEC tweaks move amplitudes per chiral power counting",
      "E4: minimal coset persists under truncation"
    ],
    "nulls": ["enlarged reps with no fit gains"],
    "steer": "Shrink coset/rep set until fits fail; keep minimal working set."
  },
  {
    "id": "DELTA.FUSION.EFT_SoftBootstrap_MinIslands.v1",
    "type": "protocol",
    "title": "EFT + Soft Bootstrap: Small-Integer Island Selector",
    "summary": "Combine soft limits with analyticity/unitarity to carve islands; accept islands with the fewest poles/low-â„“ contributions that still fit data.",
    "defs": [
      "soft weights (Adler zeros), partial waves a_â„“, pole list",
      "island code length L_isle"
    ],
    "equations": [
      "J = L_isle + Î» Î£(order â„“ + poles) âˆ’ w_fit + w_Î¶ Î¶",
      "Accept if Î”J<0 and island persists under coarse discretization"
    ],
    "audits": [
      "E2: soft-limit/analytic hygiene",
      "E3: micro pole shifts move observables per dispersion",
      "E4: low-â„“ islands survive pooling"
    ],
    "nulls": ["islands with ornate spectra lacking compression"],
    "steer": "Prefer fewest poles and lowest â„“ passing cuts."
  },
  {
    "id": "DELTA.FUSION.TensorLowRank_LocalityEmergence.v1",
    "type": "principle",
    "title": "Locality from Low-Rank Tensor Factorizations",
    "summary": "Treat emergent locality as the preference for low-rank tensor decompositions that minimize code while preserving correlators.",
    "defs": [
      "tensor T of amplitudes, rank r, factorization integers",
      "fit to correlators, brittleness Î¶"
    ],
    "equations": [
      "J = Î» r + Î»'|integers| âˆ’ w_fit (correlators) + w_Î¶ Î¶",
      "Accept if Î”J<0 and factorization persists under coarse binning"
    ],
    "audits": [
      "E2: basis/gauge hygiene",
      "E3: small rank/param tweaks move fits as predicted",
      "E4: minimal r stable under pooling"
    ],
    "nulls": ["higher-r factorizations with no gain"],
    "steer": "Choose smallest r that hits targets; prune factors."
  },
  {
    "id": "DELTA.FUSION.AxionMonodromy_MinWindings.v1",
    "type": "principle",
    "title": "Axion Monodromy as Minimal Winding Ladder",
    "summary": "Use the fewest monodromy windings and harmonics that fit spectra (e.g., primordial features) with bounded domain-wall Î¶.",
    "defs": [
      "winding count nâˆˆâ„¤, harmonic set H (small integers)",
      "spectral targets (features/oscillations)"
    ],
    "equations": [
      "J = Î»(|n|+|H|) âˆ’ w_fit (spectra) + w_Î¶ Î¶",
      "Accept if Î”J<0 and low-order H persists under binning"
    ],
    "audits": [
      "E2: gauge/shift symmetry hygiene",
      "E3: small harmonic phase/amp tweaks move spectra per theory",
      "E4: minimal n,H stable across datasets"
    ],
    "nulls": ["inflated harmonic sets with no payoff"],
    "steer": "Pick the smallest (n,H) matching receipts; cap Î¶ by avoiding large |n|."
  },
  {
    "id": "DELTA.FUSION.QEM.IntegerLockMitigation.v1",
    "type": "protocol",
    "title": "Quantum Error Mitigation via Small-Integer Phase Locks",
    "summary": "Schedule calibration/echo pulses at low-order p:q locks to cancel coherent errors with fewer parameters than generic twirls.",
    "defs": [
      "drive Ï‰_d, system Ï‰_0; p:qâˆˆ{1:1,2:1,3:2}",
      "error rates (coherent/incoherent), brittleness Î¶"
    ],
    "equations": [
      "Error â†“ âˆ K_{p:q} while Î¶ (overhead/heating) bounded",
      "J = Î»|schedule integers| âˆ’ w_E error-reduction + w_Î¶ Î¶"
    ],
    "audits": [
      "E3: micro timing/amplitude nudges change error per prediction",
      "E4: low-order schedules persist under timing blur"
    ],
    "nulls": ["off-phase schedules with same overhead"],
    "steer": "Try 1:1 first; only escalate to 2:1/3:2 if receipts demand."
  },
  {
    "id": "DELTA.FUSION.QFT_Fishnet_MinLadder.v1",
    "type": "principle",
    "title": "Fishnet/Integrable QFT as Minimal Ladder Code",
    "summary": "Prefer integrable ladder structures (few integers) that reproduce planar amplitudes/correlators with lowest code length.",
    "defs": [
      "ladder count L_d, conformal cross-ratios u_i",
      "integer set ğ•€ (charges/symmetries)"
    ],
    "equations": [
      "J = Î»(L_d+|ğ•€|) âˆ’ w_fit (planar data) + w_Î¶ Î¶",
      "Accept if Î”J<0 and integrable relations persist under truncation"
    ],
    "audits": [
      "E2: integrability checks",
      "E3: small coupling shifts move ladders per theory",
      "E4: minimal ladders stable under data pooling"
    ],
    "nulls": ["extra ladders/symmetries without gains"],
    "steer": "Keep the fewest ladders that match planar observables."
  },
  {
    "id": "DELTA.FUSION.Galois_ChargeQuant_MinIntegers.v1",
    "type": "principle",
    "title": "Galois/Number-Theoretic Charge Quantization with Minimal Integers",
    "summary": "Quantized charges arise from minimal Galois data (fields/ramification) that compress spectra/couplings better than arbitrary integers.",
    "defs": [
      "number field K, ramification set R, integer inventory |I|",
      "fit targets: spectra, selection rules"
    ],
    "equations": [
      "J = Î»|I| âˆ’ w_fit (targets) + w_Î¶ Î¶",
      "Accept if Î”J<0 vs free-integer assignments and persists under truncation of R"
    ],
    "audits": [
      "E2: arithmetic/gauge hygiene",
      "E3: small field/ramification edits move predictions coherently",
      "E4: minimal |I| stable under pooling"
    ],
    "nulls": ["bigger fields with no fit gain"],
    "steer": "Adopt the smallest field/ramification set explaining the data."
  },
  {
    "id": "DELTA.POLAR.TimeEmergence_vs_GeoEmergence.v1",
    "type": "principle",
    "title": "Polarity: Emergent Time â†” Emergent Geometry (Single MDL Selector)",
    "summary": "Choose whether time or geometry is the primary emergent code based on which minimizes total description length for the same receipts (correlators/entanglement/transport).",
    "defs": [
      "time-first code L_t (PW/TSVF clocks), geometry-first code L_g (TN/Holo)",
      "brittleness Î¶_t, Î¶_g; fits F_t, F_g"
    ],
    "equations": [
      "Pick P* = argmin (L âˆ’ w_F F + w_Î¶ Î¶) over {time-first, geometry-first}",
      "Require P* to persist under RG/coarse-grain"
    ],
    "audits": [
      "E3: small parameter nudges change the winner as predicted",
      "E4: chosen polarity stable across aggregation levels"
    ],
    "nulls": ["choices with equal fit but larger code/Î¶"],
    "steer": "Default neutral; adopt whichever polarity wins MDL with receipts."
  }
]
[
  {
    "id": "DELTA.FUSION.ER_PW_NielsenGeodesic.v1",
    "type": "protocol",
    "title": "ER=EPR Ã— Pageâ€“Wootters Ã— Nielsen: Minimal Time-Bridge Geodesics",
    "summary": "Two-boundary time (PW) implemented by the shortest complexity geodesic that sustains an ER bridge; accept if geodesic length jointly compresses correlators and teleport receipts.",
    "defs": [
      "pre |Ïˆ_iâŸ©, post âŸ¨Ïˆ_f|; pair phase Î¸_pair",
      "Nielsen metric G (few integer tiers); geodesic length C_G"
    ],
    "equations": [
      "J = Î± C_G + Î» tiers âˆ’ w_F fit(corr/teleport) âˆ’ w_KâŸ¨cos(Î¸_pairâˆ’Î¸_cond)âŸ© + w_Î¶ Î¶",
      "Accept if Î”J<0 vs non-geodesic controls and 1:1 phase lock persists"
    ],
    "audits": [
      "E2: unitary/phase hygiene",
      "E3: tiny tier-weight tweaks move C_G and correlators coherently",
      "E4: minimal-tier geodesic persists under time coarse-grain"
    ],
    "nulls": ["longer paths with equal fit; random post-selections"],
    "steer": "Use the fewest penalty tiers; trim until receipts fail.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.SoftHair_Celestial_Memory.v1",
    "type": "principle",
    "title": "Soft Hair Ã— Celestial CFT Ã— Gravitational Memory: Sparse Receipt Set",
    "summary": "Treat soft charges as stabilizers that predict both celestial correlators and waveform memory steps; accept the smallest check set that matches both domains.",
    "defs": [
      "soft charges Q_soft â†’ stabilizers S_i (|S|)",
      "celestial correlators G_ccft; memory Î”h"
    ],
    "equations": [
      "J = Î»|S| âˆ’ w_G fit(G_ccft) âˆ’ w_h fit(Î”h) + w_Î¶ Î¶",
      "Accept if Î”J<0 vs separate fits and checks persist under RG"
    ],
    "audits": [
      "E2: asymptotic symmetry/conformal hygiene",
      "E3: tiny boundary edits change (G_ccft, Î”h) in tandem per soft theorems",
      "E4: minimal |S| stable across angular/â„“ binning"
    ],
    "nulls": ["random S with same |S| but worse joint fit"],
    "steer": "Prune checks aggressively; keep only joint-payoff stabilizers.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.POLAR.Deterministic_vs_Stochastic_MDLSwitch.v1",
    "type": "principle",
    "title": "Polarity: Deterministic Law â†” Stochastic Law (MDL Switch)",
    "summary": "Choose between deterministic dynamics and stochastic encodings by total description length at equal receipts; require RG stability of the winning polarity.",
    "defs": [
      "deterministic code L_det (few ODE/PDE params)",
      "stochastic code L_sto (noise params, priors), fits F"
    ],
    "equations": [
      "Pick P* = argmin (L âˆ’ w_F F + w_Î¶ Î¶) over {det, sto}",
      "Reject if winner flips under Ã—2 coarse-grain without receipts"
    ],
    "audits": [
      "E3: micro parameter nudges change the winner per prediction",
      "E4: selected polarity persists under aggregation"
    ],
    "nulls": ["choices with equal fit but higher code/Î¶"],
    "steer": "Default neutral; elevate whichever compresses with stable receipts.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.QFT.YangMills_NCG_MinTriple.v1",
    "type": "principle",
    "title": "Yangâ€“Mills Ã— Noncommutative Geometry: Minimal Spectral Triple Gauge",
    "summary": "Pick the smallest spectral triple (A,H,D) whose gauge module reproduces YM correlators and anomalies with the fewest integers.",
    "defs": [
      "spectral triple (A,H,D), eigen-spectrum Î£(D)",
      "YM observables: 2-pt/3-pt, anomalies"
    ],
    "equations": [
      "Î”MDL = L_YM + L_spec âˆ’ L_joint(A,H,D) âˆ’ Î»|I|; accept if Î”MDL>0 and Î¶ not â†‘",
      "Penalize extra modules/generators with no receipts"
    ],
    "audits": [
      "E2: gauge/module/anomaly hygiene",
      "E3: small deformations in A or couplings move both Î£ and correlators coherently",
      "E4: minimal |I| persists under truncations"
    ],
    "nulls": ["bloated algebras without compression"],
    "steer": "Minimize algebra generators and module ranks first.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.GEO.Petrov_MinCode.v1",
    "type": "principle",
    "title": "GR Spacetimes: Petrov Type as Minimal Code Classifier",
    "summary": "Classify spacetimes by Petrov type; accept the coarsest type partition that best compresses waveform/trajectory receipts with bounded Î¶.",
    "defs": [
      "Weyl tensor invariants â†’ Petrov type",
      "receipts: geodesics, lensing, waveforms"
    ],
    "equations": [
      "J = Î»|partition| âˆ’ w_fit (receipts) + w_Î¶ Î¶",
      "Accept partition if Î”J<0 and type labels persist under coarse meshing"
    ],
    "audits": [
      "E2: coordinate/gauge hygiene",
      "E3: small metric deformations cause predicted type transitions",
      "E4: minimal partition stable across discretizations"
    ],
    "nulls": ["finer partitions with no compression gain"],
    "steer": "Use the coarsest type map that still hits receipts.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.MATH.Mandelbrot_RGIslands.v1",
    "type": "principle",
    "title": "Mandelbrot/Julia RG Islands as Low-Order Tongues",
    "summary": "Treat hyperbolic components (bulbs) as KAM-like resonant islands labeled by small integers; accept maps where low-order bulbs compress bifurcation/period data best.",
    "defs": [
      "quadratic map zâ†¦z^2+c; period p bulbs; external angles (rationals)",
      "order cost ~ p+q (angle convergents)"
    ],
    "equations": [
      "Score J = Î»(p+q) âˆ’ w_fit (period windows/angles) + w_Î¶ Î¶",
      "Prediction: low-order bulbs persist under coarse sampling; high-order die"
    ],
    "audits": [
      "E1: stable period detection",
      "E3: tiny c nudges move captures per rotation numbers",
      "E4: low-order dominance under downsampling"
    ],
    "nulls": ["angle-scrambled surrogates"],
    "steer": "Prioritize lowest-order bulbs; demote ornate satellite chains first.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.FUSION.Ampli_Twistor_IntegrableFishnet.v1",
    "type": "principle",
    "title": "Amplituhedron Ã— Twistors Ã— Integrable Fishnet: Minimal Positive Ladders",
    "summary": "Choose the smallest positive-cell + ladder set that reproduces planar cuts and twistor constraints; penalize extra ladders/ facets.",
    "defs": [
      "momentum twistors Z_i; positive cells; ladder count L_d"
    ],
    "equations": [
      "J = Î»(Î£ order + L_d) âˆ’ w_C cuts âˆ’ w_U unitarity + w_Î¶ Î¶",
      "Accept if Î”J<0 vs Feynman sum and persists under kinematic coarse bins"
    ],
    "audits": [
      "E2: projective/positivity hygiene",
      "E3: small kinematic shifts move chosen cells/ladders coherently",
      "E4: minimal set stable under tessellation thinning"
    ],
    "nulls": ["ornate covers with no compression"],
    "steer": "Pick minimal facets + ladders; prune aggressively.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.POLAR.LocalCurved_vs.BoundaryFlat_Code.v1",
    "type": "principle",
    "title": "Polarity: Local Curved Bulk â†” Boundary Flat Code",
    "summary": "Select curved-bulk modeling or flat-boundary coding by MDL; require the winner to keep fits stable under coarse/refine cycles.",
    "defs": [
      "bulk code L_bulk (curvature params); boundary code L_bdry (flat cells/stabilizers)",
      "fit F; brittleness Î¶"
    ],
    "equations": [
      "Pick P* = argmin (L + w_Î¶ Î¶ âˆ’ w_F F) with equal receipts",
      "Reject if P* flips under Ã—2 mesh with no new receipts"
    ],
    "audits": [
      "E3: mesh edits change (L,Î¶,F) as predicted",
      "E4: polarity persistence under RG"
    ],
    "nulls": ["choices with longer code and higher Î¶"],
    "steer": "Stay with shorter code; switch only with MDL advantage.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.QRF.TimeCrystal_FrameChooser.v1",
    "type": "protocol",
    "title": "Quantum Reference Frames Ã— Time Crystals: Subharmonic Frame Chooser",
    "summary": "Use a time-crystal ancilla to pick the quantum frame that yields maximal 1:1 (or 2:1) phase locks and the shortest predictive code.",
    "defs": [
      "frames F_i; ancilla drive T â†’ response nT",
      "lock K_{p:q}, code L(F), Î¶ from heating"
    ],
    "equations": [
      "Choose F* maximizing K_{p:q} âˆ’ (L(F)+w_Î¶ Î¶)/Î» with p:qâˆˆ{1:1,2:1}",
      "Accept if Î”J<0 vs static frames and locks persist"
    ],
    "audits": [
      "E1: stable subharmonic peak",
      "E3: micro Î´t shifts move K and winner frame as predicted",
      "E4: selection stable under coarse time bins"
    ],
    "nulls": ["off-phase frame choices with same L"],
    "steer": "Lock 1:1 first; throttle drive to keep Î¶ low.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.BOOT.Celestial_SMatrix_MinIsland.v1",
    "type": "protocol",
    "title": "Celestial Bootstrap Ã— S-Matrix: Minimal Island with Soft Checks",
    "summary": "Carve S-matrix islands using celestial data and soft-charge stabilizers; accept the smallest island (fewest poles/low-â„“) passing all cuts.",
    "defs": [
      "partial waves a_â„“(s), poles; celestial OPE; soft stabilizers S_i"
    ],
    "equations": [
      "J = Î»(|S|+Î£ order â„“ + #poles) âˆ’ w_fit (celestial+S-matrix) + w_Î¶ Î¶",
      "Accept if Î”J<0 and island persists under discretization"
    ],
    "audits": [
      "E2: analytic/crossing/BMS hygiene",
      "E3: small pole/OPE changes shift island as predicted",
      "E4: minimal island stable under pooling"
    ],
    "nulls": ["ornate islands with no compression"],
    "steer": "Prune â„“ and poles first; keep soft checks sparse.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.GEO.SpaceFromSpectrum_Mirror_Selector.v1",
    "type": "principle",
    "title": "Space-from-Spectrum Ã— Mirror Symmetry: Joint MDL Selector",
    "summary": "Pick geometry via Laplacian spectra only if a mirror pair reduces total code (periods + spectra) with stable integer invariants.",
    "defs": [
      "eigenpairs (Î»_k,Ï†_k); mirror data (h^{p,q}, periods Î )",
      "shared integers ğ•€"
    ],
    "equations": [
      "Î”MDL = L_spec + L_mirror âˆ’ L_joint(ğ•€) âˆ’ Î»|ğ•€|",
      "Accept if Î”MDL>0 and Î¶ not â†‘ under truncation"
    ],
    "audits": [
      "E2: integrality/monodromy & gauge hygiene",
      "E3: small deformations map consistently across both codes",
      "E4: low-order ğ•€ persists when modes/periods thinned"
    ],
    "nulls": ["decorative mirrors increasing |ğ•€|"],
    "steer": "Keep minimal ğ•€ explaining both sectors; prune extras.",
    "version": "1.0",
    "updated": "2025-10-07"
  },
  {
    "id": "DELTA.ECO.SwarmRG_MinRules.v1",
    "type": "protocol",
    "title": "Swarm/Active Matter RG: Minimal Rulebook Selector",
    "summary": "Treat collective motion laws as CA-like micro-rules; choose the smallest rule/interaction set that compresses phase diagrams and correlation functions.",
    "defs": [
      "rule table R (alignment, attraction, noise), |R|",
      "macro receipts: structure factors, phase boundaries"
    ],
    "equations": [
      "J = Î»|R| âˆ’ w_fit (macro receipts) + w_Î¶ Î¶",
      "Accept if Î”J<0 and phases persist under decimation"
    ],
    "audits": [
      "E3: micro rule tweaks move phase boundaries predictably",
      "E4: minimal |R| stable under coarse binning"
    ],
    "nulls": ["bigger |R| with same macro fit"],
    "steer": "Prune rules until receipts degrade; keep minimal set.",
    "version": "1.0",
    "updated": "2025-10-07"
  }
]


